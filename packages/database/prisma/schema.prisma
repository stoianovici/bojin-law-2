// Prisma Schema for Legal Platform
// Generated for Story 2.2: Cloud Infrastructure and Database Setup
// Database: PostgreSQL 16 with pgvector extension

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
  binaryTargets   = ["native", "linux-musl-openssl-3.0.x", "debian-openssl-3.0.x"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [vector, uuid_ossp(map: "uuid-ossp"), pg_trgm]
}

// This is a minimal schema for Story 2.2 (infrastructure setup)
// Full schema will be added in later stories when implementing:
// - Story 2.4: Authentication (users, sessions) - IN PROGRESS
// - Story 2.6: Case Management (cases, parties, court_info)
// - Story 2.7: Document Management (documents, document_versions)
// - Story 2.8: Task Management (tasks, time_entries)

// Placeholder model to validate Prisma setup
// This will be replaced with actual models in future stories
model DatabaseHealth {
  id        String   @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  timestamp DateTime @default(now())
  status    String   @default("healthy")
  message   String?
  metadata  Json?

  @@map("database_health")
}

// ============================================================================
// Story 2.4: Authentication with Azure AD
// ============================================================================

// Firm model - law firm entity (Story 2.8.1)
model Firm {
  id           String   @id @default(uuid())
  name         String   @db.VarChar(200)
  defaultRates Json?    @map("default_rates") // { partnerRate: number, associateRate: number, paralegalRate: number }
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt    DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  users       User[]
  clients     Client[]
  cases       Case[]
  rateHistory CaseRateHistory[]
  approvals   CaseApproval[] // Story 2.8.2
  timeEntries TimeEntry[]

  // Relations (Story 2.8.4)
  documents         Document[]
  caseDocuments     CaseDocument[]
  documentAuditLogs DocumentAuditLog[]

  // Relations (Story 2.11.2)
  retainerUsage RetainerPeriodUsage[]

  // Relations (Story 3.6)
  batchReviews BatchReview[]

  // Relations (Story 4.2)
  tasks Task[]

  // Relations (Story 4.4)
  taskTemplates TaskTemplate[]

  // Custom case types
  caseTypeConfigs CaseTypeConfig[]

  // Custom actor types (OPS-220)
  actorTypeConfigs ActorTypeConfig[]

  // Relations (Story 5.1: Email Integration)
  emails Email[]

  // Relations (Story 5.2: Communication Intelligence)
  extractedDeadlines   ExtractedDeadline[]
  extractedCommitments ExtractedCommitment[]
  extractedActionItems ExtractedActionItem[]
  extractedQuestions   ExtractedQuestion[]
  riskIndicators       RiskIndicator[]
  threadSummaries      ThreadSummary[]

  // Relations (Story 5.3: Email Drafting)
  emailDrafts EmailDraft[]

  // Relations (Story 5.4: Proactive AI Suggestions)
  suggestions        AISuggestion[]
  userActionPatterns UserActionPattern[]
  morningBriefings   MorningBriefing[]

  // Relations (Story 5.5: Multi-Channel Communication Hub)
  communicationEntries   CommunicationEntry[]
  communicationTemplates CommunicationTemplate[]
  bulkCommunications     BulkCommunication[]
  communicationExports   CommunicationExport[]

  // Relations (Story 5.6: AI Learning and Personalization)
  writingStyleProfiles         WritingStyleProfile[]
  personalSnippets             PersonalSnippet[]
  taskCreationPatterns         TaskCreationPattern[]
  documentStructurePreferences DocumentStructurePreference[]
  responseTimePatterns         ResponseTimePattern[]
  draftEditHistory             DraftEditHistory[]

  // Relations (OPS-027: Multi-Case Classification)
  globalEmailSources GlobalEmailSource[]

  // Relations (OPS-031: Classification Review)
  classificationLogs     EmailClassificationLog[]
  pendingClassifications PendingClassification[]

  // Relations (OPS-063: AI Conversation)
  aiConversations AIConversation[]

  // Relations (OPS-089: Document Folders)
  documentFolders DocumentFolder[]

  // Relations (OPS-099: Mapa)
  mapaTemplates MapaTemplate[]

  // Relations (OPS-115: AI Context Files)
  activityEvents UserActivityEvent[]

  // Relations (OPS-279: Universal Draft Mode)
  sentEmailDrafts SentEmailDraft[]

  // Relations (Team Chat)
  teamChatMessages TeamChatMessage[]

  // Relations (Case History Redesign)
  caseChapters CaseChapter[]

  @@map("firms")
}

// User model for authentication and authorization
// Azure AD integration with automatic user provisioning
model User {
  id          String     @id @default(uuid())
  firmId      String?    @map("firm_id")
  email       String     @unique @db.VarChar(255)
  firstName   String     @map("first_name") @db.VarChar(100)
  lastName    String     @map("last_name") @db.VarChar(100)
  role        UserRole   @default(AssociateJr)
  status      UserStatus @default(Pending)
  azureAdId   String     @unique @map("azure_ad_id") @db.VarChar(255)
  preferences Json       @default("{}")
  createdAt   DateTime   @default(now()) @map("created_at") @db.Timestamptz
  lastActive  DateTime   @default(now()) @map("last_active") @db.Timestamptz

  // Relations (Story 2.4.1)
  auditLogsAsUser  UserAuditLog[] @relation("AuditLogUser")
  auditLogsAsAdmin UserAuditLog[] @relation("AuditLogAdmin")

  // Relations (Story 2.6)
  cases             CaseTeam[]
  assignedCases     CaseTeam[]     @relation("AssignedBy")
  caseAuditLogs     CaseAuditLog[]
  createdCaseActors CaseActor[]

  // Relations (Story 2.8.1)
  firm        Firm?             @relation(fields: [firmId], references: [id])
  rateChanges CaseRateHistory[]

  // Relations (Story 2.8.2)
  submittedApprovals CaseApproval[] @relation("CaseApprovalSubmitter")
  reviewedApprovals  CaseApproval[] @relation("CaseApprovalReviewer")
  notifications      Notification[]
  timeEntries        TimeEntry[]

  // Relations (Story 2.8.4)
  uploadedDocuments Document[]         @relation("DocumentUploader")
  linkedDocuments   CaseDocument[]     @relation("DocumentLinker")
  documentAuditLogs DocumentAuditLog[] @relation("DocumentAuditUser")

  // Relations (Story 2.9)
  documentVersions DocumentVersion[] @relation("DocumentVersionCreator")

  // Relations (OPS-171: Document Review Assignment)
  reviewingDocuments Document[] @relation("DocumentReviewer")

  // Relations (Story 3.6: Document Review)
  submittedReviews     DocumentReview[]     @relation("ReviewSubmitter")
  assignedReviews      DocumentReview[]     @relation("ReviewReviewer")
  reviewComments       ReviewComment[]      @relation("CommentAuthor")
  resolvedComments     ReviewComment[]      @relation("CommentResolver")
  commentReplies       ReviewCommentReply[] @relation("ReplyAuthor")
  reviewHistoryActions ReviewHistory[]      @relation("ReviewHistoryActor")
  createdBatchReviews  BatchReview[]        @relation("BatchReviewCreator")

  // Relations (Story 4.2: Task Management)
  assignedTasks     Task[]             @relation("TaskAssignee")
  createdTasks      Task[]             @relation("TaskCreator")
  taskAttendees     TaskAttendee[]
  taskDocumentLinks TaskDocumentLink[]
  delegationsFrom   TaskDelegation[]   @relation("DelegationDelegator")
  delegationsTo     TaskDelegation[]   @relation("DelegationDelegate")

  // Relations (Story 4.5: Team Workload Management)
  availabilities   UserAvailability[]    @relation("UserAvailabilities")
  delegatedFor     UserAvailability[]    @relation("UserDelegates")
  skills           UserSkill[]
  workloadSettings UserWorkloadSettings?

  // Relations (Story 4.6: Task Collaboration)
  taskComments       TaskComment[]       @relation("TaskCommentAuthor")
  taskHistoryActions TaskHistory[]       @relation("TaskHistoryActor")
  caseActivities     CaseActivityEntry[] @relation("CaseActivityActor")
  taskAttachments    TaskAttachment[]    @relation("TaskAttachmentUploader")
  caseSubscriptions  CaseSubscription[]

  // Custom case types created by this user
  createdCaseTypes CaseTypeConfig[]

  // Custom actor types created by this user (OPS-220)
  createdActorTypes ActorTypeConfig[] @relation("ActorTypeCreator")

  // Relations (Story 5.1: Email Integration)
  emails           Email[]
  emailSyncState   EmailSyncState?
  personalContacts PersonalContact[] // OPS-187: Personal email blocklist

  // Relations (Story 5.3: Email Drafting)
  emailDrafts EmailDraft[]

  // Relations (Story 5.4: Proactive AI Suggestions)
  suggestions      AISuggestion[]
  actionPatterns   UserActionPattern[]
  morningBriefings MorningBriefing[]

  // Relations (Story 5.5: Multi-Channel Communication Hub)
  sentCommunications   CommunicationEntry[]    @relation("CommunicationSender")
  createdTemplates     CommunicationTemplate[] @relation("TemplateCreator")
  bulkCommunications   BulkCommunication[]     @relation("BulkCommunicationCreator")
  communicationExports CommunicationExport[]   @relation("CommunicationExporter")

  // Relations (Story 5.6: AI Learning and Personalization)
  writingStyleProfile          WritingStyleProfile?
  personalSnippets             PersonalSnippet[]
  taskCreationPatterns         TaskCreationPattern[]
  documentStructurePreferences DocumentStructurePreference[]
  responseTimePatterns         ResponseTimePattern[]
  draftEditHistory             DraftEditHistory[]

  // Relations (OPS-031: Classification Review)
  classificationLogs      EmailClassificationLog[]
  resolvedClassifications PendingClassification[]

  // Relations (OPS-063: AI Conversation)
  aiConversations AIConversation[]

  // Relations (OPS-099: Mapa)
  createdMape          Mapa[]         @relation("MapaCreator")
  createdMapaTemplates MapaTemplate[] @relation("MapaTemplateCreator")
  assignedSlots        MapaSlot[]     @relation("SlotAssigner")

  // Relations (OPS-115: AI Context Files)
  activityEvents UserActivityEvent[]
  dailyContext   UserDailyContext?

  // Relations (OPS-120: Notifications)
  inAppNotifications InAppNotification[]
  pushSubscriptions  PushSubscription[]

  // Relations (OPS-178: Document Edit Sessions)
  documentEditSessions DocumentEditSession[] @relation("DocumentEditSessionUser")

  // Relations (OPS-279: Universal Draft Mode)
  sentEmailDrafts SentEmailDraft[]

  // Relations (Mobile: Case Notes)
  caseNotes CaseNote[]

  // Relations (Team Chat)
  sentChatMessages TeamChatMessage[] @relation("SentChatMessages")

  @@map("users")
}

// User roles within the law firm
enum UserRole {
  Partner
  Associate
  AssociateJr
  BusinessOwner // Story 2.11.1: Firm-wide financial data access
}

// User account status
// Pending: New user awaiting partner activation (Story 2.4.1)
// Active: User can access the system
// Inactive: User account disabled
enum UserStatus {
  Pending
  Active
  Inactive
}

// ============================================================================
// Story 2.4.1: Partner User Management
// ============================================================================

// Audit log for user management operations
// Tracks all user activation, deactivation, and role changes
model UserAuditLog {
  id          String          @id @default(uuid())
  userId      String          @map("user_id")
  action      UserAuditAction
  adminUserId String          @map("admin_user_id")
  oldValue    String?         @map("old_value") @db.VarChar(255)
  newValue    String?         @map("new_value") @db.VarChar(255)
  timestamp   DateTime        @default(now()) @db.Timestamptz

  user  User @relation("AuditLogUser", fields: [userId], references: [id])
  admin User @relation("AuditLogAdmin", fields: [adminUserId], references: [id])

  @@map("user_audit_logs")
}

// User audit actions for tracking management operations
enum UserAuditAction {
  Activated
  Deactivated
  RoleChanged
}

// ============================================================================
// Story 2.5: Microsoft Graph API Integration Foundation
// ============================================================================

// Graph API webhook subscriptions for email and file notifications
// Subscriptions expire every 3 days and require renewal
model GraphSubscription {
  id                 String    @id @default(uuid())
  subscriptionId     String    @unique @map("subscription_id") @db.VarChar(255)
  resource           String    @db.VarChar(500)
  changeTypes        String    @map("change_types") @db.VarChar(255)
  notificationUrl    String    @map("notification_url") @db.Text
  clientState        String?   @map("client_state") @db.VarChar(255)
  expirationDateTime DateTime  @map("expiration_datetime") @db.Timestamptz
  createdAt          DateTime  @default(now()) @map("created_at") @db.Timestamptz
  lastRenewedAt      DateTime? @map("last_renewed_at") @db.Timestamptz
  isActive           Boolean   @default(true) @map("is_active")

  @@index([expirationDateTime])
  @@index([isActive])
  @@map("graph_subscriptions")
}

// ============================================================================
// Story 2.6: Case Management Data Model and API
// ============================================================================

// Case status lifecycle
enum CaseStatus {
  PendingApproval
  Active
  OnHold
  Closed
  Archived
}

// Case type categorization (built-in types)
enum CaseType {
  Litigation
  Contract
  Advisory
  Criminal
  Other
}

// Custom case types per firm (user-defined)
model CaseTypeConfig {
  id        String   @id @default(uuid())
  firmId    String   @map("firm_id")
  name      String   @db.VarChar(100) // Display name in Romanian
  code      String   @db.VarChar(50) // Internal code (unique per firm)
  isActive  Boolean  @default(true) @map("is_active")
  sortOrder Int      @default(0) @map("sort_order")
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  createdBy String   @map("created_by")

  // Relations
  firm    Firm @relation(fields: [firmId], references: [id], onDelete: Cascade)
  creator User @relation(fields: [createdBy], references: [id], onDelete: Restrict)

  @@unique([firmId, code])
  @@index([firmId])
  @@map("case_type_configs")
}

// Custom actor types per firm (user-defined) - OPS-220
model ActorTypeConfig {
  id        String   @id @default(uuid())
  firmId    String   @map("firm_id")
  name      String   @db.VarChar(100) // Display name in Romanian
  code      String   @db.VarChar(50) // Internal code (unique per firm)
  isActive  Boolean  @default(true) @map("is_active")
  sortOrder Int      @default(0) @map("sort_order")
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  createdBy String   @map("created_by")

  // Relations
  firm    Firm @relation(fields: [firmId], references: [id], onDelete: Cascade)
  creator User @relation("ActorTypeCreator", fields: [createdBy], references: [id], onDelete: Restrict)

  @@unique([firmId, code])
  @@index([firmId])
  @@map("actor_type_configs")
}

// External party roles in a case
// OPS-219: Expanded for Romanian legal practice
enum CaseActorRole {
  Client
  OpposingParty
  OpposingCounsel
  Witness
  Expert
  Intervenient // Intervenient (third party joining case)
  Mandatar // Mandatar (legal representative with mandate)
  Court // Instanță (court/tribunal)
  Prosecutor // Procuror (prosecutor)
  Bailiff // Executor Judecătoresc (bailiff)
  Notary // Notar (notary)
  LegalRepresentative // Reprezentant Legal (legal representative)
  Other // OPS-125: Generic contact role for auto-added senders
}

// Global email source categories (OPS-027: Multi-Case Classification)
enum GlobalEmailSourceCategory {
  Court // Courts and tribunals
  Notary // Notary offices
  Bailiff // Bailiff offices (executori judecătorești)
  Authority // Government authorities
  Other // Other institutional sources
}

// Client entity - firm's client relationships
model Client {
  id          String   @id @default(uuid())
  firmId      String   @map("firm_id")
  name        String   @db.VarChar(200)
  contactInfo Json     @default("{}") @map("contact_info")
  address     String?  @db.Text
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  firm      Firm       @relation(fields: [firmId], references: [id], onDelete: Restrict)
  cases     Case[]
  documents Document[] // Story 2.8.4 - Documents owned by this client

  @@unique([firmId, name])
  @@index([firmId])
  @@map("clients")
}

// Global email source - firm-level shared addresses (courts, authorities) (OPS-027)
model GlobalEmailSource {
  id     String @id @default(uuid())
  firmId String @map("firm_id")

  category GlobalEmailSourceCategory // court, notary, authority, etc.
  name     String                    @db.VarChar(200) // "Tribunalul București"
  domains  String[]                  @default([]) // ["just.ro", "tribunalul-bucuresti.ro"]
  emails   String[]                  @default([]) // Specific email addresses

  // How to classify emails from this source
  classificationHint String? @map("classification_hint") @db.Text // "Match by reference number in subject"

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  firm Firm @relation(fields: [firmId], references: [id], onDelete: Cascade)

  @@index([firmId])
  @@index([category])
  @@map("global_email_sources")
}

// Billing type enum (Story 2.8.1, 2.11.2)
enum BillingType {
  Hourly
  Fixed
  Retainer // Story 2.11.2: Retainer billing support
}

// Retainer period enum (Story 2.11.2)
enum RetainerPeriod {
  Monthly
  Quarterly
  Annually
}

// Case entity - legal cases managed by the firm
model Case {
  id          String     @id @default(uuid())
  firmId      String     @map("firm_id")
  caseNumber  String     @map("case_number") @db.VarChar(100)
  title       String     @db.VarChar(500)
  clientId    String     @map("client_id")
  status      CaseStatus @default(Active)
  type        String     @db.VarChar(50) // Dynamic case type code (from CaseTypeConfig)
  description String     @db.Text
  openedDate  DateTime   @map("opened_date") @db.Date
  closedDate  DateTime?  @map("closed_date") @db.Date
  value       Decimal?   @db.Decimal(15, 2)
  metadata    Json       @default("{}")
  createdAt   DateTime   @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime   @updatedAt @map("updated_at") @db.Timestamptz

  // Billing fields (Story 2.8.1)
  billingType BillingType @default(Hourly) @map("billing_type")
  fixedAmount Decimal?    @map("fixed_amount") @db.Decimal(15, 2)
  customRates Json?       @map("custom_rates") // { partnerRate?: number, associateRate?: number, paralegalRate?: number }

  // Retainer fields (Story 2.11.2)
  retainerAmount    Decimal?        @map("retainer_amount") @db.Decimal(15, 2)
  retainerPeriod    RetainerPeriod? @map("retainer_period")
  retainerRollover  Boolean         @default(false) @map("retainer_rollover")
  retainerAutoRenew Boolean         @default(false) @map("retainer_auto_renew")

  // Search fields (Story 2.10)
  searchText       String?                     @map("search_text") @db.Text // Concatenated searchable text for full-text search
  contentEmbedding Unsupported("vector(768)")? @map("content_embedding") // multilingual-e5-base embedding for semantic search

  // OPS-237: AI-generated search terms for fuzzy search
  searchTerms          String?   @map("search_terms") @db.Text // Space-separated terms (abbreviations, alternates, entities, tags)
  searchTermsUpdatedAt DateTime? @map("search_terms_updated_at") @db.Timestamptz // When search terms were last generated

  // Email classification fields (OPS-027: Multi-Case Classification)
  keywords            String[] @default([]) // User-defined terms for matching emails to this case
  referenceNumbers    String[] @default([]) @map("reference_numbers") // Court file numbers, contract refs (e.g., "1234/5/2024")
  subjectPatterns     String[] @default([]) @map("subject_patterns") // Email subject patterns (glob-style)
  classificationNotes String?  @map("classification_notes") @db.Text // Free text guidance for AI classifier

  // Relations
  firm           Firm                  @relation(fields: [firmId], references: [id], onDelete: Restrict)
  client         Client                @relation(fields: [clientId], references: [id], onDelete: Restrict)
  teamMembers    CaseTeam[]
  auditLogs      CaseAuditLog[]
  actors         CaseActor[]
  rateHistory    CaseRateHistory[]
  approval       CaseApproval? // Story 2.8.2 - Only present for cases requiring approval
  timeEntries    TimeEntry[]
  documents      CaseDocument[] // Story 2.8.4 - Documents linked to this case
  retainerUsage  RetainerPeriodUsage[] // Story 2.11.2 - Retainer usage tracking
  tasks          Task[] // Story 4.2 - Tasks for this case
  templateUsages TaskTemplateUsage[] // Story 4.4 - Template applications to this case
  activityFeed   CaseActivityEntry[] // Story 4.6 - Activity feed for this case
  subscriptions  CaseSubscription[] // Story 4.6 - User subscriptions for this case
  emails         Email[] // Story 5.1 - Emails linked to this case (legacy, use emailLinks)
  emailLinks     EmailCaseLink[] // OPS-058: Multi-case email support

  // Relations (Story 5.2: Communication Intelligence)
  extractedDeadlines   ExtractedDeadline[]
  extractedCommitments ExtractedCommitment[]
  extractedActionItems ExtractedActionItem[]
  extractedQuestions   ExtractedQuestion[]
  riskIndicators       RiskIndicator[]
  threadSummaries      ThreadSummary[]

  // Relations (Story 5.3: Email Drafting)
  emailDrafts EmailDraft[]

  // Relations (Story 5.4: Proactive AI Suggestions)
  suggestions AISuggestion[]

  // Relations (Story 5.5: Multi-Channel Communication Hub)
  communicationEntries CommunicationEntry[]
  bulkCommunications   BulkCommunication[]
  communicationExports CommunicationExport[]

  // Relations (OPS-031: Classification Review)
  classificationLogsFrom EmailClassificationLog[] @relation("ClassificationFromCase")
  classificationLogsTo   EmailClassificationLog[] @relation("ClassificationToCase")

  // Relations (OPS-046: Persistent AI Case Summary)
  summary CaseSummary?

  // Relations (OPS-063: AI Conversation)
  aiConversations AIConversation[]

  // Relations (OPS-089: Document Folders)
  documentFolders DocumentFolder[]

  // Relations (OPS-099: Mapa)
  mape Mapa[]

  // Relations (OPS-115: AI Context Files)
  briefing CaseBriefing?

  // Relations (OPS-239: Case Health Scoring)
  healthScores CaseHealthScore[]

  // Relations (OPS-279: Universal Draft Mode)
  sentEmailDrafts SentEmailDraft[]

  // Relations (Case History Redesign)
  chapters CaseChapter[]

  // Relations (Mobile: Case Notes)
  notes CaseNote[]

  // Relations (Historical Email Sync)
  historicalEmailSyncJobs HistoricalEmailSyncJob[]

  @@unique([firmId, caseNumber])
  @@index([firmId])
  @@index([clientId])
  @@index([status])
  @@index([openedDate])
  @@map("cases")
}

// Case team assignments - many-to-many between Case and User
model CaseTeam {
  id         String   @id @default(uuid())
  caseId     String   @map("case_id")
  userId     String   @map("user_id")
  role       String   @db.VarChar(50)
  assignedAt DateTime @default(now()) @map("assigned_at") @db.Timestamptz
  assignedBy String?  @map("assigned_by")

  // Relations
  case     Case  @relation(fields: [caseId], references: [id], onDelete: Cascade)
  user     User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  assigner User? @relation("AssignedBy", fields: [assignedBy], references: [id], onDelete: SetNull)

  @@unique([caseId, userId])
  @@index([caseId])
  @@index([userId])
  @@map("case_team")
}

// Case notes - sticky notes attached to cases (Mobile feature)
model CaseNote {
  id        String   @id @default(uuid())
  caseId    String   @map("case_id")
  firmId    String   @map("firm_id")
  authorId  String   @map("author_id")
  content   String   @db.Text
  color     String   @default("yellow") @db.VarChar(20) // yellow, blue, green, pink
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  case   Case @relation(fields: [caseId], references: [id], onDelete: Cascade)
  author User @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([caseId])
  @@index([firmId])
  @@index([authorId])
  @@map("case_notes")
}

// Case audit log - tracks all case modifications
model CaseAuditLog {
  id        String   @id @default(uuid())
  caseId    String   @map("case_id")
  userId    String?  @map("user_id")
  action    String   @db.VarChar(100)
  fieldName String?  @map("field_name") @db.VarChar(100)
  oldValue  String?  @map("old_value") @db.Text
  newValue  String?  @map("new_value") @db.Text
  timestamp DateTime @default(now()) @db.Timestamptz

  // Relations
  case Case  @relation(fields: [caseId], references: [id], onDelete: Cascade)
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([caseId])
  @@index([timestamp])
  @@map("case_audit_logs")
}

// Case actors - external parties involved in the case
model CaseActor {
  id             String        @id @default(uuid())
  caseId         String        @map("case_id")
  role           CaseActorRole
  customRoleCode String?       @map("custom_role_code") @db.VarChar(50) // OPS-220: References ActorTypeConfig.code when set
  name           String        @db.VarChar(200)
  organization   String?       @db.VarChar(200)
  email          String?       @db.VarChar(255)
  phone          String?       @db.VarChar(50)
  address        String?       @db.Text
  notes          String?       @db.Text
  createdAt      DateTime      @default(now()) @map("created_at") @db.Timestamptz
  updatedAt      DateTime      @updatedAt @map("updated_at") @db.Timestamptz
  createdBy      String?       @map("created_by")

  // Email classification (OPS-027: Multi-Case Classification)
  emailDomains String[] @default([]) @map("email_domains") // Additional email domains for this actor

  // Relations
  case    Case  @relation(fields: [caseId], references: [id], onDelete: Cascade)
  creator User? @relation(fields: [createdBy], references: [id], onDelete: SetNull)

  @@index([caseId])
  @@map("case_actors")
}

// ============================================================================
// Story 2.8.2: Case Approval Workflow
// ============================================================================

// Approval status for case review workflow
enum ApprovalStatus {
  Pending
  Approved
  Rejected
}

// Case approval tracking - one record per case requiring approval
model CaseApproval {
  id              String         @id @default(uuid())
  caseId          String         @unique @map("case_id")
  submittedBy     String         @map("submitted_by")
  submittedAt     DateTime       @default(now()) @map("submitted_at") @db.Timestamptz
  reviewedBy      String?        @map("reviewed_by")
  reviewedAt      DateTime?      @map("reviewed_at") @db.Timestamptz
  status          ApprovalStatus @default(Pending)
  rejectionReason String?        @map("rejection_reason") @db.Text
  revisionCount   Int            @default(0) @map("revision_count")
  firmId          String         @map("firm_id")

  // Relations
  case      Case  @relation(fields: [caseId], references: [id], onDelete: Cascade)
  submitter User  @relation("CaseApprovalSubmitter", fields: [submittedBy], references: [id], onDelete: Restrict)
  reviewer  User? @relation("CaseApprovalReviewer", fields: [reviewedBy], references: [id], onDelete: SetNull)
  firm      Firm  @relation(fields: [firmId], references: [id], onDelete: Restrict)

  @@index([caseId])
  @@index([status])
  @@index([submittedBy])
  @@index([firmId])
  @@map("case_approvals")
}

// ============================================================================
// Story 2.8.2: Case Approval Workflow - Notifications
// ============================================================================

// Notification types for approval workflow events
enum NotificationType {
  // Existing (Story 2.8.2)
  CasePendingApproval // Partner notification when case submitted for approval
  CaseApproved // Associate notification when case approved
  CaseRejected // Associate notification when case rejected
  // Story 3.6: Document Review Notifications
  DocumentReviewRequested // Notification when document is submitted for review
  DocumentReviewAssigned // Notification when assigned as reviewer
  DocumentApproved // Notification when document is approved
  DocumentRejected // Notification when document is rejected
  DocumentRevisionRequested // Notification when revision is requested
  DocumentCommentAdded // Notification when comment is added to review
  DocumentCommentMentioned // Notification when user is @mentioned in comment
  // Story 4.2: Task Delegation Notifications
  DelegationRequested // When delegation is created, sent to delegate
  DelegationAccepted // When delegate accepts, sent to delegator
  DelegationDeclined // When delegate declines, sent to delegator
  // Story 4.4: Task Reminder and Dependency Notifications
  TaskDeadlineReminder // Reminder for approaching deadline
  TaskOverdue // Task is past due date
  DependencyBlocked // Task blocked by incomplete dependency
  DependencyUnblocked // Blocked task now unblocked
  // Story 4.6: Task Collaboration Notifications
  TaskCommentAdded // When comment is added to task
  TaskCommentMentioned // When @mentioned in task comment
  TaskCommentReplied // When someone replies to your comment
  TaskStatusUpdated // When task status changes
  SubtaskCreated // When subtask is added to your task
  TaskAttachmentAdded // When attachment is added to task
  // Story 5.4: Proactive AI Suggestions Notifications
  MorningBriefingReady // When AI morning briefing is generated
  AISuggestionCreated // When new AI suggestion is available
  // Story 5.5: Communication Hub Notifications
  BulkCommunicationCompleted // When bulk communication job completes
  CommunicationExportReady // When communication export is ready for download
}

// In-app notifications for users
model Notification {
  id        String           @id @default(uuid())
  userId    String           @map("user_id")
  type      NotificationType
  title     String           @db.VarChar(200)
  message   String           @db.Text
  link      String?          @db.VarChar(500) // Deep link to case detail page
  read      Boolean          @default(false)
  caseId    String?          @map("case_id") // Reference to related case
  taskId    String?          @map("task_id") // Story 4.6: Reference to related task
  createdAt DateTime         @default(now()) @map("created_at") @db.Timestamptz
  readAt    DateTime?        @map("read_at") @db.Timestamptz

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([read])
  @@index([createdAt])
  @@map("notifications")
}

// ============================================================================
// Story 2.8.1: Billing & Rate Management
// ============================================================================

// Rate type enum for rate history tracking
enum RateType {
  partner
  associate
  paralegal
  fixed
}

// Case rate history - tracks all rate changes for audit trail
model CaseRateHistory {
  id        String   @id @default(uuid())
  caseId    String   @map("case_id")
  changedAt DateTime @default(now()) @map("changed_at") @db.Timestamptz
  changedBy String   @map("changed_by")
  rateType  RateType @map("rate_type")
  oldRate   Decimal  @map("old_rate") @db.Decimal(15, 2)
  newRate   Decimal  @map("new_rate") @db.Decimal(15, 2)
  firmId    String   @map("firm_id")

  // Relations
  case    Case @relation(fields: [caseId], references: [id], onDelete: Cascade)
  changer User @relation(fields: [changedBy], references: [id], onDelete: Restrict)
  firm    Firm @relation(fields: [firmId], references: [id], onDelete: Restrict)

  @@index([caseId])
  @@index([changedAt])
  @@index([firmId])
  @@map("case_rate_history")
}

// ============================================================================
// Time Entry Model - for KPI calculations and billing
// ============================================================================

model TimeEntry {
  id          String   @id @default(uuid())
  caseId      String   @map("case_id")
  userId      String   @map("user_id")
  taskId      String?  @map("task_id") // Story 4.3: Optional task relation for time tracking
  date        DateTime @db.Date
  hours       Decimal  @db.Decimal(5, 2)
  hourlyRate  Decimal  @map("hourly_rate") @db.Decimal(15, 2)
  description String   @db.Text
  narrative   String?  @db.Text // Story 4.3: Detailed billing narrative for clarity
  billable    Boolean  @default(true)
  firmId      String   @map("firm_id")
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  case Case  @relation(fields: [caseId], references: [id], onDelete: Cascade)
  user User  @relation(fields: [userId], references: [id], onDelete: Restrict)
  firm Firm  @relation(fields: [firmId], references: [id], onDelete: Restrict)
  task Task? @relation(fields: [taskId], references: [id], onDelete: SetNull) // Story 4.3

  @@index([caseId])
  @@index([userId])
  @@index([taskId]) // Story 4.3
  @@index([date])
  @@index([firmId])
  @@map("time_entries")
}

// ============================================================================
// Story 2.8.4: Cross-Case Document Linking
// ============================================================================

// Document status enum (Story 2.9)
// OPS-172: Extended with review workflow states
enum DocumentStatus {
  DRAFT // Working copy, editable
  IN_REVIEW // Submitted for supervisor review
  CHANGES_REQUESTED // Supervisor requested modifications
  PENDING // Legacy - awaiting processing
  FINAL // Approved, locked
  ARCHIVED // Historical, not active
}

// OPS-114: Thumbnail generation status
enum ThumbnailStatus {
  PENDING // Not yet generated
  PROCESSING // Currently being generated
  COMPLETED // Successfully generated
  FAILED // Generation failed
  NOT_SUPPORTED // File type doesn't support thumbnails
}

// OPS-171: Document source type - distinguishes origin of document
enum DocumentSourceType {
  UPLOAD // Directly uploaded by user
  EMAIL_ATTACHMENT // Saved from email attachment
  AI_GENERATED // Created by AI drafting service
  TEMPLATE // Generated from template
}

// Document entity - owned by Client (not Case) for cross-case sharing
// Documents are stored at the client level and can be linked to multiple cases
// Story 2.9: Extended with OneDrive integration fields
model Document {
  id          String   @id @default(uuid())
  clientId    String   @map("client_id")
  firmId      String   @map("firm_id")
  fileName    String   @map("file_name") @db.VarChar(500)
  fileType    String   @map("file_type") @db.VarChar(100)
  fileSize    Int      @map("file_size") // Size in bytes
  storagePath String   @map("storage_path") @db.Text // Path: /{firmId}/clients/{clientId}/documents/{documentId}-{fileName}
  uploadedBy  String   @map("uploaded_by")
  uploadedAt  DateTime @default(now()) @map("uploaded_at") @db.Timestamptz
  metadata    Json     @default("{}") // Tags, description, etc.
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Story 2.9: OneDrive integration fields
  oneDriveId     String?        @map("one_drive_id") @db.VarChar(255) // OneDrive item ID
  oneDrivePath   String?        @map("one_drive_path") @db.Text // Full OneDrive path
  oneDriveUserId String?        @map("one_drive_user_id") @db.VarChar(255) // OPS-104: MS Graph user ID of the OneDrive owner (for cross-user access)
  status         DocumentStatus @default(DRAFT) // Document status

  // OPS-107: SharePoint migration fields
  sharePointItemId String? @map("share_point_item_id") @db.VarChar(255) // SharePoint item ID
  sharePointPath   String? @map("share_point_path") @db.Text // Full SharePoint path

  // OPS-114: Permanent thumbnail URLs stored in R2
  thumbnailSmallUrl  String?         @map("thumbnail_small_url") @db.Text // 48x48 R2 URL
  thumbnailMediumUrl String?         @map("thumbnail_medium_url") @db.Text // 200x200 R2 URL
  thumbnailLargeUrl  String?         @map("thumbnail_large_url") @db.Text // 800x800 R2 URL
  thumbnailStatus    ThumbnailStatus @default(PENDING) @map("thumbnail_status")
  thumbnailError     String?         @map("thumbnail_error") @db.VarChar(500)

  // Search fields (Story 2.10)
  metadataEmbedding Unsupported("vector(768)")? @map("metadata_embedding") // multilingual-e5-base embedding for semantic search

  // OPS-237: AI-generated search terms for fuzzy search
  searchTerms          String?   @map("search_terms") @db.Text // Space-separated terms (abbreviations, alternates, entities, tags)
  searchTermsUpdatedAt DateTime? @map("search_terms_updated_at") @db.Timestamptz // When search terms were last generated

  // OPS-171: Document source type and review fields
  sourceType  DocumentSourceType @default(UPLOAD) @map("source_type")
  reviewerId  String?            @map("reviewer_id")
  submittedAt DateTime?          @map("submitted_at") @db.Timestamptz // When submitted for review

  // OPS-178: SharePoint edit session tracking
  sharePointLastModified DateTime? @map("share_point_last_modified") @db.Timestamptz // Last known SP modified time
  sharePointETag         String?   @map("share_point_etag") @db.VarChar(255) // SharePoint eTag for change detection

  // Relations
  client                   Client                      @relation(fields: [clientId], references: [id], onDelete: Restrict)
  firm                     Firm                        @relation(fields: [firmId], references: [id], onDelete: Restrict)
  uploader                 User                        @relation("DocumentUploader", fields: [uploadedBy], references: [id], onDelete: Restrict)
  reviewer                 User?                       @relation("DocumentReviewer", fields: [reviewerId], references: [id], onDelete: SetNull)
  caseLinks                CaseDocument[] // Cases this document is linked to
  auditLogs                DocumentAuditLog[]
  versions                 DocumentVersion[] // Story 2.9: Version history
  semanticChanges          SemanticChange[] // Story 3.5: Semantic changes
  reviews                  DocumentReview[] // Story 3.6: Document reviews
  taskLinks                TaskDocumentLink[] // Story 4.2: Tasks linked to this document
  taskAttachments          TaskAttachment[] // Story 4.6: Task attachments linked to this document
  emailAttachments         EmailAttachment[] // Story 5.1: Email attachments linked to this document
  attachmentSuggestions    AttachmentSuggestion[] // Story 5.3: Suggested attachments for email drafts
  completenessChecks       DocumentCompletenessCheck[] // Story 5.4: Document completeness checks
  communicationAttachments CommunicationAttachment[] // Story 5.5: Communication attachments
  editSession              DocumentEditSession? // OPS-178: Active edit session for change detection

  @@index([clientId])
  @@index([firmId])
  @@index([uploadedAt])
  @@index([fileName])
  @@index([oneDriveId])
  @@index([sharePointItemId]) // OPS-107
  @@index([thumbnailStatus]) // OPS-114
  @@index([sourceType]) // OPS-171
  @@index([reviewerId]) // OPS-171
  @@map("documents")
}

// CaseDocument join table - many-to-many relationship between Case and Document
// Allows same document to be linked to multiple cases without duplication
model CaseDocument {
  id         String   @id @default(uuid())
  caseId     String   @map("case_id")
  documentId String   @map("document_id")
  linkedBy   String   @map("linked_by")
  linkedAt   DateTime @default(now()) @map("linked_at") @db.Timestamptz
  isOriginal Boolean  @default(false) @map("is_original") // True if document was uploaded to this case
  firmId     String   @map("firm_id")
  folderId   String?  @map("folder_id") // OPS-089: Optional folder for document organization

  // OPS-171: Promotion tracking from email attachment
  promotedFromAttachment Boolean @default(false) @map("promoted_from_attachment")
  originalAttachmentId   String? @map("original_attachment_id") // Reference to EmailAttachment if promoted

  // Relations
  case               Case             @relation(fields: [caseId], references: [id], onDelete: Cascade)
  document           Document         @relation(fields: [documentId], references: [id], onDelete: Cascade)
  linker             User             @relation("DocumentLinker", fields: [linkedBy], references: [id], onDelete: Restrict)
  firm               Firm             @relation(fields: [firmId], references: [id], onDelete: Restrict)
  folder             DocumentFolder?  @relation(fields: [folderId], references: [id], onDelete: SetNull)
  originalAttachment EmailAttachment? @relation("PromotedFromAttachment", fields: [originalAttachmentId], references: [id], onDelete: SetNull)

  // Relations (OPS-099: Mapa)
  mapaSlots MapaSlot[] // Document can be assigned to multiple mapa slots

  @@unique([caseId, documentId]) // Prevent duplicate links
  @@index([caseId])
  @@index([documentId])
  @@index([firmId])
  @@index([folderId])
  @@index([promotedFromAttachment]) // OPS-171
  @@map("case_documents")
}

// Document folder hierarchy for organizing documents within cases (OPS-089)
model DocumentFolder {
  id        String   @id @default(uuid())
  name      String   @db.VarChar(255)
  caseId    String   @map("case_id")
  parentId  String?  @map("parent_id")
  order     Int      @default(0)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz
  firmId    String   @map("firm_id")

  // Relations
  case      Case             @relation(fields: [caseId], references: [id], onDelete: Cascade)
  parent    DocumentFolder?  @relation("FolderHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children  DocumentFolder[] @relation("FolderHierarchy")
  documents CaseDocument[]
  firm      Firm             @relation(fields: [firmId], references: [id], onDelete: Restrict)

  @@index([caseId])
  @@index([parentId])
  @@index([firmId])
  @@map("document_folders")
}

// Document audit action types
enum DocumentAuditAction {
  Uploaded // Document was uploaded
  LinkedToCase // Document linked to a case
  UnlinkedFromCase // Document unlinked from a case
  PermanentlyDeleted // Document permanently deleted (Partners only)
  MetadataUpdated // Document metadata was updated
}

// Document audit log - tracks all document operations
model DocumentAuditLog {
  id         String              @id @default(uuid())
  documentId String?             @map("document_id") // Nullable for permanent delete (document no longer exists)
  userId     String              @map("user_id")
  action     DocumentAuditAction
  caseId     String?             @map("case_id") // Related case for link/unlink operations
  details    Json                @default("{}") // Additional details (fileName, affectedCaseCount, etc.)
  timestamp  DateTime            @default(now()) @db.Timestamptz
  firmId     String              @map("firm_id")

  // Relations
  document Document? @relation(fields: [documentId], references: [id], onDelete: SetNull)
  user     User      @relation("DocumentAuditUser", fields: [userId], references: [id], onDelete: Restrict)
  firm     Firm      @relation(fields: [firmId], references: [id], onDelete: Restrict)

  @@index([documentId])
  @@index([userId])
  @@index([caseId])
  @@index([timestamp])
  @@index([firmId])
  @@map("document_audit_logs")
}

// ============================================================================
// Story 2.9: Document Version Tracking
// ============================================================================

// Document version for tracking changes from OneDrive sync
model DocumentVersion {
  id                String   @id @default(uuid())
  documentId        String   @map("document_id")
  versionNumber     Int      @map("version_number")
  oneDriveVersionId String?  @map("one_drive_version_id") @db.VarChar(255)
  changesSummary    String?  @map("changes_summary") @db.Text
  createdBy         String   @map("created_by")
  createdAt         DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  document            Document                 @relation(fields: [documentId], references: [id], onDelete: Cascade)
  creator             User                     @relation("DocumentVersionCreator", fields: [createdBy], references: [id], onDelete: Restrict)
  // Story 3.5: Semantic version control relations
  semanticChangesFrom SemanticChange[]         @relation("SemanticChangeFromVersion")
  semanticChangesTo   SemanticChange[]         @relation("SemanticChangeToVersion")
  comparisonCacheFrom VersionComparisonCache[] @relation("CacheFromVersion")
  comparisonCacheTo   VersionComparisonCache[] @relation("CacheToVersion")
  // Story 3.6: Document review relations
  reviews             DocumentReview[]

  @@unique([documentId, versionNumber])
  @@index([documentId])
  @@map("document_versions")
}

// OPS-178: Track active document edit sessions for SharePoint change detection
// When a user opens a document in Word, we record the baseline SharePoint state
// so we can detect if they made changes when we next access the document
model DocumentEditSession {
  id                     String    @id @default(uuid())
  documentId             String    @unique @map("document_id") // One active session per document
  userId                 String    @map("user_id")
  startedAt              DateTime  @default(now()) @map("started_at") @db.Timestamptz
  sharePointLastModified DateTime? @map("share_point_last_modified") @db.Timestamptz // Baseline SP modified time
  sharePointETag         String?   @map("share_point_etag") @db.VarChar(255) // Baseline eTag
  lockToken              String    @map("lock_token") @db.VarChar(255) // Unique token for this edit session

  // Relations
  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  user     User     @relation("DocumentEditSessionUser", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([startedAt])
  @@map("document_edit_sessions")
}

// ============================================================================
// Story 2.10: Basic AI Search Implementation
// ============================================================================

// Search type enum for categorizing search methods
enum SearchType {
  FullText
  Semantic
  Hybrid
}

// Search history for caching recent searches and analytics
model SearchHistory {
  id          String     @id @default(uuid())
  userId      String     @map("user_id")
  firmId      String     @map("firm_id")
  query       String     @db.VarChar(500)
  searchType  SearchType @map("search_type")
  filters     Json?      @default("{}") // { dateRange?, caseTypes?, documentTypes?, etc. }
  resultCount Int        @map("result_count")
  createdAt   DateTime   @default(now()) @map("created_at") @db.Timestamptz

  @@index([userId, createdAt])
  @@index([firmId])
  @@index([query])
  @@map("search_history")
}

// ============================================================================
// Story 2.11.2: Retainer Billing Support
// ============================================================================

// Retainer period usage - tracks usage per billing period for retainer cases
model RetainerPeriodUsage {
  id            String   @id @default(uuid())
  caseId        String   @map("case_id")
  firmId        String   @map("firm_id")
  periodStart   DateTime @map("period_start") @db.Date
  periodEnd     DateTime @map("period_end") @db.Date
  hoursUsed     Decimal  @default(0) @map("hours_used") @db.Decimal(10, 2)
  hoursIncluded Decimal  @map("hours_included") @db.Decimal(10, 2)
  rolledOver    Decimal  @default(0) @map("rolled_over") @db.Decimal(10, 2)
  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)
  firm Firm @relation(fields: [firmId], references: [id], onDelete: Restrict)

  @@unique([caseId, periodStart])
  @@index([caseId])
  @@index([firmId])
  @@index([periodStart])
  @@map("retainer_period_usage")
}

// ============================================================================
// Story 3.1: AI Service Infrastructure
// ============================================================================

// AI Token Usage - tracks all AI API calls for cost monitoring and analysis
model AITokenUsage {
  id            String   @id @default(uuid())
  userId        String?  @map("user_id")
  caseId        String?  @map("case_id")
  firmId        String   @map("firm_id")
  operationType String   @map("operation_type") @db.VarChar(100)
  modelUsed     String   @map("model_used") @db.VarChar(100)
  inputTokens   Int      @map("input_tokens")
  outputTokens  Int      @map("output_tokens")
  totalTokens   Int      @map("total_tokens")
  costCents     Int      @map("cost_cents")
  latencyMs     Int      @map("latency_ms")
  cached        Boolean  @default(false)
  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@index([userId, createdAt])
  @@index([caseId])
  @@index([firmId, createdAt])
  @@index([operationType])
  @@map("ai_token_usage")
}

// AI Response Cache - semantic similarity cache for reducing duplicate API calls
model AIResponseCache {
  id              String                      @id @default(uuid())
  promptHash      String                      @unique @map("prompt_hash") @db.VarChar(64)
  promptEmbedding Unsupported("vector(768)")? @map("prompt_embedding") // multilingual-e5-base embedding
  prompt          String                      @db.Text
  response        String                      @db.Text
  modelUsed       String                      @map("model_used") @db.VarChar(100)
  operationType   String                      @map("operation_type") @db.VarChar(100)
  firmId          String                      @map("firm_id")
  hitCount        Int                         @default(0) @map("hit_count")
  createdAt       DateTime                    @default(now()) @map("created_at") @db.Timestamptz
  expiresAt       DateTime                    @map("expires_at") @db.Timestamptz

  @@index([firmId])
  @@index([operationType])
  @@index([expiresAt])
  @@map("ai_response_cache")
}

// AIFeatureConfig - per-feature toggles and budget controls (OPS-234)
model AIFeatureConfig {
  id     String @id @default(uuid())
  firmId String @map("firm_id")

  // Feature identifier (e.g., 'assistant_chat', 'search_index', 'morning_briefings')
  feature String @db.VarChar(100)

  // Enable/disable toggle
  enabled Boolean @default(true)

  // Budget controls (EUR for Romanian firm)
  monthlyBudgetEur Decimal? @map("monthly_budget_eur") @db.Decimal(10, 2)
  dailyLimitEur    Decimal? @map("daily_limit_eur") @db.Decimal(10, 2)

  // Batch job schedule (cron format, e.g., '0 3 * * *' for 3 AM daily)
  schedule String? @db.VarChar(50)

  // Claude model to use for this feature (null = use default: claude-sonnet-4-20250514)
  model String? @db.VarChar(100)

  // Audit
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz
  updatedBy String   @map("updated_by") // User ID who last updated

  @@unique([firmId, feature])
  @@index([firmId])
  @@map("ai_feature_configs")
}

// ============================================================================
// Story 3.2.5: Legacy Document Import & Categorization for AI Training
// ============================================================================

// Import session status lifecycle
enum ImportSessionStatus {
  Uploading // PST file being uploaded
  Extracting // PST being processed
  InProgress // Categorization in progress
  Completed // All documents categorized
  Exported // Exported to OneDrive
}

// Primary language detection results
enum PrimaryLanguage {
  Romanian
  English
  Italian
  French
  Mixed
}

// Template potential rating
enum TemplatePotential {
  High // >80% standard structure
  Medium // 50-80% standard
  Low // <50% standard
}

// Document structure type
enum StructureType {
  structured
  semi_structured @map("semi-structured")
  unstructured
}

// Legacy import session - one per PST file upload
model LegacyImportSession {
  id                 String              @id @default(uuid())
  firmId             String              @map("firm_id")
  pstFileName        String              @map("pst_file_name") @db.VarChar(500)
  pstFileSize        BigInt              @map("pst_file_size") // Size in bytes
  pstStoragePath     String?             @map("pst_storage_path") @db.Text // Cloudflare R2 path
  uploadedBy         String              @map("uploaded_by") // User ID (Partner)
  status             ImportSessionStatus @default(Uploading)
  totalDocuments     Int                 @default(0) @map("total_documents")
  categorizedCount   Int                 @default(0) @map("categorized_count")
  skippedCount       Int                 @default(0) @map("skipped_count")
  analyzedCount      Int                 @default(0) @map("analyzed_count") // AI analysis count
  extractionErrors   Json?               @map("extraction_errors") // Error log from PST extraction
  extractionProgress Json?               @map("extraction_progress") // Track resumable extraction: {totalInPst, extractedCount, isComplete}
  createdAt          DateTime            @default(now()) @map("created_at") @db.Timestamptz
  updatedAt          DateTime            @updatedAt @map("updated_at") @db.Timestamptz
  exportedAt         DateTime?           @map("exported_at") @db.Timestamptz
  cleanupScheduledAt DateTime?           @map("cleanup_scheduled_at") @db.Timestamptz // When R2 cleanup is scheduled (7 days after export)
  cleanedUpAt        DateTime?           @map("cleaned_up_at") @db.Timestamptz // When R2 files were actually deleted
  lastSnapshotAt     DateTime?           @map("last_snapshot_at") @db.Timestamptz // When last categorization snapshot was taken

  // Relations
  batches        DocumentBatch[]
  documents      ExtractedDocument[]
  categories     ImportCategory[]
  processingLogs AIProcessingLog[]

  @@index([firmId])
  @@index([uploadedBy])
  @@index([status])
  @@index([createdAt])
  @@map("legacy_import_sessions")
}

// Document batch - groups documents by month for assistant allocation
model DocumentBatch {
  id               String    @id @default(uuid())
  sessionId        String    @map("session_id")
  monthYear        String    @map("month_year") @db.VarChar(7) // 'YYYY-MM' format
  assignedTo       String?   @map("assigned_to") // User ID (Assistant)
  documentCount    Int       @map("document_count")
  categorizedCount Int       @default(0) @map("categorized_count")
  skippedCount     Int       @default(0) @map("skipped_count")
  assignedAt       DateTime? @map("assigned_at") @db.Timestamptz
  completedAt      DateTime? @map("completed_at") @db.Timestamptz
  createdAt        DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt        DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  session   LegacyImportSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  documents ExtractedDocument[]

  @@unique([sessionId, monthYear])
  @@index([sessionId])
  @@index([assignedTo])
  @@index([monthYear])
  @@map("document_batches")
}

// Document categorization status
enum DocumentCategorizationStatus {
  Uncategorized
  Categorized
  Skipped
}

// Extracted document from PST file
model ExtractedDocument {
  id            String  @id @default(uuid())
  sessionId     String  @map("session_id")
  batchId       String? @map("batch_id")
  fileName      String  @map("file_name") @db.VarChar(500)
  fileExtension String  @map("file_extension") @db.VarChar(10) // pdf, docx, doc
  fileSizeBytes Int     @map("file_size_bytes")
  storagePath   String  @map("storage_path") @db.Text // Cloudflare R2 path
  folderPath    String  @map("folder_path") @db.Text // Original PST folder path
  isSent        Boolean @default(false) @map("is_sent") // Determined from folder path
  extractedText String? @map("extracted_text") @db.Text // For AI analysis

  // Email metadata
  emailSubject  String?   @map("email_subject") @db.VarChar(1000)
  emailSender   String?   @map("email_sender") @db.VarChar(500)
  emailReceiver String?   @map("email_receiver") @db.VarChar(500)
  emailDate     DateTime? @map("email_date") @db.Timestamptz

  // Categorization
  categoryId    String?                      @map("category_id")
  status        DocumentCategorizationStatus @default(Uncategorized)
  categorizedBy String?                      @map("categorized_by") // User ID
  categorizedAt DateTime?                    @map("categorized_at") @db.Timestamptz

  // AI Analysis Fields (Story 3.2.5 Enhancement)
  primaryLanguage        PrimaryLanguage?   @map("primary_language")
  secondaryLanguage      PrimaryLanguage?   @map("secondary_language")
  languageRatio          Json?              @map("language_ratio") // { Romanian: 0.85, English: 0.15 }
  languageConfidence     Float?             @map("language_confidence") // 0-1
  documentType           String?            @map("document_type") @db.VarChar(200) // e.g., "Contract de Vanzare-Cumparare"
  documentTypeConfidence Float?             @map("document_type_confidence")
  clauseCategories       String[]           @map("clause_categories") // ["payment_terms", "warranties"]
  templatePotential      TemplatePotential? @map("template_potential")

  // AI Metadata (extended analysis)
  aiMetadata         Json?     @map("ai_metadata") // { complexityScore, structureType, keyTerms, clauseCount }
  riskIndicators     Json?     @map("risk_indicators") // { hasUnclearTerms, hasMixedJurisdiction, complianceFlags }
  aiAnalysisVersion  String?   @map("ai_analysis_version") @db.VarChar(100) // e.g., "claude-3-haiku-20240307"
  analysisTimestamp  DateTime? @map("analysis_timestamp") @db.Timestamptz
  analysisTokensUsed Int?      @map("analysis_tokens_used")

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  session  LegacyImportSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  batch    DocumentBatch?      @relation(fields: [batchId], references: [id], onDelete: SetNull)
  category ImportCategory?     @relation(fields: [categoryId], references: [id], onDelete: SetNull)

  @@index([sessionId])
  @@index([batchId])
  @@index([categoryId])
  @@index([status])
  @@index([emailDate])
  @@index([primaryLanguage])
  @@index([templatePotential])
  // Composite indexes for common query patterns
  @@index([sessionId, batchId])
  @@index([sessionId, status])
  @@map("extracted_documents")
}

// Import category - user-defined categories for document classification
model ImportCategory {
  id            String   @id @default(uuid())
  sessionId     String   @map("session_id")
  name          String   @db.VarChar(200) // e.g., "Contract", "Notificare Avocateasca"
  documentCount Int      @default(0) @map("document_count") // Denormalized for performance
  createdBy     String   @map("created_by") // User ID
  createdAt     DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime @updatedAt @map("updated_at") @db.Timestamptz
  mergedInto    String?  @map("merged_into") // If this category was merged, points to target

  // Relations
  session   LegacyImportSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  documents ExtractedDocument[]

  @@unique([sessionId, name])
  @@index([sessionId])
  @@index([createdBy])
  @@map("import_categories")
}

// AI Processing Log - tracks all AI API calls for cost monitoring
model AIProcessingLog {
  id               String   @id @default(uuid())
  sessionId        String   @map("session_id")
  documentId       String?  @map("document_id")
  model            String   @db.VarChar(100) // e.g., "claude-3-haiku-20240307"
  tokensUsed       Int      @map("tokens_used")
  costUSD          Float    @map("cost_usd")
  processingTimeMs Int      @map("processing_time_ms")
  success          Boolean  @default(true)
  errorMessage     String?  @map("error_message") @db.Text
  metadata         Json? // Additional details (documentCount, etc.)
  createdAt        DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  session LegacyImportSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@index([createdAt])
  @@index([model])
  @@map("ai_processing_logs")
}

// Legacy Import Audit Log - tracks all significant actions
model LegacyImportAuditLog {
  id        String   @id @default(uuid())
  sessionId String   @map("session_id")
  userId    String   @map("user_id")
  action    String   @db.VarChar(100) // e.g., "PST_UPLOADED", "EXPORT_COMPLETED", "PST_DELETED"
  details   Json? // Additional context
  timestamp DateTime @default(now()) @db.Timestamptz

  @@index([sessionId])
  @@index([userId])
  @@index([action])
  @@index([timestamp])
  @@map("legacy_import_audit_logs")
}

// ============================================================================
// Story 3.2.6: AI Training Pipeline for Legacy Document Processing
// ============================================================================

// Training document - processed legacy documents for AI learning
model TrainingDocument {
  id                   String                   @id @default(uuid())
  category             String                   @db.VarChar(255)
  originalFilename     String                   @map("original_filename") @db.VarChar(500)
  originalFolderPath   String?                  @map("original_folder_path") @db.Text
  oneDriveFileId       String                   @unique @map("one_drive_file_id") @db.VarChar(255)
  textContent          String                   @map("text_content") @db.Text
  language             String                   @db.VarChar(10) // 'ro' or 'en'
  wordCount            Int?                     @map("word_count")
  metadata             Json?
  processedAt          DateTime                 @default(now()) @map("processed_at") @db.Timestamptz
  processingDurationMs Int?                     @map("processing_duration_ms")
  createdAt            DateTime                 @default(now()) @map("created_at") @db.Timestamptz
  textSearchVector     Unsupported("tsvector")? @map("text_search_vector") // Full-text search vector

  // Relations
  embeddings       DocumentEmbedding[]
  baseForTemplates TemplateLibrary[]

  @@index([category])
  @@index([oneDriveFileId])
  @@index([processedAt])
  @@map("training_documents")
}

// Document embedding chunk for semantic search
model DocumentEmbedding {
  id         String                     @id @default(uuid())
  documentId String                     @map("document_id")
  chunkIndex Int                        @map("chunk_index")
  chunkText  String                     @map("chunk_text") @db.Text
  embedding  Unsupported("vector(768)") // pgvector type - multilingual-e5-base (768 dimensions)
  tokenCount Int?                       @map("token_count")
  createdAt  DateTime                   @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  document TrainingDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([documentId, chunkIndex])
  @@index([documentId])
  @@map("document_embeddings")
}

// Pattern type enum
enum PatternType {
  phrase
  clause
  structure
}

// Document pattern - identified common patterns across documents
model DocumentPattern {
  id              String      @id @default(uuid())
  category        String      @db.VarChar(255)
  patternType     PatternType @map("pattern_type")
  patternText     String      @map("pattern_text") @db.Text
  frequency       Int         @default(1)
  documentIds     String[]    @map("document_ids") // Array of UUID strings
  confidenceScore Decimal?    @map("confidence_score") @db.Decimal(3, 2)
  metadata        Json?
  createdAt       DateTime    @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime    @updatedAt @map("updated_at") @db.Timestamptz

  @@index([category])
  @@index([patternType])
  @@index([frequency])
  @@map("document_patterns")
}

// Template library - extracted document templates
model TemplateLibrary {
  id                 String   @id @default(uuid())
  category           String   @db.VarChar(255)
  name               String?  @db.VarChar(500)
  baseDocumentId     String?  @map("base_document_id")
  structure          Json // Sections, headings, clause order
  similarDocumentIds String[] @map("similar_document_ids") // Array of UUID strings
  usageCount         Int      @default(0) @map("usage_count")
  qualityScore       Decimal? @map("quality_score") @db.Decimal(3, 2)
  createdAt          DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt          DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  baseDocument TrainingDocument? @relation(fields: [baseDocumentId], references: [id], onDelete: SetNull)

  @@index([category])
  @@index([usageCount])
  @@index([qualityScore])
  @@map("template_library")
}

// Pipeline run type enum
enum PipelineRunType {
  scheduled
  manual
}

// Pipeline status enum
enum PipelineStatus {
  running
  completed
  failed
}

// Training pipeline run - tracks pipeline executions
model TrainingPipelineRun {
  id                  String          @id @default(uuid())
  runType             PipelineRunType @map("run_type")
  status              PipelineStatus
  startedAt           DateTime        @default(now()) @map("started_at") @db.Timestamptz
  completedAt         DateTime?       @map("completed_at") @db.Timestamptz
  documentsDiscovered Int             @default(0) @map("documents_discovered")
  documentsProcessed  Int             @default(0) @map("documents_processed")
  documentsFailed     Int             @default(0) @map("documents_failed")
  patternsIdentified  Int             @default(0) @map("patterns_identified")
  templatesCreated    Int             @default(0) @map("templates_created")
  totalTokensUsed     Int             @default(0) @map("total_tokens_used")
  errorLog            Json?           @map("error_log")
  metadata            Json?
  createdAt           DateTime        @default(now()) @map("created_at") @db.Timestamptz

  @@index([status])
  @@index([startedAt])
  @@map("training_pipeline_runs")
}

// ============================================================================
// Story 3.3: Intelligent Document Drafting - Quality Metrics
// ============================================================================

// Document draft metrics - tracks AI-generated document quality
model DocumentDraftMetrics {
  id                    String    @id @default(uuid())
  documentId            String    @unique @map("document_id")
  firmId                String    @map("firm_id")
  userId                String    @map("user_id")
  documentType          String    @map("document_type") @db.VarChar(50)
  initialWordCount      Int       @map("initial_word_count")
  finalWordCount        Int?      @map("final_word_count")
  charactersAdded       Int       @default(0) @map("characters_added")
  charactersRemoved     Int       @default(0) @map("characters_removed")
  editPercentage        Decimal   @map("edit_percentage") @db.Decimal(5, 2) // Target: < 30%
  timeToFinalizeMinutes Int?      @map("time_to_finalize_minutes")
  userRating            Int?      @map("user_rating") // 1-5 stars
  generationTimeMs      Int?      @map("generation_time_ms")
  tokensUsed            Int?      @map("tokens_used")
  modelUsed             String?   @map("model_used") @db.VarChar(100)
  templateId            String?   @map("template_id")
  precedentIds          String[]  @map("precedent_ids") // Array of referenced document IDs
  createdAt             DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt             DateTime  @updatedAt @map("updated_at") @db.Timestamptz
  finalizedAt           DateTime? @map("finalized_at") @db.Timestamptz

  @@index([firmId])
  @@index([userId])
  @@index([documentType])
  @@index([editPercentage])
  @@index([createdAt])
  @@index([userRating])
  @@map("document_draft_metrics")
}

// ============================================================================
// Story 3.4: Word Integration with Live AI Assistance
// ============================================================================

// Document comment - synced between platform and Word
model DocumentComment {
  id            String    @id @default(uuid())
  documentId    String    @map("document_id")
  versionId     String?   @map("version_id")
  authorId      String    @map("author_id")
  content       String    @db.Text
  anchorText    String?   @map("anchor_text") @db.Text
  anchorStart   Int?      @map("anchor_start")
  anchorEnd     Int?      @map("anchor_end")
  wordCommentId String?   @map("word_comment_id") @db.VarChar(255)
  resolved      Boolean   @default(false)
  resolvedBy    String?   @map("resolved_by")
  resolvedAt    DateTime? @map("resolved_at") @db.Timestamptz
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  @@index([documentId])
  @@index([authorId])
  @@index([wordCommentId])
  @@map("document_comments")
}

// Document lock - prevents concurrent editing
model DocumentLock {
  id          String   @id @default(uuid())
  documentId  String   @unique @map("document_id")
  userId      String   @map("user_id")
  lockToken   String   @unique @map("lock_token") @db.VarChar(64)
  lockedAt    DateTime @default(now()) @map("locked_at") @db.Timestamptz
  expiresAt   DateTime @map("expires_at") @db.Timestamptz
  sessionType String   @map("session_type") @db.VarChar(50) // 'word_desktop', 'word_online', 'platform'

  @@index([userId])
  @@index([expiresAt])
  @@map("document_locks")
}

// ============================================================================
// Story 3.5: Semantic Version Control System
// ============================================================================

// Change type classification
enum ChangeType {
  ADDED
  REMOVED
  MODIFIED
  MOVED
}

// Change significance levels
enum ChangeSignificance {
  FORMATTING
  MINOR_WORDING
  SUBSTANTIVE
  CRITICAL
}

// Risk levels for changes
enum RiskLevel {
  LOW
  MEDIUM
  HIGH
}

// Response suggestion types
enum ResponseType {
  ACCEPT
  REJECT
  COUNTER_PROPOSAL
  CLARIFICATION
}

// Semantic change - stores analyzed changes between versions
model SemanticChange {
  id                  String             @id @default(uuid())
  documentId          String             @map("document_id")
  fromVersionId       String             @map("from_version_id")
  toVersionId         String             @map("to_version_id")
  changeType          ChangeType         @map("change_type")
  significance        ChangeSignificance
  beforeText          String             @map("before_text") @db.Text
  afterText           String             @map("after_text") @db.Text
  sectionPath         String?            @map("section_path") @db.VarChar(500)
  plainSummary        String             @map("plain_summary") @db.Text
  legalClassification String?            @map("legal_classification") @db.VarChar(100)
  riskLevel           RiskLevel?         @map("risk_level")
  riskExplanation     String?            @map("risk_explanation") @db.Text
  aiConfidence        Decimal?           @map("ai_confidence") @db.Decimal(3, 2)
  createdAt           DateTime           @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  document            Document             @relation(fields: [documentId], references: [id], onDelete: Cascade)
  fromVersion         DocumentVersion      @relation("SemanticChangeFromVersion", fields: [fromVersionId], references: [id], onDelete: Cascade)
  toVersion           DocumentVersion      @relation("SemanticChangeToVersion", fields: [toVersionId], references: [id], onDelete: Cascade)
  responseSuggestions ResponseSuggestion[]

  @@index([documentId])
  @@index([fromVersionId])
  @@index([toVersionId])
  @@map("semantic_changes")
}

// Version comparison cache - caches expensive comparison results
model VersionComparisonCache {
  id             String    @id @default(uuid())
  fromVersionId  String    @map("from_version_id")
  toVersionId    String    @map("to_version_id")
  comparisonData Json      @map("comparison_data")
  summary        String    @db.Text
  aggregateRisk  RiskLevel @map("aggregate_risk")
  createdAt      DateTime  @default(now()) @map("created_at") @db.Timestamptz
  expiresAt      DateTime  @map("expires_at") @db.Timestamptz

  // Relations
  fromVersion DocumentVersion @relation("CacheFromVersion", fields: [fromVersionId], references: [id], onDelete: Cascade)
  toVersion   DocumentVersion @relation("CacheToVersion", fields: [toVersionId], references: [id], onDelete: Cascade)

  @@unique([fromVersionId, toVersionId])
  @@index([expiresAt])
  @@map("version_comparison_cache")
}

// Response suggestion - AI-generated response options
model ResponseSuggestion {
  id             String       @id @default(uuid())
  changeId       String       @map("change_id")
  suggestionType ResponseType @map("suggestion_type")
  suggestedText  String       @map("suggested_text") @db.Text
  reasoning      String?      @db.Text
  language       String       @db.VarChar(10) // 'ro' or 'en'
  createdAt      DateTime     @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  change SemanticChange @relation(fields: [changeId], references: [id], onDelete: Cascade)

  @@index([changeId])
  @@map("response_suggestions")
}

// ============================================================================
// Story 3.6: Document Review and Approval Workflow
// ============================================================================

// Review status lifecycle
enum ReviewStatus {
  PENDING
  IN_REVIEW
  APPROVED
  REJECTED
  REVISION_REQUESTED
}

// Review priority levels
enum ReviewPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

// AI concern type classification
enum ConcernType {
  LEGAL_INCONSISTENCY
  AMBIGUOUS_LANGUAGE
  MISSING_CLAUSE
  OUTDATED_REFERENCE
  COMPLIANCE_ISSUE
  STYLE_VIOLATION
  HIGH_RISK_CLAUSE
}

// AI concern severity levels
enum ConcernSeverity {
  INFO
  WARNING
  ERROR
}

// Review action types for history tracking
enum ReviewAction {
  SUBMITTED
  ASSIGNED
  COMMENT_ADDED
  COMMENT_RESOLVED
  APPROVED
  REJECTED
  REVISION_REQUESTED
  RESUBMITTED
}

// Batch review status
enum BatchReviewStatus {
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

// Document review - tracks review workflow for documents
model DocumentReview {
  id                String         @id @default(uuid())
  documentId        String         @map("document_id")
  documentVersionId String         @map("document_version_id")
  firmId            String         @map("firm_id")
  submittedBy       String         @map("submitted_by")
  submittedAt       DateTime       @default(now()) @map("submitted_at") @db.Timestamptz
  assignedTo        String?        @map("assigned_to")
  status            ReviewStatus   @default(PENDING)
  reviewedAt        DateTime?      @map("reviewed_at") @db.Timestamptz
  feedback          String?        @db.Text
  priority          ReviewPriority @default(NORMAL)
  dueDate           DateTime?      @map("due_date") @db.Date
  revisionNumber    Int            @default(0) @map("revision_number")
  createdAt         DateTime       @default(now()) @map("created_at") @db.Timestamptz
  updatedAt         DateTime       @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  document        Document          @relation(fields: [documentId], references: [id], onDelete: Cascade)
  documentVersion DocumentVersion   @relation(fields: [documentVersionId], references: [id])
  submitter       User              @relation("ReviewSubmitter", fields: [submittedBy], references: [id])
  reviewer        User?             @relation("ReviewReviewer", fields: [assignedTo], references: [id])
  comments        ReviewComment[]
  aiConcerns      AIReviewConcern[]
  history         ReviewHistory[]

  @@index([documentId])
  @@index([firmId])
  @@index([submittedBy])
  @@index([assignedTo])
  @@index([status])
  @@map("document_reviews")
}

// Review comment - inline comments on documents during review
model ReviewComment {
  id             String    @id @default(uuid())
  reviewId       String    @map("review_id")
  authorId       String    @map("author_id")
  content        String    @db.Text
  anchorText     String?   @map("anchor_text") @db.Text
  anchorStart    Int?      @map("anchor_start")
  anchorEnd      Int?      @map("anchor_end")
  sectionPath    String?   @map("section_path") @db.VarChar(500)
  resolved       Boolean   @default(false)
  resolvedBy     String?   @map("resolved_by")
  resolvedAt     DateTime? @map("resolved_at") @db.Timestamptz
  suggestionText String?   @map("suggestion_text") @db.Text
  isAISuggestion Boolean   @default(false) @map("is_ai_suggestion")
  createdAt      DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt      DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  review   DocumentReview       @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  author   User                 @relation("CommentAuthor", fields: [authorId], references: [id])
  resolver User?                @relation("CommentResolver", fields: [resolvedBy], references: [id])
  replies  ReviewCommentReply[]

  @@index([reviewId])
  @@index([authorId])
  @@map("review_comments")
}

// Review comment reply - threaded replies to comments
model ReviewCommentReply {
  id        String   @id @default(uuid())
  commentId String   @map("comment_id")
  authorId  String   @map("author_id")
  content   String   @db.Text
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  comment ReviewComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  author  User          @relation("ReplyAuthor", fields: [authorId], references: [id])

  @@index([commentId])
  @@map("review_comment_replies")
}

// AI review concern - AI-flagged areas of concern in documents
model AIReviewConcern {
  id           String          @id @default(uuid())
  reviewId     String          @map("review_id")
  concernType  ConcernType     @map("concern_type")
  severity     ConcernSeverity
  description  String          @db.Text
  anchorText   String          @map("anchor_text") @db.Text
  anchorStart  Int             @map("anchor_start")
  anchorEnd    Int             @map("anchor_end")
  sectionPath  String?         @map("section_path") @db.VarChar(500)
  suggestedFix String?         @map("suggested_fix") @db.Text
  aiConfidence Decimal         @map("ai_confidence") @db.Decimal(3, 2)
  dismissed    Boolean         @default(false)
  dismissedBy  String?         @map("dismissed_by")
  dismissedAt  DateTime?       @map("dismissed_at") @db.Timestamptz
  createdAt    DateTime        @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  review DocumentReview @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  @@index([reviewId])
  @@map("ai_review_concerns")
}

// Review history - tracks all actions on a review
model ReviewHistory {
  id             String        @id @default(uuid())
  reviewId       String        @map("review_id")
  action         ReviewAction
  actorId        String        @map("actor_id")
  previousStatus ReviewStatus? @map("previous_status")
  newStatus      ReviewStatus? @map("new_status")
  feedback       String?       @db.Text
  metadata       Json?
  timestamp      DateTime      @default(now()) @db.Timestamptz

  // Relations
  review DocumentReview @relation(fields: [reviewId], references: [id], onDelete: Cascade)
  actor  User           @relation("ReviewHistoryActor", fields: [actorId], references: [id])

  @@index([reviewId])
  @@index([timestamp])
  @@map("review_history")
}

// Batch review - for batch operations on multiple reviews
model BatchReview {
  id             String            @id @default(uuid())
  firmId         String            @map("firm_id")
  createdBy      String            @map("created_by")
  reviewIds      String[]          @map("review_ids")
  status         BatchReviewStatus
  processedCount Int               @default(0) @map("processed_count")
  totalCount     Int               @map("total_count")
  commonFeedback String?           @map("common_feedback") @db.Text
  createdAt      DateTime          @default(now()) @map("created_at") @db.Timestamptz
  completedAt    DateTime?         @map("completed_at") @db.Timestamptz

  // Relations
  firm    Firm @relation(fields: [firmId], references: [id], onDelete: Restrict)
  creator User @relation("BatchReviewCreator", fields: [createdBy], references: [id])

  @@index([firmId])
  @@index([createdBy])
  @@map("batch_reviews")
}

// ============================================================================
// Story 3.8: Document System Testing and Performance
// ============================================================================

// Performance metric - stores performance metrics for analysis
model PerformanceMetric {
  id        String   @id @default(uuid())
  timestamp DateTime @default(now()) @db.Timestamptz
  value     Float
  operation String   @db.VarChar(255) // e.g., "GET /api/documents/:id", "ai.claude-sonnet.document_generation"
  metadata  Json? // Additional context (statusCode, firmId, userId, etc.)

  @@index([timestamp])
  @@index([operation])
  @@map("performance_metrics")
}

// ============================================================================
// Story 4.1: Natural Language Task Parser
// ============================================================================

// Task type enum for parsed tasks
enum TaskTypeEnum {
  Research
  DocumentCreation
  DocumentRetrieval
  CourtDate
  Meeting
  BusinessTrip
}

// Task parse pattern - learned patterns for autocomplete suggestions
model TaskParsePattern {
  id           String       @id @default(uuid())
  firmId       String       @map("firm_id")
  inputPattern String       @map("input_pattern") @db.Text // Regex pattern
  taskType     TaskTypeEnum @map("task_type")
  frequency    Int          @default(1)
  lastUsed     DateTime     @default(now()) @map("last_used") @db.Timestamptz
  metadata     Json? // Extracted entities mapping
  createdAt    DateTime     @default(now()) @map("created_at") @db.Timestamptz

  @@index([firmId])
  @@index([taskType])
  @@index([frequency])
  @@map("task_parse_patterns")
}

// Task parse history - records all parse attempts for learning
model TaskParseHistory {
  id               String   @id @default(uuid())
  userId           String   @map("user_id")
  firmId           String   @map("firm_id")
  inputText        String   @map("input_text") @db.Text
  detectedLanguage String   @map("detected_language") @db.VarChar(10)
  parsedResult     Json     @map("parsed_result") // Full NLPTaskParseResponse
  wasAccepted      Boolean  @map("was_accepted")
  userCorrections  Json?    @map("user_corrections")
  finalTaskId      String?  @map("final_task_id")
  createdAt        DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations (Story 4.2)
  task Task?

  @@index([firmId])
  @@index([userId])
  @@index([createdAt])
  @@map("task_parse_history")
}

// ============================================================================
// Story 4.2: Task Type System Implementation
// ============================================================================

// Task status lifecycle
enum TaskStatus {
  Pending
  InProgress
  Completed
  Cancelled
}

// Task priority levels
enum TaskPriority {
  Low
  Medium
  High
  Urgent
}

// Task entity - main task model with type-specific metadata
model Task {
  id             String       @id @default(uuid())
  firmId         String       @map("firm_id")
  caseId         String       @map("case_id")
  type           TaskTypeEnum
  title          String       @db.VarChar(500)
  description    String?      @db.Text
  assignedTo     String       @map("assigned_to")
  dueDate        DateTime     @map("due_date") @db.Date
  dueTime        String?      @map("due_time") @db.VarChar(5) // HH:mm format
  status         TaskStatus   @default(Pending)
  priority       TaskPriority @default(Medium)
  estimatedHours Decimal?     @map("estimated_hours") @db.Decimal(5, 2)

  // Type-specific fields stored as JSON
  typeMetadata Json? @map("type_metadata")

  // Parent task for subtasks
  parentTaskId String? @map("parent_task_id")

  // Source tracking (from NLP parser)
  parseHistoryId String? @unique @map("parse_history_id")

  // Story 4.4: Task dependency and template tracking
  templateStepId  String? @map("template_step_id") // Source template step
  templateUsageId String? @map("template_usage_id") // Template application instance
  isCriticalPath  Boolean @default(false) @map("is_critical_path")
  blockedReason   String? @map("blocked_reason") @db.VarChar(500)

  createdBy   String    @map("created_by")
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime  @updatedAt @map("updated_at") @db.Timestamptz
  completedAt DateTime? @map("completed_at") @db.Timestamptz

  // Relations
  firm         Firm              @relation(fields: [firmId], references: [id])
  case         Case              @relation(fields: [caseId], references: [id])
  assignee     User              @relation("TaskAssignee", fields: [assignedTo], references: [id])
  creator      User              @relation("TaskCreator", fields: [createdBy], references: [id])
  parentTask   Task?             @relation("TaskSubtasks", fields: [parentTaskId], references: [id])
  subtasks     Task[]            @relation("TaskSubtasks")
  parseHistory TaskParseHistory? @relation(fields: [parseHistoryId], references: [id])

  // Type-specific relations
  attendees         TaskAttendee[]
  documentLinks     TaskDocumentLink[]
  delegationsSource TaskDelegation[]   @relation("DelegationSource")
  delegatedTasks    TaskDelegation[]   @relation("DelegatedTask")
  timeEntries       TimeEntry[] // Story 4.3: Time entries logged against this task

  // Story 4.4: Dependency relations
  predecessors TaskDependency[] @relation("TaskSuccessor")
  successors   TaskDependency[] @relation("TaskPredecessor")

  // Story 4.6: Task Collaboration relations
  comments    TaskComment[]
  history     TaskHistory[]
  attachments TaskAttachment[]

  // Story 5.2: Communication Intelligence - tasks converted from extractions
  convertedFromDeadline   ExtractedDeadline[]   @relation("DeadlineConvertedTask")
  convertedFromCommitment ExtractedCommitment[] @relation("CommitmentConvertedTask")
  convertedFromActionItem ExtractedActionItem[] @relation("ActionItemConvertedTask")

  @@index([firmId])
  @@index([caseId])
  @@index([assignedTo])
  @@index([status])
  @@index([dueDate])
  @@index([type])
  @@index([parentTaskId])
  @@map("tasks")
}

// Attendee response status for meeting tasks
enum AttendeeResponse {
  Pending
  Accepted
  Declined
  Tentative
}

// Task attendee model for Meeting tasks
model TaskAttendee {
  id            String           @id @default(uuid())
  taskId        String           @map("task_id")
  userId        String?          @map("user_id") // Internal user
  externalName  String?          @map("external_name") @db.VarChar(200)
  externalEmail String?          @map("external_email") @db.VarChar(255)
  isOrganizer   Boolean          @default(false) @map("is_organizer")
  response      AttendeeResponse @default(Pending)
  createdAt     DateTime         @default(now()) @map("created_at") @db.Timestamptz

  task Task  @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user User? @relation(fields: [userId], references: [id])

  @@index([taskId])
  @@map("task_attendees")
}

// Task document link type
enum TaskDocumentLinkType {
  Source // Research source document
  Output // Created document from task
  Reference // General reference
}

// Task document link model for Research tasks
model TaskDocumentLink {
  id         String               @id @default(uuid())
  taskId     String               @map("task_id")
  documentId String               @map("document_id")
  linkType   TaskDocumentLinkType @map("link_type")
  notes      String?              @db.Text
  linkedBy   String               @map("linked_by")
  linkedAt   DateTime             @default(now()) @map("linked_at") @db.Timestamptz

  task     Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  document Document @relation(fields: [documentId], references: [id])
  linker   User     @relation(fields: [linkedBy], references: [id])

  @@unique([taskId, documentId])
  @@index([taskId])
  @@map("task_document_links")
}

// Delegation status
enum DelegationStatus {
  Pending
  Accepted
  Declined
}

// Task delegation model for Business Trip coverage
model TaskDelegation {
  id              String           @id @default(uuid())
  sourceTaskId    String           @map("source_task_id") // BusinessTrip task
  delegatedTaskId String?          @map("delegated_task_id") // Task being covered
  delegatedTo     String           @map("delegated_to")
  delegatedBy     String           @map("delegated_by")
  reason          String           @db.Text // "Business Trip coverage"
  startDate       DateTime         @map("start_date") @db.Date
  endDate         DateTime         @map("end_date") @db.Date
  status          DelegationStatus @default(Pending)
  notes           String?          @db.Text
  createdAt       DateTime         @default(now()) @map("created_at") @db.Timestamptz
  acceptedAt      DateTime?        @map("accepted_at") @db.Timestamptz

  // Story 4.5: Delegation handoff relation
  handoff DelegationHandoff?

  sourceTask    Task  @relation("DelegationSource", fields: [sourceTaskId], references: [id])
  delegatedTask Task? @relation("DelegatedTask", fields: [delegatedTaskId], references: [id])
  delegate      User  @relation("DelegationDelegate", fields: [delegatedTo], references: [id])
  delegator     User  @relation("DelegationDelegator", fields: [delegatedBy], references: [id])

  @@index([sourceTaskId])
  @@index([delegatedTo])
  @@index([startDate, endDate])
  @@map("task_delegations")
}

// ============================================================================
// Story 4.4: Task Dependencies and Automation
// ============================================================================

// Offset type for task template step scheduling
enum OffsetType {
  CaseStart // Days from case creation
  PreviousTask // Days from previous step completion
  CaseDeadline // Days before case deadline (negative offset)
}

// Dependency type for task relationships
enum DependencyType {
  FinishToStart // Target starts when source finishes (most common)
  StartToStart // Target starts when source starts
  FinishToFinish // Target finishes when source finishes
  StartToFinish // Target finishes when source starts (rare)
}

// Task template - defines common workflow patterns
model TaskTemplate {
  id          String    @id @default(uuid())
  firmId      String    @map("firm_id")
  name        String    @db.VarChar(200)
  description String?   @db.Text
  caseType    CaseType? @map("case_type") // Optional: template for specific case types
  isDefault   Boolean   @default(false) @map("is_default") // Firm default template
  isActive    Boolean   @default(true) @map("is_active")
  createdBy   String    @map("created_by")
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  firm   Firm                @relation(fields: [firmId], references: [id])
  steps  TaskTemplateStep[]
  usages TaskTemplateUsage[]

  @@unique([firmId, name])
  @@index([firmId])
  @@index([caseType])
  @@map("task_templates")
}

// Task template step - individual steps within a template
model TaskTemplateStep {
  id             String       @id @default(uuid())
  templateId     String       @map("template_id")
  stepOrder      Int          @map("step_order") // Execution order
  taskType       TaskTypeEnum @map("task_type")
  title          String       @db.VarChar(500)
  description    String?      @db.Text
  estimatedHours Decimal?     @map("estimated_hours") @db.Decimal(5, 2)
  typeMetadata   Json?        @map("type_metadata") // Type-specific defaults
  offsetDays     Int          @map("offset_days") // Days from case start or previous task
  offsetFrom     OffsetType   @default(CaseStart) @map("offset_from")
  isParallel     Boolean      @default(false) @map("is_parallel") // Can run parallel with next step
  isCriticalPath Boolean      @default(false) @map("is_critical_path")
  createdAt      DateTime     @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  template   TaskTemplate             @relation(fields: [templateId], references: [id], onDelete: Cascade)
  dependsOn  TemplateStepDependency[] @relation("DependencyTarget")
  dependents TemplateStepDependency[] @relation("DependencySource")

  @@unique([templateId, stepOrder])
  @@index([templateId])
  @@map("task_template_steps")
}

// Template step dependency - defines dependencies between template steps
model TemplateStepDependency {
  id             String         @id @default(uuid())
  sourceStepId   String         @map("source_step_id") // The step that must complete
  targetStepId   String         @map("target_step_id") // The step that depends on source
  dependencyType DependencyType @default(FinishToStart) @map("dependency_type")
  lagDays        Int            @default(0) @map("lag_days") // Days between finish-start

  sourceStep TaskTemplateStep @relation("DependencySource", fields: [sourceStepId], references: [id], onDelete: Cascade)
  targetStep TaskTemplateStep @relation("DependencyTarget", fields: [targetStepId], references: [id], onDelete: Cascade)

  @@unique([sourceStepId, targetStepId])
  @@map("template_step_dependencies")
}

// Task dependency - actual dependencies between tasks
model TaskDependency {
  id             String         @id @default(uuid())
  predecessorId  String         @map("predecessor_id") // Task that must complete first
  successorId    String         @map("successor_id") // Task that depends on predecessor
  dependencyType DependencyType @default(FinishToStart) @map("dependency_type")
  lagDays        Int            @default(0) @map("lag_days")
  createdAt      DateTime       @default(now()) @map("created_at") @db.Timestamptz

  predecessor Task @relation("TaskPredecessor", fields: [predecessorId], references: [id], onDelete: Cascade)
  successor   Task @relation("TaskSuccessor", fields: [successorId], references: [id], onDelete: Cascade)

  @@unique([predecessorId, successorId])
  @@index([predecessorId])
  @@index([successorId])
  @@map("task_dependencies")
}

// Task template usage - tracks when templates are applied to cases
model TaskTemplateUsage {
  id         String   @id @default(uuid())
  templateId String   @map("template_id")
  caseId     String   @map("case_id")
  appliedBy  String   @map("applied_by")
  appliedAt  DateTime @default(now()) @map("applied_at") @db.Timestamptz
  taskIds    String[] @map("task_ids") // Created task IDs

  template TaskTemplate @relation(fields: [templateId], references: [id])
  case     Case         @relation(fields: [caseId], references: [id])

  @@index([templateId])
  @@index([caseId])
  @@map("task_template_usages")
}

// ============================================================================
// Story 4.5: Team Workload Management
// ============================================================================

// Availability type for OOO and reduced hours
enum AvailabilityType {
  OutOfOffice // Fully unavailable
  ReducedHours // Working fewer hours
  Vacation // Planned vacation
  SickLeave // Unplanned absence
  Training // Training/conference
}

// Skill types for task assignment matching
enum SkillType {
  Litigation
  ContractDrafting
  LegalResearch
  ClientCommunication
  CourtProcedures
  DocumentReview
  Negotiation
  DueDiligence
  RegulatoryCompliance
  IntellectualProperty
}

// User availability - tracks OOO, vacation, reduced hours (AC: 1, 5)
model UserAvailability {
  id               String           @id @default(uuid())
  userId           String           @map("user_id")
  firmId           String           @map("firm_id")
  availabilityType AvailabilityType @map("availability_type")
  startDate        DateTime         @map("start_date") @db.Date
  endDate          DateTime         @map("end_date") @db.Date
  hoursPerDay      Decimal?         @map("hours_per_day") @db.Decimal(4, 2) // Override default 8h
  reason           String?          @db.VarChar(500)
  autoReassign     Boolean          @default(true) @map("auto_reassign") // AC5: Auto-reassign urgent tasks
  delegateTo       String?          @map("delegate_to") // Preferred delegate user ID
  createdAt        DateTime         @default(now()) @map("created_at") @db.Timestamptz
  updatedAt        DateTime         @updatedAt @map("updated_at") @db.Timestamptz

  user     User  @relation("UserAvailabilities", fields: [userId], references: [id], onDelete: Cascade)
  delegate User? @relation("UserDelegates", fields: [delegateTo], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([firmId])
  @@index([startDate, endDate])
  @@map("user_availabilities")
}

// User skill - tracks user proficiencies for task assignment (AC: 3)
model UserSkill {
  id          String    @id @default(uuid())
  userId      String    @map("user_id")
  firmId      String    @map("firm_id")
  skillType   SkillType @map("skill_type")
  proficiency Int       @default(3) // 1-5 scale
  verified    Boolean   @default(false) // Partner-verified skill
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, skillType])
  @@index([firmId])
  @@index([skillType])
  @@map("user_skills")
}

// Delegation handoff - automatic handoff notes for task delegation (AC: 4)
model DelegationHandoff {
  id             String   @id @default(uuid())
  delegationId   String   @unique @map("delegation_id")
  handoffNotes   String   @map("handoff_notes") @db.Text
  contextSummary String?  @map("context_summary") @db.Text // AI-generated summary
  relatedTaskIds String[] @map("related_task_ids")
  relatedDocIds  String[] @map("related_doc_ids")
  aiGenerated    Boolean  @default(false) @map("ai_generated")
  createdAt      DateTime @default(now()) @map("created_at") @db.Timestamptz

  delegation TaskDelegation @relation(fields: [delegationId], references: [id], onDelete: Cascade)

  @@map("delegation_handoffs")
}

// User workload settings - capacity and preferences (AC: 2, 6)
model UserWorkloadSettings {
  id                  String   @id @default(uuid())
  userId              String   @unique @map("user_id")
  firmId              String   @map("firm_id")
  dailyCapacityHours  Decimal  @default(8) @map("daily_capacity_hours") @db.Decimal(4, 2)
  weeklyCapacityHours Decimal  @default(40) @map("weekly_capacity_hours") @db.Decimal(5, 2)
  workingDays         Int[]    @map("working_days") // [1,2,3,4,5] = Mon-Fri
  maxConcurrentTasks  Int      @default(10) @map("max_concurrent_tasks")
  overloadThreshold   Decimal  @default(1.2) @map("overload_threshold") @db.Decimal(3, 2) // 120% capacity
  createdAt           DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt           DateTime @updatedAt @map("updated_at") @db.Timestamptz

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([firmId])
  @@map("user_workload_settings")
}

// ============================================================================
// Story 4.6: Task Collaboration and Updates
// ============================================================================

// Task comment - comments on tasks with @mention support and threading (AC: 1)
model TaskComment {
  id        String    @id @default(uuid())
  taskId    String    @map("task_id")
  authorId  String    @map("author_id")
  content   String    @db.Text
  parentId  String?   @map("parent_id") // For threaded replies
  mentions  String[] // User IDs mentioned in comment
  createdAt DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime  @updatedAt @map("updated_at") @db.Timestamptz
  editedAt  DateTime? @map("edited_at") @db.Timestamptz

  task    Task          @relation(fields: [taskId], references: [id], onDelete: Cascade)
  author  User          @relation("TaskCommentAuthor", fields: [authorId], references: [id])
  parent  TaskComment?  @relation("CommentReplies", fields: [parentId], references: [id])
  replies TaskComment[] @relation("CommentReplies")

  @@index([taskId])
  @@index([authorId])
  @@index([createdAt])
  @@map("task_comments")
}

// Task history action types (AC: 5)
enum TaskHistoryAction {
  Created
  Updated
  StatusChanged
  AssigneeChanged
  PriorityChanged
  DueDateChanged
  CommentAdded
  CommentEdited
  CommentDeleted
  AttachmentAdded
  AttachmentRemoved
  SubtaskCreated
  SubtaskCompleted
  DependencyAdded
  DependencyRemoved
  Delegated
}

// Task history - tracks all modifications with attribution (AC: 5)
model TaskHistory {
  id        String            @id @default(uuid())
  taskId    String            @map("task_id")
  actorId   String            @map("actor_id")
  action    TaskHistoryAction
  field     String?           @db.VarChar(100) // Field that changed
  oldValue  String?           @map("old_value") @db.Text
  newValue  String?           @map("new_value") @db.Text
  metadata  Json? // Additional context (e.g., subtask info, attachment details)
  createdAt DateTime          @default(now()) @map("created_at") @db.Timestamptz

  task  Task @relation(fields: [taskId], references: [id], onDelete: Cascade)
  actor User @relation("TaskHistoryActor", fields: [actorId], references: [id])

  @@index([taskId])
  @@index([actorId])
  @@index([createdAt])
  @@map("task_history")
}

// Case activity types for activity feed (AC: 2)
enum CaseActivityType {
  TaskCreated
  TaskStatusChanged
  TaskCompleted
  TaskAssigned
  TaskCommented
  DocumentUploaded
  DocumentVersioned
  CommunicationReceived
  CommunicationSent
  DeadlineApproaching
  MilestoneReached
}

// Case activity entry - case activity feed (AC: 2)
model CaseActivityEntry {
  id           String           @id @default(uuid())
  caseId       String           @map("case_id")
  actorId      String           @map("actor_id")
  activityType CaseActivityType @map("activity_type")
  entityType   String           @map("entity_type") @db.VarChar(50) // 'Task', 'Document', 'Communication'
  entityId     String           @map("entity_id")
  title        String           @db.VarChar(500)
  summary      String?          @db.Text
  metadata     Json? // Type-specific details
  createdAt    DateTime         @default(now()) @map("created_at") @db.Timestamptz

  case  Case @relation(fields: [caseId], references: [id], onDelete: Cascade)
  actor User @relation("CaseActivityActor", fields: [actorId], references: [id])

  @@index([caseId])
  @@index([actorId])
  @@index([createdAt])
  @@index([entityType, entityId])
  @@map("case_activity_entries")
}

// Task attachment - file attachments linked to tasks with version tracking (AC: 3)
model TaskAttachment {
  id                String   @id @default(uuid())
  taskId            String   @map("task_id")
  documentId        String?  @map("document_id") // Link to existing document (version tracking)
  fileName          String   @map("file_name") @db.VarChar(255)
  fileSize          Int      @map("file_size") // Size in bytes
  mimeType          String   @map("mime_type") @db.VarChar(100)
  storageUrl        String   @map("storage_url") @db.VarChar(1000) // R2 URL
  uploadedBy        String   @map("uploaded_by")
  version           Int      @default(1) // Attachment version number
  previousVersionId String?  @map("previous_version_id")
  createdAt         DateTime @default(now()) @map("created_at") @db.Timestamptz

  task            Task             @relation(fields: [taskId], references: [id], onDelete: Cascade)
  document        Document?        @relation(fields: [documentId], references: [id])
  uploader        User             @relation("TaskAttachmentUploader", fields: [uploadedBy], references: [id])
  previousVersion TaskAttachment?  @relation("AttachmentVersions", fields: [previousVersionId], references: [id])
  nextVersions    TaskAttachment[] @relation("AttachmentVersions")

  @@index([taskId])
  @@index([documentId])
  @@index([uploadedBy])
  @@map("task_attachments")
}

// Case subscription - user subscriptions for daily digest (AC: 6)
model CaseSubscription {
  id               String   @id @default(uuid())
  caseId           String   @map("case_id")
  userId           String   @map("user_id")
  digestEnabled    Boolean  @default(true) @map("digest_enabled")
  notifyOnTask     Boolean  @default(true) @map("notify_on_task")
  notifyOnDocument Boolean  @default(true) @map("notify_on_document")
  notifyOnComment  Boolean  @default(true) @map("notify_on_comment")
  createdAt        DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt        DateTime @updatedAt @map("updated_at") @db.Timestamptz

  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([caseId, userId])
  @@index([userId])
  @@index([digestEnabled])
  @@map("case_subscriptions")
}

// ============================================================================
// Story 4.7: Task Analytics and Optimization
// ============================================================================

// Snapshot type for analytics aggregation
enum SnapshotType {
  Daily
  Weekly
  Monthly
}

// Task analytics snapshot - pre-aggregated metrics for performance (AC: 1, 2, 3)
model TaskAnalyticsSnapshot {
  id           String       @id @default(uuid())
  firmId       String       @map("firm_id")
  snapshotDate DateTime     @map("snapshot_date") @db.Date
  snapshotType SnapshotType @default(Daily) @map("snapshot_type")

  // Completion metrics (AC: 1)
  totalTasksCreated      Int     @map("total_tasks_created")
  totalTasksCompleted    Int     @map("total_tasks_completed")
  avgCompletionTimeHours Decimal @map("avg_completion_time_hours") @db.Decimal(8, 2)

  // By type breakdown (stored as JSON for flexibility)
  completionByType Json @map("completion_by_type") // { [TaskTypeEnum]: { count, avgHours } }
  completionByUser Json @map("completion_by_user") // { [userId]: { count, avgHours } }

  // Overdue metrics (AC: 2)
  overdueCount    Int  @map("overdue_count")
  overdueByType   Json @map("overdue_by_type")
  overdueByUser   Json @map("overdue_by_user")
  bottleneckTasks Json @map("bottleneck_tasks") // Task IDs causing most delays

  // Velocity metrics (AC: 3)
  velocityScore Decimal @map("velocity_score") @db.Decimal(5, 2) // Tasks completed / target
  velocityTrend String  @map("velocity_trend") @db.VarChar(20) // 'improving' | 'stable' | 'declining'

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@unique([firmId, snapshotDate, snapshotType])
  @@index([firmId])
  @@index([snapshotDate])
  @@map("task_analytics_snapshots")
}

// Task pattern type for AI-detected task patterns
enum TaskPatternType {
  CoOccurrence // Tasks frequently created together
  Sequence // Tasks frequently follow each other
  CaseTypeSpecific // Patterns specific to case type
}

// Task pattern analysis - AI-detected co-occurrence patterns (AC: 4)
model TaskPatternAnalysis {
  id          String          @id @default(uuid())
  firmId      String          @map("firm_id")
  patternType TaskPatternType @map("pattern_type")

  // Co-occurring task pattern (AC: 4)
  taskTypes       String[]   @map("task_types") // TaskTypeEnum values
  caseTypes       CaseType[] @map("case_types") // Associated case types
  occurrenceCount Int        @map("occurrence_count")
  confidence      Decimal    @map("confidence") @db.Decimal(3, 2) // 0.00-1.00
  suggestedName   String?    @map("suggested_name") @db.VarChar(200) // AI-suggested template name

  // Pattern details
  avgSequenceGap  Decimal? @map("avg_sequence_gap") @db.Decimal(5, 2) // Days between tasks
  commonAssignees String[] @map("common_assignees") // User IDs frequently assigned

  isTemplateCreated Boolean @default(false) @map("is_template_created")
  templateId        String? @map("template_id") // Created template ID if converted
  isDismissed       Boolean @default(false) @map("is_dismissed") // User dismissed this pattern

  analyzedAt DateTime @default(now()) @map("analyzed_at") @db.Timestamptz
  expiresAt  DateTime @map("expires_at") @db.Timestamptz // Pattern validity

  @@index([firmId])
  @@index([patternType])
  @@index([confidence])
  @@map("task_pattern_analyses")
}

// Delegation analytics - delegation pattern analysis per user (AC: 5)
model DelegationAnalytics {
  id            String   @id @default(uuid())
  firmId        String   @map("firm_id")
  userId        String   @map("user_id")
  analysisMonth DateTime @map("analysis_month") @db.Date // First of month

  // Delegation metrics (AC: 5)
  delegationsReceived Int  @map("delegations_received")
  delegationsGiven    Int  @map("delegations_given")
  delegationsByType   Json @map("delegations_by_type") // { [TaskTypeEnum]: count }

  // Success metrics
  successRate       Decimal  @map("success_rate") @db.Decimal(3, 2) // Completed on time
  avgCompletionTime Decimal? @map("avg_completion_time") @db.Decimal(8, 2)

  // Training opportunities
  struggleAreas     String[] @map("struggle_areas") // Task types with low success
  strengthAreas     String[] @map("strength_areas") // Task types with high success
  suggestedTraining Json?    @map("suggested_training") // AI recommendations

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@unique([firmId, userId, analysisMonth])
  @@index([firmId])
  @@index([userId])
  @@map("delegation_analytics")
}

// Automation ROI metrics - time savings from automation features (AC: 6)
model AutomationROIMetrics {
  id          String   @id @default(uuid())
  firmId      String   @map("firm_id")
  metricMonth DateTime @map("metric_month") @db.Date

  // Time savings (AC: 6)
  templateTasksCreated  Int @map("template_tasks_created") // Tasks from templates
  manualTasksCreated    Int @map("manual_tasks_created")
  estimatedTimeSavedMin Int @map("estimated_time_saved_min") // Minutes saved

  // NLP parser savings
  nlpTasksCreated           Int @map("nlp_tasks_created")
  avgParseTimeMs            Int @map("avg_parse_time_ms")
  estimatedFormTimeSavedMin Int @map("estimated_form_time_saved_min")

  // Automation impact
  autoRemindersSet       Int @map("auto_reminders_sent")
  autoDependencyTriggers Int @map("auto_dependency_triggers")
  autoReassignments      Int @map("auto_reassignments") // OOO auto-reassign

  // ROI calculation inputs
  avgHourlyRate   Decimal @map("avg_hourly_rate") @db.Decimal(10, 2)
  totalValueSaved Decimal @map("total_value_saved") @db.Decimal(12, 2)

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@unique([firmId, metricMonth])
  @@index([firmId])
  @@map("automation_roi_metrics")
}

// ============================================================================
// Story 5.1: Email Integration and Synchronization
// ============================================================================

// Email model - synchronized emails from Microsoft Graph API
model Email {
  id                String    @id @default(uuid())
  graphMessageId    String    @unique @map("graph_message_id") // Microsoft Graph message ID
  conversationId    String    @map("conversation_id") // Graph conversation ID for threading
  internetMessageId String?   @map("internet_message_id") // SMTP Message-ID header
  subject           String    @db.VarChar(1000)
  bodyPreview       String    @map("body_preview") @db.VarChar(500)
  bodyContent       String    @map("body_content") @db.Text
  bodyContentType   String    @map("body_content_type") @db.VarChar(10) // text or html
  bodyContentClean  String?   @map("body_content_clean") @db.Text // OPS-090: AI-cleaned content (no signatures, quotes)
  from              Json // { name?: string, address: string }
  toRecipients      Json      @map("to_recipients") // Array of { name?, address }
  ccRecipients      Json      @map("cc_recipients")
  bccRecipients     Json      @map("bcc_recipients")
  receivedDateTime  DateTime  @map("received_date_time") @db.Timestamptz
  sentDateTime      DateTime  @map("sent_date_time") @db.Timestamptz
  hasAttachments    Boolean   @map("has_attachments")
  importance        String    @db.VarChar(10) // low, normal, high
  isRead            Boolean   @map("is_read")
  isIgnored         Boolean   @default(false) @map("is_ignored") // Marked as not case-related
  ignoredAt         DateTime? @map("ignored_at") @db.Timestamptz // When the email was ignored
  folderType        String?   @map("folder_type") @db.VarChar(10) // OPS-091: 'inbox' | 'sent' (deprecated, use parentFolderName)
  parentFolderId    String?   @map("parent_folder_id") @db.VarChar(255) // Graph API folder ID
  parentFolderName  String?   @map("parent_folder_name") @db.VarChar(255) // Display name: "Inbox", "Archive", etc.

  // Privacy fields (OPS-187)
  isPrivate       Boolean   @default(false) @map("is_private") // Marked private by partner
  markedPrivateAt DateTime? @map("marked_private_at") @db.Timestamptz
  markedPrivateBy String?   @map("marked_private_by") // Partner userId who marked it private

  // Classification state machine (OPS-035)
  classificationState      EmailClassificationState @default(Pending) @map("classification_state")
  classificationConfidence Float?                   @map("classification_confidence") // 0.0 - 1.0
  classifiedAt             DateTime?                @map("classified_at") @db.Timestamptz
  classifiedBy             String?                  @map("classified_by") // "auto" or userId
  isSuggestedAssignment    Boolean                  @default(false) @map("is_suggested_assignment") // AI-assigned, may need review

  userId    String   @map("user_id") // User who owns this email
  caseId    String?  @map("case_id") // Assigned case (nullable until categorized)
  firmId    String   @map("firm_id")
  syncedAt  DateTime @default(now()) @map("synced_at") @db.Timestamptz
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user        User              @relation(fields: [userId], references: [id])
  case        Case?             @relation(fields: [caseId], references: [id])
  firm        Firm              @relation(fields: [firmId], references: [id])
  attachments EmailAttachment[]
  caseLinks   EmailCaseLink[] // OPS-058: Multi-case email support

  // Relations (Story 5.2: Communication Intelligence)
  extractedDeadlines   ExtractedDeadline[]
  extractedCommitments ExtractedCommitment[]
  extractedActionItems ExtractedActionItem[]
  extractedQuestions   ExtractedQuestion[]
  riskIndicators       RiskIndicator[]

  // Relations (Story 5.3: Email Drafting)
  drafts EmailDraft[]

  // Relations (OPS-031: Classification Review)
  classificationLogs    EmailClassificationLog[]
  pendingClassification PendingClassification?

  @@index([userId])
  @@index([caseId])
  @@index([conversationId])
  @@index([receivedDateTime])
  @@index([firmId])
  @@index([isIgnored])
  @@index([classificationState])
  @@index([folderType])
  @@index([parentFolderName])
  @@map("emails")
}

// Email attachment model - attachments from synchronized emails
model EmailAttachment {
  id                String   @id @default(uuid())
  emailId           String   @map("email_id")
  graphAttachmentId String   @map("graph_attachment_id")
  name              String   @db.VarChar(500)
  contentType       String   @map("content_type") @db.VarChar(200)
  size              Int
  storageUrl        String?  @map("storage_url") @db.Text // R2/OneDrive URL after saving
  documentId        String?  @map("document_id") // Link to Document if saved to case
  createdAt         DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Filter tracking (OPS-113: Rule-Based Document Filtering)
  filterStatus String?   @map("filter_status") @db.VarChar(20) // 'imported' | 'dismissed' | 'quarantined' | 'flagged'
  filterRuleId String?   @map("filter_rule_id") @db.VarChar(50) // Which rule matched
  filterReason String?   @map("filter_reason") @db.VarChar(200) // Human-readable reason
  dismissedAt  DateTime? @map("dismissed_at") @db.Timestamptz // When filtered

  // OPS-136: User-marked as not useful (signatures, logos, etc.)
  irrelevant Boolean @default(false)

  // Relations
  email    Email     @relation(fields: [emailId], references: [id], onDelete: Cascade)
  document Document? @relation(fields: [documentId], references: [id])

  // OPS-171: Track when this attachment was promoted to a working document
  promotedCaseDocuments CaseDocument[] @relation("PromotedFromAttachment")

  @@index([emailId])
  @@index([documentId])
  @@index([filterStatus])
  @@map("email_attachments")
}

// Email sync state model - tracks sync progress per user
model EmailSyncState {
  id                 String    @id @default(uuid())
  userId             String    @unique @map("user_id")
  deltaToken         String?   @map("delta_token") @db.Text // For incremental sync
  subscriptionId     String?   @map("subscription_id") @db.VarChar(255) // Graph subscription ID
  subscriptionExpiry DateTime? @map("subscription_expiry") @db.Timestamptz
  lastSyncAt         DateTime? @map("last_sync_at") @db.Timestamptz
  syncStatus         String    @default("pending") @map("sync_status") @db.VarChar(20) // pending, syncing, synced, error
  errorMessage       String?   @map("error_message") @db.Text
  createdAt          DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt          DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user User @relation(fields: [userId], references: [id])

  @@map("email_sync_states")
}

// Personal contacts blocklist (OPS-187)
// Emails from these addresses are not synced/displayed for this user
model PersonalContact {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  email     String   @db.VarChar(255) // Blocked email address
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, email])
  @@index([userId])
  @@map("personal_contacts")
}

// ============================================================================
// Story 5.2: Communication Intelligence Engine
// ============================================================================

// Extraction status for AI-extracted items
enum ExtractionStatus {
  Pending // Awaiting user action
  Converted // Converted to task/event
  Dismissed // User dismissed
  Expired // Past due date without action
}

// Risk type classification for email content
enum RiskType {
  ClientDissatisfaction
  DeadlineRisk
  ScopeCreep
  PaymentRisk
  RelationshipRisk
}

// Risk severity levels
enum RiskSeverity {
  Low
  Medium
  High
}

// Extracted deadline from email content (AC: 1, 2)
model ExtractedDeadline {
  id              String           @id @default(uuid())
  emailId         String           @map("email_id")
  caseId          String?          @map("case_id")
  firmId          String           @map("firm_id")
  description     String           @db.Text
  dueDate         DateTime         @map("due_date") @db.Timestamptz
  confidence      Float // 0.0 - 1.0, maps to Low (<0.6), Medium (0.6-0.8), High (>0.8)
  status          ExtractionStatus @default(Pending)
  convertedTaskId String?          @map("converted_task_id")
  dismissedAt     DateTime?        @map("dismissed_at") @db.Timestamptz
  dismissReason   String?          @map("dismiss_reason") @db.VarChar(500)
  createdAt       DateTime         @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime         @updatedAt @map("updated_at") @db.Timestamptz

  email         Email @relation(fields: [emailId], references: [id], onDelete: Cascade)
  case          Case? @relation(fields: [caseId], references: [id])
  firm          Firm  @relation(fields: [firmId], references: [id])
  convertedTask Task? @relation("DeadlineConvertedTask", fields: [convertedTaskId], references: [id])

  @@index([emailId])
  @@index([caseId])
  @@index([status])
  @@map("extracted_deadlines")
}

// Extracted commitment from email content (AC: 1, 2)
model ExtractedCommitment {
  id              String           @id @default(uuid())
  emailId         String           @map("email_id")
  caseId          String?          @map("case_id")
  firmId          String           @map("firm_id")
  party           String           @db.VarChar(200) // Who made the commitment
  commitmentText  String           @map("commitment_text") @db.Text
  dueDate         DateTime?        @map("due_date") @db.Timestamptz
  confidence      Float // 0.0 - 1.0
  status          ExtractionStatus @default(Pending)
  convertedTaskId String?          @map("converted_task_id")
  dismissedAt     DateTime?        @map("dismissed_at") @db.Timestamptz
  dismissReason   String?          @map("dismiss_reason") @db.VarChar(500)
  createdAt       DateTime         @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime         @updatedAt @map("updated_at") @db.Timestamptz

  email         Email @relation(fields: [emailId], references: [id], onDelete: Cascade)
  case          Case? @relation(fields: [caseId], references: [id])
  firm          Firm  @relation(fields: [firmId], references: [id])
  convertedTask Task? @relation("CommitmentConvertedTask", fields: [convertedTaskId], references: [id])

  @@index([emailId])
  @@index([caseId])
  @@map("extracted_commitments")
}

// Extracted action item from email content (AC: 1, 2, 4)
model ExtractedActionItem {
  id                String           @id @default(uuid())
  emailId           String           @map("email_id")
  caseId            String?          @map("case_id")
  firmId            String           @map("firm_id")
  description       String           @db.Text
  suggestedAssignee String?          @map("suggested_assignee") @db.VarChar(200)
  priority          TaskPriority     @default(Medium)
  confidence        Float // 0.0 - 1.0
  status            ExtractionStatus @default(Pending)
  convertedTaskId   String?          @map("converted_task_id")
  dismissedAt       DateTime?        @map("dismissed_at") @db.Timestamptz
  dismissReason     String?          @map("dismiss_reason") @db.VarChar(500)
  createdAt         DateTime         @default(now()) @map("created_at") @db.Timestamptz
  updatedAt         DateTime         @updatedAt @map("updated_at") @db.Timestamptz

  email         Email @relation(fields: [emailId], references: [id], onDelete: Cascade)
  case          Case? @relation(fields: [caseId], references: [id])
  firm          Firm  @relation(fields: [firmId], references: [id])
  convertedTask Task? @relation("ActionItemConvertedTask", fields: [convertedTaskId], references: [id])

  @@index([emailId])
  @@index([caseId])
  @@map("extracted_action_items")
}

// Extracted question requiring response (AC: 1)
model ExtractedQuestion {
  id            String           @id @default(uuid())
  emailId       String           @map("email_id")
  caseId        String?          @map("case_id")
  firmId        String           @map("firm_id")
  questionText  String           @map("question_text") @db.Text
  respondBy     DateTime?        @map("respond_by") @db.Timestamptz
  confidence    Float // 0.0 - 1.0
  status        ExtractionStatus @default(Pending)
  isAnswered    Boolean          @default(false) @map("is_answered")
  answeredAt    DateTime?        @map("answered_at") @db.Timestamptz
  dismissedAt   DateTime?        @map("dismissed_at") @db.Timestamptz
  dismissReason String?          @map("dismiss_reason") @db.VarChar(500)
  createdAt     DateTime         @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime         @updatedAt @map("updated_at") @db.Timestamptz

  email Email @relation(fields: [emailId], references: [id], onDelete: Cascade)
  case  Case? @relation(fields: [caseId], references: [id])
  firm  Firm  @relation(fields: [firmId], references: [id])

  @@index([emailId])
  @@index([caseId])
  @@index([status])
  @@map("extracted_questions")
}

// Risk indicator from email analysis (AC: 6)
model RiskIndicator {
  id              String       @id @default(uuid())
  emailId         String       @map("email_id")
  caseId          String?      @map("case_id")
  firmId          String       @map("firm_id")
  type            RiskType
  severity        RiskSeverity
  description     String       @db.Text
  evidence        String       @db.Text // Quote from email
  suggestedAction String?      @map("suggested_action") @db.Text
  isResolved      Boolean      @default(false) @map("is_resolved")
  resolvedAt      DateTime?    @map("resolved_at") @db.Timestamptz
  resolvedBy      String?      @map("resolved_by")
  createdAt       DateTime     @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime     @updatedAt @map("updated_at") @db.Timestamptz

  email Email @relation(fields: [emailId], references: [id], onDelete: Cascade)
  case  Case? @relation(fields: [caseId], references: [id])
  firm  Firm  @relation(fields: [firmId], references: [id])

  @@index([caseId])
  @@index([type])
  @@index([severity])
  @@map("risk_indicators")
}

// Thread summary for opposing counsel analysis (AC: 5)
// OPS-240: Extended with general summary fields for batch processing
model ThreadSummary {
  id                      String   @id @default(uuid())
  conversationId          String   @unique @map("conversation_id") // Graph conversation ID
  caseId                  String?  @map("case_id")
  firmId                  String   @map("firm_id")
  opposingCounselPosition String?  @map("opposing_counsel_position") @db.Text
  keyArguments            Json?    @map("key_arguments") // Array of argument summaries
  positionChanges         Json?    @map("position_changes") // Array of position change events
  lastAnalyzedAt          DateTime @map("last_analyzed_at") @db.Timestamptz
  messageCount            Int      @map("message_count")
  createdAt               DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt               DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // OPS-240: General thread summary fields (batch processor)
  overview     String? @db.Text // 1-2 sentence overview in Romanian
  keyPoints    Json?   @map("key_points") // Array of bullet points (string[])
  actionItems  Json?   @map("action_items") // Array of action items (string[])
  sentiment    String? @map("sentiment") @db.VarChar(20) // 'positive' | 'neutral' | 'negative' | 'urgent'
  participants Json? // Array of participant names/emails

  case Case? @relation(fields: [caseId], references: [id])
  firm Firm  @relation(fields: [firmId], references: [id])

  @@index([caseId])
  @@map("thread_summaries")
}

// ============================================================================
// Story 5.3: AI-Powered Email Drafting
// ============================================================================

// Email tone options for draft generation
enum EmailTone {
  Formal // Court, official correspondence
  Professional // Standard business communication
  Brief // Quick acknowledgment, simple responses
  Detailed // Comprehensive, thorough explanations
}

// Recipient type for adapting email language
enum RecipientType {
  Client
  OpposingCounsel
  Court
  ThirdParty
  Internal
}

// Draft status for workflow tracking
enum DraftStatus {
  Generated // AI generated, not yet reviewed
  Editing // User is editing
  Ready // Ready to send
  Sent // Email sent
  Discarded // User discarded draft
}

// Email draft model - AI-generated email responses
model EmailDraft {
  id                   String        @id @default(uuid())
  emailId              String        @map("email_id") // Original email being replied to
  caseId               String?       @map("case_id")
  firmId               String        @map("firm_id")
  userId               String        @map("user_id") // User who requested draft
  tone                 EmailTone     @default(Professional)
  recipientType        RecipientType @default(Client)
  subject              String        @db.VarChar(500)
  body                 String        @db.Text
  htmlBody             String?       @map("html_body") @db.Text
  suggestedAttachments Json?         @map("suggested_attachments") // Array of {documentId, title, relevance}
  confidence           Float // 0.0 - 1.0
  status               DraftStatus   @default(Generated)
  userEdits            Json?         @map("user_edits") // Track user modifications
  sentAt               DateTime?     @map("sent_at") @db.Timestamptz
  outlookDraftId       String?       @map("outlook_draft_id") // Outlook message ID when saved as draft
  createdAt            DateTime      @default(now()) @map("created_at") @db.Timestamptz
  updatedAt            DateTime      @updatedAt @map("updated_at") @db.Timestamptz

  email                 Email                  @relation(fields: [emailId], references: [id], onDelete: Cascade)
  case                  Case?                  @relation(fields: [caseId], references: [id])
  firm                  Firm                   @relation(fields: [firmId], references: [id])
  user                  User                   @relation(fields: [userId], references: [id])
  refinements           DraftRefinement[]
  attachmentSuggestions AttachmentSuggestion[]
  editHistory           DraftEditHistory[] // Story 5.6: Track edits for learning

  @@index([emailId])
  @@index([caseId])
  @@index([userId])
  @@index([status])
  @@map("email_drafts")
}

// Source types for sent email drafts (non-AI-drafted emails)
enum SentEmailSource {
  NEW_EMAIL // sendNewEmail mutation
  REPLY // replyToEmail mutation
  TASK_REMINDER // Task due date notification
  OVERDUE_NOTIFICATION // Overdue task notification
}

// Tracks emails sent via platform that weren't AI-drafted (ad-hoc sends)
// These go to Outlook drafts when EMAIL_SEND_MODE=draft
model SentEmailDraft {
  id             String          @id @default(uuid())
  outlookDraftId String          @map("outlook_draft_id") // Outlook message ID for the draft
  userId         String          @map("user_id")
  firmId         String          @map("firm_id")
  recipientEmail String          @map("recipient_email")
  subject        String          @db.VarChar(500)
  caseId         String?         @map("case_id")
  source         SentEmailSource
  createdAt      DateTime        @default(now()) @map("created_at") @db.Timestamptz

  user User  @relation(fields: [userId], references: [id])
  firm Firm  @relation(fields: [firmId], references: [id])
  case Case? @relation(fields: [caseId], references: [id])

  @@index([userId])
  @@index([firmId])
  @@index([outlookDraftId])
  @@index([createdAt])
  @@map("sent_email_drafts")
}

// Draft refinement model - tracks AI refinement history
model DraftRefinement {
  id           String   @id @default(uuid())
  draftId      String   @map("draft_id")
  instruction  String   @db.Text // User's refinement request
  previousBody String   @map("previous_body") @db.Text
  refinedBody  String   @map("refined_body") @db.Text
  tokensUsed   Int      @map("tokens_used")
  createdAt    DateTime @default(now()) @map("created_at") @db.Timestamptz

  draft EmailDraft @relation(fields: [draftId], references: [id], onDelete: Cascade)

  @@index([draftId])
  @@map("draft_refinements")
}

// Attachment suggestion model - AI-suggested attachments for email drafts
model AttachmentSuggestion {
  id             String   @id @default(uuid())
  draftId        String   @map("draft_id")
  documentId     String   @map("document_id")
  title          String   @db.VarChar(500)
  reason         String   @db.Text // Why this document is relevant
  relevanceScore Float    @map("relevance_score") // 0.0 - 1.0
  isSelected     Boolean  @default(false) @map("is_selected")
  createdAt      DateTime @default(now()) @map("created_at") @db.Timestamptz

  draft    EmailDraft @relation(fields: [draftId], references: [id], onDelete: Cascade)
  document Document   @relation(fields: [documentId], references: [id])

  @@index([draftId])
  @@map("attachment_suggestions")
}

// ============================================================================
// Story 5.4: Proactive AI Suggestions System
// ============================================================================

// Suggestion type - what kind of suggestion this is
enum SuggestionType {
  MorningBriefing // Daily prioritized task list
  TaskSuggestion // Suggested next action
  PatternMatch // Based on learned patterns
  DeadlineWarning // Upcoming deadline alert
  DocumentCheck // Document completeness issue
  FollowUp // Follow-up action reminder
  RiskAlert // Risk-based suggestion
}

// Suggestion category - what area the suggestion relates to
enum SuggestionCategory {
  Task // Task-related suggestions
  Communication // Email/communication suggestions
  Document // Document-related suggestions
  Calendar // Calendar/scheduling suggestions
  Compliance // Compliance/deadline suggestions
}

// Suggestion priority level
enum SuggestionPriority {
  Low
  Normal
  High
  Urgent
}

// Suggestion status - lifecycle of a suggestion
enum SuggestionStatus {
  Pending // Awaiting user action
  Accepted // User accepted suggestion
  Dismissed // User dismissed
  Expired // Suggestion expired without action
  AutoApplied // System auto-applied (for low-risk actions)
}

// AI Suggestion model - stores AI-generated suggestions for users
model AISuggestion {
  id              String             @id @default(uuid())
  firmId          String             @map("firm_id")
  userId          String             @map("user_id")
  caseId          String?            @map("case_id")
  type            SuggestionType
  category        SuggestionCategory
  title           String             @db.VarChar(500)
  description     String             @db.Text
  suggestedAction String?            @map("suggested_action") @db.Text
  actionPayload   Json?              @map("action_payload") // Type-specific action data
  confidence      Float // 0.0 - 1.0
  priority        SuggestionPriority @default(Normal)
  context         Json? // Context that triggered suggestion
  status          SuggestionStatus   @default(Pending)
  dismissedAt     DateTime?          @map("dismissed_at") @db.Timestamptz
  dismissReason   String?            @map("dismiss_reason") @db.VarChar(500)
  acceptedAt      DateTime?          @map("accepted_at") @db.Timestamptz
  expiresAt       DateTime?          @map("expires_at") @db.Timestamptz
  createdAt       DateTime           @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime           @updatedAt @map("updated_at") @db.Timestamptz

  firm     Firm                 @relation(fields: [firmId], references: [id])
  user     User                 @relation(fields: [userId], references: [id])
  case     Case?                @relation(fields: [caseId], references: [id])
  feedback SuggestionFeedback[]

  @@index([userId, status])
  @@index([caseId])
  @@index([firmId])
  @@index([type])
  @@index([createdAt])
  @@index([expiresAt])
  @@map("ai_suggestions")
}

// User action pattern model - stores learned user behavior patterns
model UserActionPattern {
  id              String   @id @default(uuid())
  firmId          String   @map("firm_id")
  userId          String   @map("user_id")
  patternType     String   @map("pattern_type") @db.VarChar(100) // 'post_filing_client_update', 'morning_email_check', etc.
  triggerContext  Json     @map("trigger_context") // What triggers this pattern
  actionSequence  Json     @map("action_sequence") // Sequence of actions taken
  occurrenceCount Int      @default(1) @map("occurrence_count")
  lastOccurrence  DateTime @map("last_occurrence") @db.Timestamptz
  confidence      Float // 0.0 - 1.0 based on consistency
  isActive        Boolean  @default(true) @map("is_active")
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime @updatedAt @map("updated_at") @db.Timestamptz

  firm Firm @relation(fields: [firmId], references: [id])
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, patternType])
  @@index([firmId])
  @@index([userId])
  @@index([confidence])
  @@map("user_action_patterns")
}

// Morning briefing model - stores daily AI-generated briefings for users
model MorningBriefing {
  id               String    @id @default(uuid())
  firmId           String    @map("firm_id")
  userId           String    @map("user_id")
  briefingDate     DateTime  @map("briefing_date") @db.Date
  prioritizedTasks Json      @map("prioritized_tasks") // Array of { taskId, priority, reason }
  keyDeadlines     Json      @map("key_deadlines") // Array of upcoming deadlines
  riskAlerts       Json      @map("risk_alerts") // Array of risk indicators
  suggestions      Json // Array of AI suggestions for the day
  summary          String    @db.Text // AI-generated summary
  isViewed         Boolean   @default(false) @map("is_viewed")
  viewedAt         DateTime? @map("viewed_at") @db.Timestamptz
  generatedAt      DateTime  @default(now()) @map("generated_at") @db.Timestamptz
  tokensUsed       Int       @map("tokens_used")

  firm Firm @relation(fields: [firmId], references: [id])
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, briefingDate])
  @@index([firmId])
  @@index([userId])
  @@index([briefingDate])
  @@map("morning_briefings")
}

// Document completeness check model - tracks document validation results
model DocumentCompletenessCheck {
  id           String    @id @default(uuid())
  documentId   String    @map("document_id")
  firmId       String    @map("firm_id")
  documentType String    @map("document_type") @db.VarChar(100)
  missingItems Json      @map("missing_items") // Array of { item, severity, suggestion }
  completeness Float // 0.0 - 1.0 completeness score
  checkType    String    @map("check_type") @db.VarChar(50) // 'signature', 'section', 'reference'
  isResolved   Boolean   @default(false) @map("is_resolved")
  resolvedAt   DateTime? @map("resolved_at") @db.Timestamptz
  resolvedBy   String?   @map("resolved_by")
  createdAt    DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt    DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@index([firmId])
  @@index([isResolved])
  @@map("document_completeness_checks")
}

// Suggestion feedback model - tracks user feedback on suggestions for learning
model SuggestionFeedback {
  id             String   @id @default(uuid())
  suggestionId   String   @map("suggestion_id")
  userId         String   @map("user_id")
  firmId         String   @map("firm_id")
  action         String   @db.VarChar(50) // 'accepted', 'dismissed', 'modified', 'ignored'
  modifiedAction Json?    @map("modified_action") // What user did instead
  feedbackReason String?  @map("feedback_reason") @db.VarChar(500)
  responseTimeMs Int?     @map("response_time_ms") // Time to respond
  createdAt      DateTime @default(now()) @map("created_at") @db.Timestamptz

  suggestion AISuggestion @relation(fields: [suggestionId], references: [id], onDelete: Cascade)

  @@index([suggestionId])
  @@index([userId])
  @@index([firmId])
  @@index([action])
  @@map("suggestion_feedback")
}

// ============================================================================
// Story 5.5: Multi-Channel Communication Hub
// ============================================================================

// Communication channel types
enum CommunicationChannel {
  Email // Synchronized from Microsoft Graph
  InternalNote // Platform internal notes
  WhatsApp // Future: WhatsApp Business API
  Phone // Phone call logs
  Meeting // Meeting notes
  SMS // Future: SMS integration
}

// Communication direction
enum CommunicationDirection {
  Inbound // Received communication
  Outbound // Sent communication
  Internal // Internal note/memo
}

// Privacy level for sensitive communications
enum PrivacyLevel {
  Normal // Visible to all case team members
  Confidential // Visible to specified users only
  AttorneyOnly // Visible to attorneys only (Partners, Associates)
  PartnerOnly // Visible to Partners only
}

// Template categories for communication templates
enum TemplateCategory {
  ClientUpdate // Case status updates to clients
  CourtFiling // Court filing notifications
  AppointmentReminder // Meeting/appointment reminders
  DocumentRequest // Request for documents
  InvoiceReminder // Payment/invoice reminders
  CaseOpening // New case welcome
  CaseClosing // Case conclusion notification
  General // General purpose
}

// Bulk communication recipient types
enum BulkRecipientType {
  CaseClients // All clients on a specific case
  CaseTeam // All team members on a case
  AllClients // All firm clients
  CustomList // Custom recipient list
  CaseTypeClients // Clients by case type
}

// Bulk communication status
enum BulkCommunicationStatus {
  Draft // Being composed
  Scheduled // Scheduled for future send
  InProgress // Currently sending
  Completed // All sent
  PartiallyFailed // Some failed
  Cancelled // User cancelled
}

// Export format options
enum ExportFormat {
  PDF // Formatted PDF document
  CSV // Spreadsheet format
  JSON // Machine-readable format
  DOCX // Word document
}

// Export status
enum ExportStatus {
  Processing // Export in progress
  Completed // Ready for download
  Failed // Export failed
  Expired // Download link expired
}

// Unified communication entry - stores all communication types in one table
model CommunicationEntry {
  id             String                 @id @default(uuid())
  firmId         String                 @map("firm_id")
  caseId         String                 @map("case_id")
  channelType    CommunicationChannel   @map("channel_type")
  direction      CommunicationDirection
  subject        String?                @db.VarChar(500)
  body           String                 @db.Text
  htmlBody       String?                @map("html_body") @db.Text
  senderId       String                 @map("sender_id")
  senderName     String                 @map("sender_name") @db.VarChar(200)
  senderEmail    String?                @map("sender_email") @db.VarChar(255)
  recipients     Json // Array of { id, name, email, type: 'to'|'cc'|'bcc' }
  externalId     String?                @map("external_id") @db.VarChar(255) // Graph message ID, WhatsApp ID, etc.
  parentId       String?                @map("parent_id") // For threaded conversations
  isPrivate      Boolean                @default(false) @map("is_private")
  privacyLevel   PrivacyLevel           @default(Normal) @map("privacy_level")
  allowedViewers String[]               @map("allowed_viewers") // User IDs if private
  hasAttachments Boolean                @default(false) @map("has_attachments")
  metadata       Json? // Channel-specific metadata
  sentAt         DateTime               @map("sent_at") @db.Timestamptz
  createdAt      DateTime               @default(now()) @map("created_at") @db.Timestamptz
  updatedAt      DateTime               @updatedAt @map("updated_at") @db.Timestamptz

  firm        Firm                      @relation(fields: [firmId], references: [id])
  case        Case                      @relation(fields: [caseId], references: [id])
  sender      User                      @relation("CommunicationSender", fields: [senderId], references: [id])
  parent      CommunicationEntry?       @relation("CommunicationThread", fields: [parentId], references: [id])
  children    CommunicationEntry[]      @relation("CommunicationThread")
  attachments CommunicationAttachment[]

  @@index([caseId, sentAt])
  @@index([firmId])
  @@index([channelType])
  @@index([senderId])
  @@index([parentId])
  @@index([externalId])
  @@map("communication_entries")
}

// Communication attachment - attachments for communication entries
model CommunicationAttachment {
  id                   String   @id @default(uuid())
  communicationEntryId String   @map("communication_entry_id")
  fileName             String   @map("file_name") @db.VarChar(500)
  fileSize             Int      @map("file_size")
  mimeType             String   @map("mime_type") @db.VarChar(200)
  storageUrl           String   @map("storage_url") @db.Text
  documentId           String?  @map("document_id") // Link to Document if saved to case
  createdAt            DateTime @default(now()) @map("created_at") @db.Timestamptz

  communicationEntry CommunicationEntry @relation(fields: [communicationEntryId], references: [id], onDelete: Cascade)
  document           Document?          @relation(fields: [documentId], references: [id])

  @@index([communicationEntryId])
  @@index([documentId])
  @@map("communication_attachments")
}

// Communication template - reusable templates for standard communications
model CommunicationTemplate {
  id          String               @id @default(uuid())
  firmId      String               @map("firm_id")
  name        String               @db.VarChar(200)
  description String?              @db.VarChar(500)
  category    TemplateCategory
  channelType CommunicationChannel @map("channel_type")
  subject     String?              @db.VarChar(500)
  body        String               @db.Text
  htmlBody    String?              @map("html_body") @db.Text
  variables   Json // Array of { name, description, defaultValue, required }
  isActive    Boolean              @default(true) @map("is_active")
  isGlobal    Boolean              @default(false) @map("is_global") // Available to all users
  createdBy   String               @map("created_by")
  usageCount  Int                  @default(0) @map("usage_count")
  lastUsedAt  DateTime?            @map("last_used_at") @db.Timestamptz
  createdAt   DateTime             @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime             @updatedAt @map("updated_at") @db.Timestamptz

  firm    Firm @relation(fields: [firmId], references: [id])
  creator User @relation("TemplateCreator", fields: [createdBy], references: [id])

  @@index([firmId])
  @@index([category])
  @@index([channelType])
  @@index([isActive])
  @@map("communication_templates")
}

// Bulk communication - send messages to multiple recipients
model BulkCommunication {
  id              String                  @id @default(uuid())
  firmId          String                  @map("firm_id")
  caseId          String?                 @map("case_id") // Optional: case-specific bulk comm
  templateId      String?                 @map("template_id")
  subject         String                  @db.VarChar(500)
  body            String                  @db.Text
  htmlBody        String?                 @map("html_body") @db.Text
  channelType     CommunicationChannel    @map("channel_type")
  recipientType   BulkRecipientType       @map("recipient_type")
  recipientFilter Json                    @map("recipient_filter") // Criteria for selecting recipients
  recipients      Json // Array of resolved recipients
  totalRecipients Int                     @map("total_recipients")
  sentCount       Int                     @default(0) @map("sent_count")
  failedCount     Int                     @default(0) @map("failed_count")
  status          BulkCommunicationStatus @default(Draft)
  scheduledFor    DateTime?               @map("scheduled_for") @db.Timestamptz
  startedAt       DateTime?               @map("started_at") @db.Timestamptz
  completedAt     DateTime?               @map("completed_at") @db.Timestamptz
  createdBy       String                  @map("created_by")
  createdAt       DateTime                @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime                @updatedAt @map("updated_at") @db.Timestamptz

  firm    Firm                   @relation(fields: [firmId], references: [id])
  case    Case?                  @relation(fields: [caseId], references: [id])
  creator User                   @relation("BulkCommunicationCreator", fields: [createdBy], references: [id])
  logs    BulkCommunicationLog[]

  @@index([firmId])
  @@index([caseId])
  @@index([status])
  @@index([createdBy])
  @@map("bulk_communications")
}

// Bulk communication log - tracks individual sends
model BulkCommunicationLog {
  id                  String    @id @default(uuid())
  bulkCommunicationId String    @map("bulk_communication_id")
  recipientId         String    @map("recipient_id")
  recipientEmail      String    @map("recipient_email") @db.VarChar(255)
  recipientName       String    @map("recipient_name") @db.VarChar(200)
  status              String    @db.VarChar(20) // sent, failed, pending
  errorMessage        String?   @map("error_message") @db.Text
  sentAt              DateTime? @map("sent_at") @db.Timestamptz
  createdAt           DateTime  @default(now()) @map("created_at") @db.Timestamptz

  bulkCommunication BulkCommunication @relation(fields: [bulkCommunicationId], references: [id], onDelete: Cascade)

  @@index([bulkCommunicationId])
  @@index([status])
  @@map("bulk_communication_logs")
}

// Communication export - export communication history for case documentation
model CommunicationExport {
  id                 String       @id @default(uuid())
  firmId             String       @map("firm_id")
  caseId             String       @map("case_id")
  exportedBy         String       @map("exported_by")
  format             ExportFormat
  dateRangeFrom      DateTime?    @map("date_range_from") @db.Timestamptz
  dateRangeTo        DateTime?    @map("date_range_to") @db.Timestamptz
  channelTypes       Json         @map("channel_types") // Array of CommunicationChannel
  includeAttachments Boolean      @default(false) @map("include_attachments")
  totalEntries       Int          @map("total_entries")
  fileUrl            String?      @map("file_url") @db.Text
  status             ExportStatus @default(Processing)
  errorMessage       String?      @map("error_message") @db.Text
  expiresAt          DateTime     @map("expires_at") @db.Timestamptz // Auto-delete after expiry
  createdAt          DateTime     @default(now()) @map("created_at") @db.Timestamptz
  completedAt        DateTime?    @map("completed_at") @db.Timestamptz

  firm     Firm @relation(fields: [firmId], references: [id])
  case     Case @relation(fields: [caseId], references: [id])
  exporter User @relation("CommunicationExporter", fields: [exportedBy], references: [id])

  @@index([caseId])
  @@index([exportedBy])
  @@index([status])
  @@map("communication_exports")
}

// ============================================================================
// Story 5.6: AI Learning and Personalization Models
// ============================================================================

// Writing style profile - learns user's writing style from draft edits (AC: 1)
model WritingStyleProfile {
  id                    String    @id @default(uuid())
  firmId                String    @map("firm_id")
  userId                String    @unique @map("user_id")
  formalityLevel        Float     @default(0.5) @map("formality_level") // 0=casual, 1=formal
  averageSentenceLength Float     @default(15) @map("average_sentence_length")
  vocabularyComplexity  Float     @default(0.5) @map("vocabulary_complexity") // 0=simple, 1=complex
  preferredTone         String    @default("Professional") @map("preferred_tone") @db.VarChar(50)
  commonPhrases         Json      @default("[]") @map("common_phrases") // Array of { phrase, frequency, context }
  punctuationStyle      Json      @default("{}") @map("punctuation_style") // { useOxfordComma, preferSemicolons, etc. }
  languagePatterns      Json      @default("{}") @map("language_patterns") // Romanian vs English patterns
  sampleCount           Int       @default(0) @map("sample_count") // Number of edits analyzed
  lastAnalyzedAt        DateTime? @map("last_analyzed_at") @db.Timestamptz
  createdAt             DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt             DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  firm Firm @relation(fields: [firmId], references: [id])
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([firmId])
  @@map("writing_style_profiles")
}

// Snippet category for personal snippets (AC: 2)
enum SnippetCategory {
  Greeting // Email greetings
  Closing // Email closings/signatures
  LegalPhrase // Common legal phrases
  ClientResponse // Standard client responses
  InternalNote // Internal communication snippets
  Custom // User-defined
}

// Personal snippet - frequently used phrases saved as shortcuts (AC: 2)
model PersonalSnippet {
  id             String          @id @default(uuid())
  firmId         String          @map("firm_id")
  userId         String          @map("user_id")
  shortcut       String          @db.VarChar(50) // e.g., "/greeting", "/closing"
  title          String          @db.VarChar(200)
  content        String          @db.Text
  category       SnippetCategory
  usageCount     Int             @default(0) @map("usage_count")
  lastUsedAt     DateTime?       @map("last_used_at") @db.Timestamptz
  isAutoDetected Boolean         @default(false) @map("is_auto_detected") // AI detected vs manually created
  sourceContext  Json?           @map("source_context") // Where snippet was detected
  createdAt      DateTime        @default(now()) @map("created_at") @db.Timestamptz
  updatedAt      DateTime        @updatedAt @map("updated_at") @db.Timestamptz

  firm Firm @relation(fields: [firmId], references: [id])
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, shortcut])
  @@index([firmId])
  @@index([userId])
  @@index([category])
  @@map("personal_snippets")
}

// Task creation pattern - learned patterns for automatic task suggestions (AC: 3)
// Architectural Note: Separate from UserActionPattern because:
// - UserActionPattern tracks general behavioral sequences (any action type)
// - TaskCreationPattern stores structured task templates with specific fields
// - Separation allows type-safe task creation without JSON parsing overhead
model TaskCreationPattern {
  id              String    @id @default(uuid())
  firmId          String    @map("firm_id")
  userId          String    @map("user_id")
  patternName     String    @map("pattern_name") @db.VarChar(200)
  triggerType     String    @map("trigger_type") @db.VarChar(100) // 'case_type', 'document_type', 'email_keyword', etc.
  triggerContext  Json      @map("trigger_context") // What triggers this pattern
  taskTemplate    Json      @map("task_template") // { type, title, description, priority, estimatedHours }
  occurrenceCount Int       @default(1) @map("occurrence_count")
  confidence      Float // 0.0 - 1.0
  isActive        Boolean   @default(true) @map("is_active")
  lastTriggeredAt DateTime? @map("last_triggered_at") @db.Timestamptz
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  firm Firm @relation(fields: [firmId], references: [id])
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, patternName])
  @@index([firmId])
  @@index([userId])
  @@index([confidence])
  @@map("task_creation_patterns")
}

// Document structure preference - preferred document formatting per user (AC: 4)
model DocumentStructurePreference {
  id                String    @id @default(uuid())
  firmId            String    @map("firm_id")
  userId            String    @map("user_id")
  documentType      String    @map("document_type") @db.VarChar(100) // 'Contract', 'Motion', etc.
  preferredSections Json      @map("preferred_sections") // Array of { name, order, required }
  headerStyle       Json      @map("header_style") // { format, numbering, etc. }
  footerContent     String?   @map("footer_content") @db.Text
  marginPreferences Json?     @map("margin_preferences") // { top, bottom, left, right }
  fontPreferences   Json?     @map("font_preferences") // { family, size, lineHeight }
  usageCount        Int       @default(0) @map("usage_count")
  lastUsedAt        DateTime? @map("last_used_at") @db.Timestamptz
  createdAt         DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt         DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  firm Firm @relation(fields: [firmId], references: [id])
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, documentType])
  @@index([firmId])
  @@index([userId])
  @@map("document_structure_preferences")
}

// Response time pattern - tracks user's task completion timing patterns (AC: 5)
model ResponseTimePattern {
  id                   String   @id @default(uuid())
  firmId               String   @map("firm_id")
  userId               String   @map("user_id")
  taskType             String   @map("task_type") @db.VarChar(100)
  caseType             String?  @map("case_type") @db.VarChar(100)
  averageResponseHours Float    @map("average_response_hours")
  medianResponseHours  Float    @map("median_response_hours")
  minResponseHours     Float    @map("min_response_hours")
  maxResponseHours     Float    @map("max_response_hours")
  sampleCount          Int      @default(0) @map("sample_count")
  stdDeviation         Float?   @map("std_deviation")
  dayOfWeekPattern     Json?    @map("day_of_week_pattern") // { monday: avgHours, tuesday: avgHours, etc. }
  timeOfDayPattern     Json?    @map("time_of_day_pattern") // { morning: avgHours, afternoon: avgHours, etc. }
  lastCalculatedAt     DateTime @map("last_calculated_at") @db.Timestamptz
  createdAt            DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt            DateTime @updatedAt @map("updated_at") @db.Timestamptz

  firm Firm @relation(fields: [firmId], references: [id])
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, taskType, caseType])
  @@index([firmId])
  @@index([userId])
  @@map("response_time_patterns")
}

// Edit type for draft edit history (AC: 1)
enum EditType {
  Addition // User added content
  Deletion // User removed content
  Replacement // User replaced content
  Reorder // User reordered content
  StyleChange // Formatting/style changes
}

// Draft edit history - tracks edits to learn writing style (AC: 1)
model DraftEditHistory {
  id              String   @id @default(uuid())
  firmId          String   @map("firm_id")
  userId          String   @map("user_id")
  draftId         String   @map("draft_id") // EmailDraft ID
  originalText    String   @map("original_text") @db.Text
  editedText      String   @map("edited_text") @db.Text
  editType        EditType @map("edit_type")
  editLocation    String   @map("edit_location") @db.VarChar(100) // 'greeting', 'body', 'closing', 'full'
  isStyleAnalyzed Boolean  @default(false) @map("is_style_analyzed")
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz

  firm  Firm       @relation(fields: [firmId], references: [id])
  user  User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  draft EmailDraft @relation(fields: [draftId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([firmId])
  @@index([isStyleAnalyzed])
  @@map("draft_edit_history")
}

// ============================================================================
// OPS-031: Classification Review & Correction
// ============================================================================

// Classification action types for audit logging
enum ClassificationAction {
  Assigned // Initial assignment (import) - AI or manual
  Moved // Moved between cases
  Ignored // Marked as not case-related
  Unassigned // Removed from case without reassigning
  MANUAL_COURT_ASSIGN // User assigned court email to case
  MANUAL_IGNORE // User marked email as not case-related
  MANUAL_CLASSIFY // User manually classified email
  MANUAL_LINK // User linked email to additional case
  MANUAL_UNLINK // User removed email from case
  CONFIRMED // OPS-195: User confirmed multi-case assignment
  MANUAL_REASSIGN // OPS-195: User reassigned email to different case
}

// Classification match type - how the email was matched to a case
enum ClassificationMatchType {
  Actor // Matched by sender/recipient in CaseActor
  ReferenceNumber // Matched court file or contract reference
  Keyword // Matched case keywords
  Semantic // AI semantic similarity match
  GlobalSource // Matched global email source (court, authority)
  Manual // User manually assigned
  ThreadContinuity // Matched by conversation thread (OPS-058)
}

// Classification reason - why an email needs review
enum ClassificationReason {
  MultiCaseConflict // Multiple cases match with similar confidence
  LowConfidence // Single match but below threshold
  NoMatchingCase // No case matched criteria
  CourtNoReference // Court email without reference number match
  UnknownContact // Sender not in any CaseActor
}

// Email classification state machine (OPS-035)
enum EmailClassificationState {
  Pending // Just synced, not yet processed
  Classified // Assigned to case (auto or manual)
  Uncertain // In NECLAR queue (needs user review)
  CourtUnassigned // In INSTANȚE folder (court email, no case match)
  Ignored // Marked as not relevant
}

// ============================================================================
// OPS-031: Email Classification Audit Log
// ============================================================================

// Email classification audit log - tracks all classification decisions (OPS-031)
model EmailClassificationLog {
  id      String @id @default(uuid())
  emailId String @map("email_id")
  firmId  String @map("firm_id")

  action ClassificationAction // ASSIGNED, MOVED, IGNORED, UNASSIGNED

  // Case transition (null for initial assignment or ignore)
  fromCaseId String? @map("from_case_id")
  toCaseId   String? @map("to_case_id")

  // Classification context
  wasAutomatic Boolean                  @default(false) @map("was_automatic") // AI assigned vs human
  confidence   Float? // If AI assigned, the confidence score
  matchType    ClassificationMatchType? @map("match_type") // How the email was matched

  // Human correction context
  correctionReason String? @map("correction_reason") @db.Text // Why user moved/corrected

  // Audit fields
  performedBy String   @map("performed_by")
  performedAt DateTime @default(now()) @map("performed_at") @db.Timestamptz

  // Relations
  email    Email @relation(fields: [emailId], references: [id], onDelete: Cascade)
  firm     Firm  @relation(fields: [firmId], references: [id])
  fromCase Case? @relation("ClassificationFromCase", fields: [fromCaseId], references: [id])
  toCase   Case? @relation("ClassificationToCase", fields: [toCaseId], references: [id])
  user     User  @relation(fields: [performedBy], references: [id])

  @@index([emailId])
  @@index([fromCaseId])
  @@index([toCaseId])
  @@index([firmId])
  @@index([performedAt])
  @@index([action])
  @@map("email_classification_logs")
}

// Pending classification queue - emails awaiting manual review (OPS-031)
model PendingClassification {
  id      String @id @default(uuid())
  emailId String @unique @map("email_id") // One pending entry per email
  firmId  String @map("firm_id")

  reason             ClassificationReason
  suggestedCases     Json                 @default("[]") @map("suggested_cases") // Array of { caseId, confidence, matchType }
  detectedReferences String[]             @default([]) @map("detected_references") // Reference numbers found in email

  // Status
  isResolved Boolean   @default(false) @map("is_resolved")
  resolvedAt DateTime? @map("resolved_at") @db.Timestamptz
  resolvedBy String?   @map("resolved_by")

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  email    Email @relation(fields: [emailId], references: [id], onDelete: Cascade)
  firm     Firm  @relation(fields: [firmId], references: [id])
  resolver User? @relation(fields: [resolvedBy], references: [id])

  @@index([firmId])
  @@index([isResolved])
  @@index([reason])
  @@index([createdAt])
  @@map("pending_classifications")
}

// ============================================================================
// OPS-046: Persistent AI Case Summary
// ============================================================================

// Cached AI-generated case summary with stale detection
model CaseSummary {
  id     String @id @default(cuid())
  caseId String @unique @map("case_id")

  // Summary content
  executiveSummary String @map("executive_summary") @db.Text
  currentStatus    String @map("current_status") @db.Text
  keyDevelopments  Json   @default("[]") @map("key_developments") // String[]
  openIssues       Json   @default("[]") @map("open_issues") // String[]

  // Cache management
  generatedAt     DateTime @map("generated_at") @db.Timestamptz
  isStale         Boolean  @default(false) @map("is_stale")
  dataVersionHash String?  @map("data_version_hash") // Hash of input data to detect changes

  // Input counts for staleness detection
  emailCount    Int @default(0) @map("email_count")
  documentCount Int @default(0) @map("document_count")
  noteCount     Int @default(0) @map("note_count")
  taskCount     Int @default(0) @map("task_count")

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId])
  @@index([isStale])
  @@map("case_summaries")
}

// ============================================================================
// OPS-058: Multi-Case Email Support
// ============================================================================

// Junction table for email-to-case many-to-many relationships (OPS-058)
// Replaces the single Email.caseId field to allow emails to belong to multiple cases
model EmailCaseLink {
  id      String @id @default(uuid())
  emailId String @map("email_id")
  caseId  String @map("case_id")

  // Classification metadata (per-case assignment)
  confidence Float?                   @default(1.0) // 0.0-1.0, confidence of this assignment
  matchType  ClassificationMatchType? @map("match_type") // How this link was created
  linkedAt   DateTime                 @default(now()) @map("linked_at") @db.Timestamptz
  linkedBy   String                   @map("linked_by") // "auto" or userId
  isPrimary  Boolean                  @default(false) @map("is_primary") // First/original assignment

  // Relations
  email Email @relation(fields: [emailId], references: [id], onDelete: Cascade)
  case  Case  @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@unique([emailId, caseId])
  @@index([emailId])
  @@index([caseId])
  @@index([linkedAt])
  @@map("email_case_links")
}

// ============================================================================
// Historical Email Sync Job (for syncing historical emails when client added to case)
// ============================================================================

// Status of historical email sync job
enum HistoricalEmailSyncStatus {
  Pending // Job created, waiting to be picked up
  InProgress // Worker is processing
  Completed // All emails synced successfully
  Failed // Job failed (check errorMessage)
}

model HistoricalEmailSyncJob {
  id           String                    @id @default(uuid())
  caseId       String                    @map("case_id")
  contactEmail String                    @map("contact_email") @db.VarChar(320)
  contactRole  String                    @default("Client") @map("contact_role") @db.VarChar(50)
  status       HistoricalEmailSyncStatus @default(Pending)
  totalEmails  Int?                      @map("total_emails")
  syncedEmails Int                       @default(0) @map("synced_emails")
  errorMessage String?                   @map("error_message") @db.Text
  startedAt    DateTime?                 @map("started_at") @db.Timestamptz
  completedAt  DateTime?                 @map("completed_at") @db.Timestamptz
  createdAt    DateTime                  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt    DateTime                  @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@unique([caseId, contactEmail])
  @@index([caseId])
  @@index([status])
  @@map("historical_email_sync_jobs")
}

// ============================================================================
// OPS-063: AI Conversation Data Model
// ============================================================================

// Conversation session status
enum ConversationStatus {
  Active // User is actively conversing
  AwaitingConfirmation // Waiting for user to confirm an action
  Completed // Conversation finished normally
  Expired // Session timed out or abandoned
}

// Message role in conversation
enum AIMessageRole {
  User // User input
  Assistant // AI response
  System // System message (context, errors)
}

// Action state machine
enum AIActionStatus {
  Proposed // AI proposed an action
  Confirmed // User approved the action
  Executed // Action completed successfully
  Rejected // User declined the action
  Failed // Execution failed
}

// AI Conversation session - multi-turn interaction with context
model AIConversation {
  id       String             @id @default(uuid())
  firmId   String             @map("firm_id")
  userId   String             @map("user_id")
  caseId   String?            @map("case_id")
  status   ConversationStatus @default(Active)
  context  Json               @default("{}") // Contextual data for the conversation
  closedAt DateTime?          @map("closed_at") @db.Timestamptz

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  firm     Firm        @relation(fields: [firmId], references: [id], onDelete: Cascade)
  user     User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  case     Case?       @relation(fields: [caseId], references: [id], onDelete: SetNull)
  messages AIMessage[]

  @@index([firmId])
  @@index([userId, status])
  @@index([caseId])
  @@map("ai_conversations")
}

// AI Message - individual message in a conversation
model AIMessage {
  id             String          @id @default(uuid())
  conversationId String          @map("conversation_id")
  role           AIMessageRole
  content        String          @db.Text
  intent         String?         @db.VarChar(100) // Detected intent (e.g., "create_task", "query_case")
  confidence     Float? // Confidence in intent detection
  actionType     String?         @map("action_type") @db.VarChar(100) // Type of action if applicable
  actionPayload  Json?           @map("action_payload") // Parameters for the action
  actionStatus   AIActionStatus? @map("action_status") // Current action state
  tokensUsed     Int?            @map("tokens_used") // For usage tracking
  modelUsed      String?         @map("model_used") @db.VarChar(50) // e.g., "haiku", "sonnet"
  latencyMs      Int?            @map("latency_ms") // Response time tracking

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  conversation AIConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId, createdAt])
  @@map("ai_messages")
}

// ============================================================================
// OPS-099: Mapa (Document Binder/Dossier)
// ============================================================================

// Mapa - document binder for organizing case documents with defined slots
model Mapa {
  id          String  @id @default(uuid())
  caseId      String  @map("case_id")
  name        String  @db.VarChar(255) // e.g., "Mapa pentru Tribunal"
  description String? @db.Text

  // Template reference (optional - for pre-defined structures)
  templateId String? @map("template_id")

  // Metadata
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz
  createdById String   @map("created_by_id")

  // Relations
  case      Case          @relation(fields: [caseId], references: [id], onDelete: Cascade)
  template  MapaTemplate? @relation(fields: [templateId], references: [id], onDelete: SetNull)
  createdBy User          @relation("MapaCreator", fields: [createdById], references: [id], onDelete: Restrict)
  slots     MapaSlot[]

  @@index([caseId])
  @@index([templateId])
  @@map("mape")
}

// MapaSlot - individual slot within a mapa (can be filled or empty)
model MapaSlot {
  id     String @id @default(uuid())
  mapaId String @map("mapa_id")

  // Slot definition
  name        String  @db.VarChar(255) // e.g., "Cerere de chemare în judecată"
  description String? @db.Text // Optional guidance text
  category    String? @db.VarChar(100) // e.g., "Acte procedurale", "Dovezi"
  required    Boolean @default(true)
  order       Int // Position in TOC

  // Assigned document (null = slot is empty/missing)
  caseDocumentId String? @map("case_document_id")

  // Timestamps
  createdAt    DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt    DateTime  @updatedAt @map("updated_at") @db.Timestamptz
  assignedAt   DateTime? @map("assigned_at") @db.Timestamptz // When document was assigned
  assignedById String?   @map("assigned_by_id")

  // Relations
  mapa         Mapa          @relation(fields: [mapaId], references: [id], onDelete: Cascade)
  caseDocument CaseDocument? @relation(fields: [caseDocumentId], references: [id], onDelete: SetNull)
  assignedBy   User?         @relation("SlotAssigner", fields: [assignedById], references: [id], onDelete: SetNull)

  @@unique([mapaId, order]) // Ensure unique ordering within mapa
  @@index([mapaId])
  @@index([caseDocumentId])
  @@map("mapa_slots")
}

// MapaTemplate - firm-level reusable mapa structures
model MapaTemplate {
  id     String @id @default(uuid())
  firmId String @map("firm_id")

  name        String  @db.VarChar(255) // e.g., "Mapa Standard Civilă"
  description String? @db.Text
  caseType    String? @map("case_type") @db.VarChar(50) // Optional: associate with case types

  // Template slot definitions (JSON for flexibility)
  // Array of: { name, description?, category?, required, order }
  slotDefinitions Json @default("[]") @map("slot_definitions")

  // Metadata
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz
  createdById String   @map("created_by_id")

  // Relations
  firm      Firm   @relation(fields: [firmId], references: [id], onDelete: Cascade)
  createdBy User   @relation("MapaTemplateCreator", fields: [createdById], references: [id], onDelete: Restrict)
  mape      Mapa[] // Mape created from this template

  @@index([firmId])
  @@index([caseType])
  @@map("mapa_templates")
}

// ============================================================================
// OPS-115: AI Context Files - Data Model
// ============================================================================

// Event types for user activity tracking
enum ActivityEventType {
  // Email events
  EMAIL_RECEIVED
  EMAIL_CLASSIFIED
  EMAIL_FROM_COURT // High importance

  // Document events
  DOCUMENT_UPLOADED
  DOCUMENT_SHARED

  // Task events
  TASK_ASSIGNED
  TASK_DUE_TODAY
  TASK_OVERDUE
  TASK_COMPLETED

  // Case events
  CASE_DEADLINE_APPROACHING
  CASE_HEARING_TODAY
  CASE_STATUS_CHANGED

  // Calendar events
  CALENDAR_EVENT_TODAY
  CALENDAR_EVENT_REMINDER
}

// Entity types for activity events
enum ActivityEntityType {
  EMAIL
  DOCUMENT
  TASK
  CASE
  CALENDAR_EVENT
}

// Importance levels for events
enum EventImportance {
  LOW
  NORMAL
  HIGH
  URGENT
}

// UserActivityEvent - tracks all events relevant to a user
// Used for notifications and "what's new" queries
model UserActivityEvent {
  id     String @id @default(uuid())
  userId String @map("user_id")
  firmId String @map("firm_id")

  // Event details
  eventType   ActivityEventType  @map("event_type")
  entityType  ActivityEntityType @map("entity_type")
  entityId    String             @map("entity_id")
  entityTitle String?            @map("entity_title") @db.VarChar(500) // Denormalized for quick display

  // Metadata
  metadata   Json? // Event-specific data
  importance EventImportance @default(NORMAL)

  // State tracking
  notified Boolean   @default(false)
  seenAt   DateTime? @map("seen_at") @db.Timestamptz

  // Timestamps
  occurredAt DateTime @default(now()) @map("occurred_at") @db.Timestamptz
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  firm Firm @relation(fields: [firmId], references: [id], onDelete: Cascade)

  @@index([userId, notified, occurredAt])
  @@index([userId, eventType, occurredAt])
  @@index([firmId, occurredAt])
  @@map("user_activity_events")
}

// UserDailyContext - pre-computed daily snapshot for fast AI access
model UserDailyContext {
  id     String @id @default(uuid())
  userId String @unique @map("user_id")
  firmId String @map("firm_id")

  // Computed state (JSON for flexibility)
  contextData Json @map("context_data") // See UserContextData type

  // Tracking
  lastComputedAt  DateTime  @map("last_computed_at") @db.Timestamptz
  lastBriefingAt  DateTime? @map("last_briefing_at") @db.Timestamptz // When user last got morning briefing
  lastSeenEventId String?   @map("last_seen_event_id") // Watermark for "what's new"

  // Cache control
  validUntil DateTime @map("valid_until") @db.Timestamptz // Soft expiry

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([validUntil])
  @@map("user_daily_contexts")
}

// CaseBriefing - per-case context for case-specific conversations
model CaseBriefing {
  id     String @id @default(uuid())
  caseId String @unique @map("case_id")
  firmId String @map("firm_id")

  // Computed briefing (markdown/text for direct injection)
  briefingText String @map("briefing_text") @db.Text
  briefingData Json   @map("briefing_data") // Structured data

  // Tracking
  lastComputedAt DateTime @map("last_computed_at") @db.Timestamptz
  validUntil     DateTime @map("valid_until") @db.Timestamptz // Soft expiry

  // Invalidation tracking
  lastEmailAt    DateTime? @map("last_email_at") @db.Timestamptz
  lastDocumentAt DateTime? @map("last_document_at") @db.Timestamptz
  lastTaskAt     DateTime? @map("last_task_at") @db.Timestamptz

  // OPS-257: Rich context sections for pre-compiled AI context
  documentSummaries    Json? @map("document_summaries") // Top document summaries
  emailThreadSummaries Json? @map("email_thread_summaries") // Recent thread summaries with action items
  upcomingDeadlines    Json? @map("upcoming_deadlines") // Next 10 deadlines structured
  contactContext       Json? @map("contact_context") // Case contacts with last communication
  clientContext        Json? @map("client_context") // Client profile, portfolio, relationship
  caseHealthIndicators Json? @map("case_health_indicators") // Risk flags, staleness warnings
  contextVersion       Int   @default(1) @map("context_version") // Schema version for migrations

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId])
  @@index([validUntil])
  @@map("case_briefings")
}

// ============================================================================
// OPS-120: Notification Engine
// ============================================================================

// InAppNotification - in-app notifications for users
model InAppNotification {
  id     String @id @default(uuid())
  userId String @map("user_id")

  // Notification content
  title String  @db.VarChar(255)
  body  String  @db.Text
  icon  String? @db.VarChar(50) // Icon identifier: court, email, task, warning, calendar, document

  // State
  read Boolean @default(false)

  // Action (what happens when notification is clicked)
  actionType String? @map("action_type") @db.VarChar(50) // open_email, open_task, open_case, open_document, open_inbox
  actionData Json?   @map("action_data") // { entityId: string, caseId?: string }

  // Source event (optional, for tracing)
  sourceEventId String? @map("source_event_id")

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read, createdAt])
  @@index([userId, createdAt])
  @@map("in_app_notifications")
}

// PushSubscription - web push notification subscriptions
model PushSubscription {
  id     String @id @default(uuid())
  userId String @map("user_id")

  // Push subscription details (from browser's PushSubscription)
  endpoint  String @db.Text // The push service URL
  p256dhKey String @map("p256dh_key") @db.VarChar(255) // Public key
  authKey   String @map("auth_key") @db.VarChar(255) // Auth secret

  // Metadata
  userAgent String? @map("user_agent") @db.VarChar(500) // Browser/device info
  active    Boolean @default(true)

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, active])
  @@map("push_subscriptions")
}

// DigestQueue - queued items for daily digest emails
model DigestQueue {
  id     String @id @default(uuid())
  userId String @map("user_id")

  // Event reference
  eventId    String  @map("event_id")
  eventType  String  @map("event_type") @db.VarChar(50)
  eventTitle String? @map("event_title") @db.VarChar(500)
  eventData  Json?   @map("event_data")

  // Scheduling
  scheduledFor DateTime @map("scheduled_for") @db.Timestamptz
  sent         Boolean  @default(false)

  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@index([userId, scheduledFor, sent])
  @@index([scheduledFor, sent])
  @@map("digest_queue")
}

// ============================================================================
// OPS-232: AI Batch Processing & Ops Dashboard
// ============================================================================

// AI Usage Log - detailed tracking of every AI API call for cost monitoring
// Different from AITokenUsage: uses EUR decimals, supports batch job linking
model AIUsageLog {
  id String @id @default(uuid())

  // What was called
  feature String @db.VarChar(100) // 'assistant_chat', 'search_index', 'morning_briefing', etc.
  model   String @db.VarChar(100) // 'claude-3-haiku-20240307', 'claude-sonnet-4-20250514', etc.

  // Token counts
  inputTokens  Int @map("input_tokens")
  outputTokens Int @map("output_tokens")

  // Cost calculation (EUR for Romanian firm - precise decimals)
  costEur Decimal @map("cost_eur") @db.Decimal(10, 6)

  // Context
  userId     String? @map("user_id") // null for batch jobs
  firmId     String  @map("firm_id")
  entityType String? @map("entity_type") @db.VarChar(50) // 'document', 'case', 'email', etc.
  entityId   String? @map("entity_id")

  // Timing
  durationMs Int      @map("duration_ms")
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz

  // For batch jobs (intentionally not a FK for flexibility - jobs may be deleted)
  batchJobId String? @map("batch_job_id")

  @@index([firmId, createdAt])
  @@index([feature, createdAt])
  @@index([batchJobId])
  @@map("ai_usage_logs")
}

// AI Batch Job Run - tracks batch processing job executions
model AIBatchJobRun {
  id     String @id @default(uuid())
  firmId String @map("firm_id")

  // Job identification
  feature String @db.VarChar(100) // 'search_index', 'morning_briefing', 'case_health', etc.

  // Status tracking
  status String @db.VarChar(20) // 'running', 'completed', 'failed', 'partial'

  // Timing
  startedAt   DateTime  @map("started_at") @db.Timestamptz
  completedAt DateTime? @map("completed_at") @db.Timestamptz

  // Metrics
  itemsProcessed Int     @default(0) @map("items_processed")
  itemsFailed    Int     @default(0) @map("items_failed")
  totalTokens    Int     @default(0) @map("total_tokens")
  totalCostEur   Decimal @default(0) @map("total_cost_eur") @db.Decimal(10, 6)

  // Error tracking
  errorMessage String? @map("error_message") @db.Text

  @@index([firmId, feature, startedAt])
  @@index([status])
  @@map("ai_batch_job_runs")
}

// AI Budget Settings - firm-wide budget controls and alert thresholds
// OPS-246: Budget Controls & Alerts Page
model AIBudgetSettings {
  id     String @id @default(uuid())
  firmId String @unique @map("firm_id")

  // Monthly budget limit in EUR
  monthlyBudgetEur Decimal @default(100) @map("monthly_budget_eur") @db.Decimal(10, 2)

  // Alert thresholds
  alertAt75Percent      Boolean @default(true) @map("alert_at_75_percent")
  alertAt90Percent      Boolean @default(true) @map("alert_at_90_percent")
  autoPauseAt100Percent Boolean @default(false) @map("auto_pause_at_100_percent")

  // Slack webhook for alerts (optional)
  slackWebhookUrl String? @map("slack_webhook_url") @db.VarChar(500)

  // Track which thresholds have been triggered this month
  alertsSentThisMonth String[] @default([]) @map("alerts_sent_this_month")
  lastAlertResetAt    DateTime @default(now()) @map("last_alert_reset_at") @db.Timestamptz

  // Audit
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz
  updatedBy String?  @map("updated_by")

  @@map("ai_budget_settings")
}

// Case Health Score - nightly-computed health metrics for cases
// OPS-239: Case Health Scoring Processor
model CaseHealthScore {
  id     String @id @default(uuid())
  caseId String @map("case_id")
  firmId String @map("firm_id")

  // Overall score 0-100
  score Int

  // Factor breakdown (each 0-100)
  activityScore Int @map("activity_score") // Days since last activity
  emailScore    Int @map("email_score") // Unanswered emails
  taskScore     Int @map("task_score") // Overdue tasks
  deadlineScore Int @map("deadline_score") // Upcoming deadlines

  // AI-generated insights (in Romanian)
  concerns    String[] // Top concerns
  suggestions String[] // Suggested actions
  riskLevel   String   @map("risk_level") @db.VarChar(20) // 'low', 'medium', 'high', 'critical'

  // Metadata
  calculatedAt DateTime @default(now()) @map("calculated_at") @db.Timestamptz

  // Relations
  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([firmId, calculatedAt])
  @@index([caseId])
  @@index([score])
  @@map("case_health_scores")
}

// ============================================================================
// Team Chat - firm-wide instant messaging
// ============================================================================

// TeamChatMessage - instant messages within a firm
model TeamChatMessage {
  id        String   @id @default(uuid())
  firmId    String   @map("firm_id")
  authorId  String   @map("author_id")
  content   String   @db.Text
  parentId  String?  @map("parent_id") // For threaded conversations
  mentions  String[] // User IDs mentioned in the message
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz
  expiresAt DateTime @map("expires_at") @db.Timestamptz

  // Relations
  firm    Firm              @relation(fields: [firmId], references: [id])
  author  User              @relation("SentChatMessages", fields: [authorId], references: [id])
  parent  TeamChatMessage?  @relation("MessageThread", fields: [parentId], references: [id])
  replies TeamChatMessage[] @relation("MessageThread")

  @@index([firmId, createdAt])
  @@index([authorId])
  @@index([parentId])
  @@index([expiresAt])
  @@map("team_chat_messages")
}

// ============================================================================
// Case Chapters - AI-generated archival history structure
// ============================================================================

// CasePhase - phases of a legal case for chapter organization
enum CasePhase {
  ConsultantaInitiala // Initial consultation
  Negociere // Negotiation
  DueDiligence // Due diligence review
  PrimaInstanta // First instance court
  Apel // Appeal
  Executare // Execution/enforcement
  Mediere // Mediation
  Arbitraj // Arbitration
  Inchis // Closed/completed
}

// CaseChapter - AI-generated chapter grouping case events by phase
model CaseChapter {
  id              String    @id @default(uuid())
  caseId          String    @map("case_id")
  firmId          String    @map("firm_id")
  phase           CasePhase
  title           String    @db.VarChar(200) // Romanian phase title
  summary         String    @db.Text // AI-generated chapter summary
  startDate       DateTime? @map("start_date") @db.Date
  endDate         DateTime? @map("end_date") @db.Date
  generatedAt     DateTime  @default(now()) @map("generated_at") @db.Timestamptz
  dataVersionHash String    @map("data_version_hash") @db.VarChar(64) // Hash for change detection
  isStale         Boolean   @default(false) @map("is_stale")
  sortOrder       Int       @default(0) @map("sort_order") // For ordering chapters chronologically
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  case   Case               @relation(fields: [caseId], references: [id], onDelete: Cascade)
  firm   Firm               @relation(fields: [firmId], references: [id], onDelete: Cascade)
  events CaseChapterEvent[]

  @@unique([caseId, phase])
  @@index([caseId])
  @@index([firmId])
  @@index([phase])
  @@index([isStale])
  @@map("case_chapters")
}

// CaseChapterEventType - types of events in the timeline
enum CaseChapterEventType {
  Document // Document uploaded/signed/filed
  Email // Email correspondence
  Task // Task completed
  CourtOutcome // Court decision/ruling
  ContractSigned // Contract execution
  Negotiation // Negotiation milestone
  Deadline // Deadline met or missed
  ClientDecision // Key client decision
  TeamChange // Team member added/removed
  StatusChange // Case status changed
  Milestone // General milestone
}

// CaseChapterEvent - individual timeline event within a chapter
model CaseChapterEvent {
  id         String               @id @default(uuid())
  chapterId  String               @map("chapter_id")
  eventType  CaseChapterEventType @map("event_type")
  title      String               @db.VarChar(300)
  summary    String               @db.Text // AI-generated event summary
  occurredAt DateTime             @map("occurred_at") @db.Timestamptz
  metadata   Json                 @default("{}") // Flexible metadata (document IDs, email IDs, etc.)
  sortOrder  Int                  @default(0) @map("sort_order")
  createdAt  DateTime             @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  chapter CaseChapter @relation(fields: [chapterId], references: [id], onDelete: Cascade)

  @@index([chapterId])
  @@index([eventType])
  @@index([occurredAt])
  @@map("case_chapter_events")
}
