/**
 * Quality Metrics Service Tests
 * Story 3.3: Intelligent Document Drafting
 */

import { qualityMetricsService } from './quality-metrics.service';
import { prisma } from '@legal-platform/database';
import { Prisma } from '@prisma/client';
import type { QualityMetricsInput, DocumentType } from '@legal-platform/types';

// Mock Prisma
jest.mock('@legal-platform/database', () => ({
  prisma: {
    documentDraftMetrics: {
      create: jest.fn(),
      findUnique: jest.fn(),
      findMany: jest.fn(),
      update: jest.fn(),
    },
  },
}));

describe('QualityMetricsService', () => {
  const mockInput: QualityMetricsInput & {
    firmId: string;
    userId: string;
    documentType: DocumentType;
  } = {
    documentId: '123e4567-e89b-12d3-a456-426614174000',
    initialContent: 'This is the initial content generated by AI. It has some legal text.',
    finalContent: 'This is the final content after user edits. It has some legal text with modifications.',
    startTime: new Date('2024-01-01T10:00:00Z'),
    endTime: new Date('2024-01-01T10:30:00Z'),
    userRating: 4,
    firmId: '123e4567-e89b-12d3-a456-426614174001',
    userId: '123e4567-e89b-12d3-a456-426614174002',
    documentType: 'Contract',
  };

  const mockDbRecord = {
    id: 'metrics-1',
    documentId: mockInput.documentId,
    firmId: mockInput.firmId,
    userId: mockInput.userId,
    documentType: mockInput.documentType,
    initialWordCount: 12,
    finalWordCount: 14,
    charactersAdded: 20,
    charactersRemoved: 0,
    editPercentage: new Prisma.Decimal(28.57),
    timeToFinalizeMinutes: 30,
    userRating: 4,
    generationTimeMs: 2500,
    tokensUsed: 600,
    modelUsed: 'claude-3-5-sonnet',
    templateId: null,
    precedentIds: [],
    createdAt: new Date(),
    updatedAt: new Date(),
    finalizedAt: new Date(),
  };

  beforeEach(() => {
    jest.clearAllMocks();

    // Setup mock implementations
    (prisma.documentDraftMetrics.create as jest.Mock).mockResolvedValue(mockDbRecord);
    (prisma.documentDraftMetrics.findUnique as jest.Mock).mockResolvedValue(mockDbRecord);
    (prisma.documentDraftMetrics.findMany as jest.Mock).mockResolvedValue([mockDbRecord]);
    (prisma.documentDraftMetrics.update as jest.Mock).mockResolvedValue(mockDbRecord);
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe('recordDraftMetrics', () => {
    it('should record metrics successfully', async () => {
      const result = await qualityMetricsService.recordDraftMetrics(mockInput);

      expect(result).toBeDefined();
      expect(result.documentId).toBe(mockInput.documentId);
    });

    it('should create a database record', async () => {
      await qualityMetricsService.recordDraftMetrics(mockInput);

      expect(prisma.documentDraftMetrics.create).toHaveBeenCalledWith(
        expect.objectContaining({
          data: expect.objectContaining({
            documentId: mockInput.documentId,
            firmId: mockInput.firmId,
            userId: mockInput.userId,
            documentType: mockInput.documentType,
          }),
        })
      );
    });

    it('should calculate word counts correctly', async () => {
      await qualityMetricsService.recordDraftMetrics(mockInput);

      const createCall = (prisma.documentDraftMetrics.create as jest.Mock).mock.calls[0][0];
      expect(createCall.data.initialWordCount).toBeGreaterThan(0);
    });

    it('should calculate edit percentage', async () => {
      await qualityMetricsService.recordDraftMetrics(mockInput);

      const createCall = (prisma.documentDraftMetrics.create as jest.Mock).mock.calls[0][0];
      expect(createCall.data.editPercentage).toBeDefined();
    });

    it('should calculate time to finalize', async () => {
      await qualityMetricsService.recordDraftMetrics(mockInput);

      const createCall = (prisma.documentDraftMetrics.create as jest.Mock).mock.calls[0][0];
      expect(createCall.data.timeToFinalizeMinutes).toBe(30);
    });

    it('should store user rating', async () => {
      await qualityMetricsService.recordDraftMetrics(mockInput);

      const createCall = (prisma.documentDraftMetrics.create as jest.Mock).mock.calls[0][0];
      expect(createCall.data.userRating).toBe(4);
    });
  });

  describe('getMetricsSummary', () => {
    const firmId = mockInput.firmId;
    const startDate = new Date('2024-01-01');
    const endDate = new Date('2024-01-31');

    it('should return metrics summary', async () => {
      (prisma.documentDraftMetrics.findMany as jest.Mock).mockResolvedValue([
        mockDbRecord,
        { ...mockDbRecord, id: 'metrics-2', editPercentage: new Prisma.Decimal(20) },
      ]);

      const result = await qualityMetricsService.getMetricsSummary(
        firmId,
        startDate,
        endDate
      );

      expect(result).toBeDefined();
      expect(result.totalDocuments).toBe(2);
      expect(result.averageEditPercentage).toBeDefined();
    });

    it('should return empty summary for no data', async () => {
      (prisma.documentDraftMetrics.findMany as jest.Mock).mockResolvedValue([]);

      const result = await qualityMetricsService.getMetricsSummary(
        firmId,
        startDate,
        endDate
      );

      expect(result.totalDocuments).toBe(0);
      expect(result.averageEditPercentage).toBe(0);
    });

    it('should filter by document type', async () => {
      await qualityMetricsService.getMetricsSummary(
        firmId,
        startDate,
        endDate,
        'Contract'
      );

      expect(prisma.documentDraftMetrics.findMany).toHaveBeenCalledWith(
        expect.objectContaining({
          where: expect.objectContaining({
            documentType: 'Contract',
          }),
        })
      );
    });

    it('should group by document type', async () => {
      (prisma.documentDraftMetrics.findMany as jest.Mock).mockResolvedValue([
        { ...mockDbRecord, documentType: 'Contract', editPercentage: new Prisma.Decimal(20) },
        { ...mockDbRecord, documentType: 'Motion', editPercentage: new Prisma.Decimal(25) },
      ]);

      const result = await qualityMetricsService.getMetricsSummary(
        firmId,
        startDate,
        endDate
      );

      expect(result.byDocumentType.length).toBe(2);
    });

    it('should calculate average user rating', async () => {
      (prisma.documentDraftMetrics.findMany as jest.Mock).mockResolvedValue([
        { ...mockDbRecord, userRating: 5 },
        { ...mockDbRecord, id: 'metrics-2', userRating: 4 },
      ]);

      const result = await qualityMetricsService.getMetricsSummary(
        firmId,
        startDate,
        endDate
      );

      expect(result.averageUserRating).toBe(4.5);
    });
  });

  describe('getDocumentMetrics', () => {
    it('should return metrics for a document', async () => {
      const result = await qualityMetricsService.getDocumentMetrics(mockInput.documentId);

      expect(result).toBeDefined();
      expect(result?.documentId).toBe(mockInput.documentId);
    });

    it('should return null for non-existent document', async () => {
      (prisma.documentDraftMetrics.findUnique as jest.Mock).mockResolvedValue(null);

      const result = await qualityMetricsService.getDocumentMetrics('non-existent');

      expect(result).toBeNull();
    });
  });

  describe('addUserRating', () => {
    it('should add user rating', async () => {
      (prisma.documentDraftMetrics.update as jest.Mock).mockResolvedValue({
        ...mockDbRecord,
        userRating: 5,
      });

      const result = await qualityMetricsService.addUserRating(mockInput.documentId, 5);

      expect(prisma.documentDraftMetrics.update).toHaveBeenCalledWith(
        expect.objectContaining({
          where: { documentId: mockInput.documentId },
          data: { userRating: 5 },
        })
      );
    });
  });

  describe('getDocumentsExceedingThreshold', () => {
    it('should return documents exceeding threshold', async () => {
      (prisma.documentDraftMetrics.findMany as jest.Mock).mockResolvedValue([
        { ...mockDbRecord, editPercentage: new Prisma.Decimal(35) },
      ]);

      const result = await qualityMetricsService.getDocumentsExceedingThreshold(
        mockInput.firmId,
        new Date('2024-01-01'),
        new Date('2024-01-31')
      );

      expect(prisma.documentDraftMetrics.findMany).toHaveBeenCalledWith(
        expect.objectContaining({
          where: expect.objectContaining({
            editPercentage: { gt: 30 },
          }),
        })
      );
    });
  });

  describe('getTrendingMetrics', () => {
    it('should return trending metrics', async () => {
      (prisma.documentDraftMetrics.findMany as jest.Mock).mockResolvedValue([
        { ...mockDbRecord, createdAt: new Date('2024-01-15') },
        { ...mockDbRecord, id: 'metrics-2', createdAt: new Date('2024-01-16') },
      ]);

      const result = await qualityMetricsService.getTrendingMetrics(
        mockInput.firmId,
        30
      );

      expect(result).toBeInstanceOf(Array);
    });

    it('should group by date', async () => {
      const date = new Date('2024-01-15');
      (prisma.documentDraftMetrics.findMany as jest.Mock).mockResolvedValue([
        { ...mockDbRecord, createdAt: date },
        { ...mockDbRecord, id: 'metrics-2', createdAt: date },
      ]);

      const result = await qualityMetricsService.getTrendingMetrics(
        mockInput.firmId,
        30
      );

      // Should have one entry for the date
      const dateEntry = result.find((r) => r.date === '2024-01-15');
      expect(dateEntry?.documentCount).toBe(2);
    });
  });
});

describe('Edit percentage calculation', () => {
  it('should calculate 0% for identical content', () => {
    const content = 'Same content';
    // Mock the calculation - this tests the concept
    const editPercentage = ((0 + 0) / content.length) * 100;
    expect(editPercentage).toBe(0);
  });

  it('should calculate percentage for added content', () => {
    const initial = 'Initial';
    const final = 'Initial with more text';
    const added = final.length - initial.length;
    const editPercentage = (added / initial.length) * 100;
    expect(editPercentage).toBeGreaterThan(0);
  });

  it('should calculate percentage for removed content', () => {
    const initial = 'Initial with more text';
    const final = 'Initial';
    const removed = initial.length - final.length;
    const editPercentage = (removed / initial.length) * 100;
    expect(editPercentage).toBeGreaterThan(0);
  });
});
