# Story 2.1: CI/CD Pipeline and Infrastructure as Code

## Status

Draft

## Story

**As a** platform operator,
**I want** automated deployment pipeline AND infrastructure as code,
**so that** deployments are consistent and repeatable.

## Acceptance Criteria

1. Monorepo structure created with apps/ and packages/ folders per architecture
2. TypeScript, ESLint, Prettier configured with shared rules across all packages
3. GitHub Actions workflow runs tests and builds on every PR
4. Azure DevOps pipeline deploys to staging environment on merge to main
5. Docker containers created for all services with docker-compose for local development
6. Environment variables managed via .env files with .env.example templates
7. Terraform/Bicep templates for all Azure resources (AKS, PostgreSQL, Redis, Blob Storage)
8. Automated infrastructure deployment pipeline
9. Infrastructure documentation with architecture diagrams
10. Cost estimation for infrastructure resources

## Tasks / Subtasks

### Phase 1: Monorepo and Development Setup (AC: 1, 2, 6)

- [ ] **Task 1: Verify and Complete Monorepo Structure** (AC: 1)
  - [x] Verify existing `/apps`, `/packages`, `/services` directories match architecture
  - [x] Create missing `/infrastructure` subdirectories: `/terraform`, `/kubernetes`, `/docker`
  - [x] Create `/scripts` directory for build and deployment scripts
  - [x] Verify `turbo.json` configuration aligns with build pipeline needs
  - [x] Document monorepo structure in `infrastructure/README.md`

- [ ] **Task 2: Configure Shared TypeScript, ESLint, Prettier** (AC: 2)
  - [x] Create `packages/config/tsconfig.base.json` with shared TypeScript rules
  - [x] Create `packages/config/eslint-config-custom` package with shared ESLint rules
  - [x] Create `packages/config/prettier-config-custom` package with Prettier rules
  - [x] Update all workspace packages to extend shared configs
  - [x] Add `lint` and `format` scripts to root `package.json` that run across all packages
  - [x] Test linting and formatting across all workspaces

- [ ] **Task 3: Environment Variable Management** (AC: 6)
  - [x] Create `.env.example` files for each service and app with documented variables
  - [x] Document required environment variables in `infrastructure/ENVIRONMENT_VARIABLES.md`
  - [x] Create environment validation script that checks for required variables
  - [x] Add `.env` to `.gitignore` (verify it's there)
  - [x] Document environment variable loading strategy (dotenv, Azure Key Vault for production)

### Phase 2: Docker Containerization (AC: 5)

- [ ] **Task 4: Create Production Dockerfiles** (AC: 5)
  - [x] Create `infrastructure/docker/Dockerfile.web` for Next.js frontend app
  - [x] Create `infrastructure/docker/Dockerfile.gateway` for GraphQL API Gateway service
  - [x] Create `infrastructure/docker/Dockerfile.service` (multi-stage template for microservices)
  - [x] Optimize Dockerfiles with multi-stage builds for smaller images
  - [x] Add health check endpoints to each service
  - [x] Document Docker build process in `infrastructure/docker/README.md`

- [ ] **Task 5: Complete docker-compose Configuration** (AC: 5)
  - [x] Update existing `docker-compose.yml` for full local development stack
  - [x] Add services: web app, gateway, PostgreSQL with pgvector, Redis, document-service
  - [x] Configure service networking and port mappings
  - [x] Add volume mounts for development hot-reload
  - [x] Create `docker-compose.prod.yml` for production-like testing
  - [x] Add `docker-compose.test.yml` for CI testing environment
  - [x] Test full stack startup with `docker-compose up`

### Phase 3: GitHub Actions CI Pipeline (AC: 3)

- [ ] **Task 6: Create PR Validation Workflow** (AC: 3)
  - [x] Create `.github/workflows/pr-validation.yml`
  - [x] Add job: Install dependencies with pnpm caching
  - [x] Add job: Run TypeScript type checking across all workspaces
  - [x] Add job: Run ESLint across all workspaces
  - [x] Add job: Run Prettier check
  - [x] Add job: Run Jest unit tests with coverage reporting
  - [x] Add job: Build all apps and services
  - [x] Add job: Run Playwright E2E tests in docker-compose environment
  - [x] Configure workflow to run on PRs targeting `main` branch
  - [x] Add status badge to root README.md

- [ ] **Task 7: Create Build and Publish Workflow** (AC: 3)
  - [x] Create `.github/workflows/build-publish.yml`
  - [x] Add job: Build Docker images for all services
  - [x] Add job: Tag images with commit SHA and `latest` tag
  - [x] Add job: Push images to Azure Container Registry (ACR)
  - [x] Configure workflow to run on merge to `main` branch
  - [x] Set up Azure Container Registry credentials as GitHub secrets
  - [x] Test workflow by triggering on test branch

### Phase 4: Terraform Infrastructure as Code (AC: 7, 8, 10)

- [ ] **Task 8: Create Terraform Project Structure** (AC: 7)
  - [ ] Create `infrastructure/terraform/main.tf` with Azure provider configuration
  - [ ] Create `infrastructure/terraform/variables.tf` for environment-specific variables
  - [ ] Create `infrastructure/terraform/outputs.tf` for resource outputs
  - [ ] Create `infrastructure/terraform/backend.tf` for remote state storage in Azure Blob
  - [ ] Create `infrastructure/terraform/environments/staging/terraform.tfvars`
  - [ ] Create `infrastructure/terraform/environments/production/terraform.tfvars`
  - [ ] Configure Terraform version constraints (>= 1.7)

- [ ] **Task 9: Define Azure Resources in Terraform** (AC: 7)
  - [ ] Create `infrastructure/terraform/modules/aks/` for AKS cluster configuration
    - AKS cluster in West Europe region with node pool configuration
    - System node pool (2 nodes, Standard_D2s_v3)
    - User node pool (3 nodes, Standard_D4s_v3, autoscaling 3-10)
  - [ ] Create `infrastructure/terraform/modules/database/` for PostgreSQL
    - Azure Database for PostgreSQL Flexible Server (version 16)
    - Enable pgvector extension
    - Configure backup retention and high availability
  - [ ] Create `infrastructure/terraform/modules/cache/` for Redis
    - Azure Cache for Redis (Standard C1)
    - Configure persistence and firewall rules
  - [ ] Create `infrastructure/terraform/modules/storage/` for Blob Storage
    - Storage account with containers for documents
    - Configure geo-redundancy (GRS) and lifecycle policies
  - [ ] Create `infrastructure/terraform/modules/monitoring/` for Application Insights
    - Application Insights resource
    - Log Analytics workspace
    - Configure retention and sampling
  - [ ] Create `infrastructure/terraform/modules/networking/` for VNet and subnet configuration
  - [ ] Create `infrastructure/terraform/modules/security/` for Azure Key Vault
    - Key Vault for secrets management
    - Configure access policies for services

- [ ] **Task 10: Cost Estimation and Documentation** (AC: 10)
  - [ ] Run `terraform plan` and use Azure Pricing Calculator for cost estimation
  - [ ] Document estimated monthly costs in `infrastructure/COST_ESTIMATION.md`
  - [ ] Break down costs by service: AKS, PostgreSQL, Redis, Storage, monitoring
  - [ ] Document cost optimization recommendations
  - [ ] Create cost alerts in Terraform for budget monitoring

### Phase 5: Azure DevOps Deployment Pipeline (AC: 4, 8)

- [ ] **Task 11: Set Up Azure DevOps Project** (AC: 4, 8)
  - [ ] Create Azure DevOps organization and project (if not exists)
  - [ ] Configure service connection to Azure subscription
  - [ ] Configure service connection to GitHub repository
  - [ ] Set up variable groups for staging and production environments
  - [ ] Configure Azure Container Registry as artifact source

- [ ] **Task 12: Create Infrastructure Deployment Pipeline** (AC: 8)
  - [ ] Create `azure-pipelines-infrastructure.yml` in root
  - [ ] Add stage: Terraform validate and plan
  - [ ] Add stage: Manual approval gate for infrastructure changes
  - [ ] Add stage: Terraform apply to create/update infrastructure
  - [ ] Add stage: Verify infrastructure health (connectivity tests)
  - [ ] Configure pipeline to run on changes to `/infrastructure` directory
  - [ ] Test pipeline in staging environment

- [ ] **Task 13: Create Application Deployment Pipeline** (AC: 4)
  - [ ] Create `azure-pipelines-deploy.yml` in root
  - [ ] Add stage: Pull Docker images from ACR
  - [ ] Add stage: Update Kubernetes manifests with new image tags
  - [ ] Add stage: Deploy to staging AKS cluster using kubectl/Helm
  - [ ] Add stage: Run smoke tests against staging environment
  - [ ] Add stage: Manual approval gate for production deployment
  - [ ] Add stage: Deploy to production AKS cluster (blue-green deployment)
  - [ ] Add stage: Run health checks and rollback on failure
  - [ ] Configure pipeline to trigger on merge to `main` branch

### Phase 6: Kubernetes Configuration (AC: 7)

- [ ] **Task 14: Create Kubernetes Manifests** (AC: 7)
  - [ ] Create `infrastructure/kubernetes/namespaces/` with staging and production namespaces
  - [ ] Create `infrastructure/kubernetes/deployments/` for each service (web, gateway, services)
  - [ ] Create `infrastructure/kubernetes/services/` for service discovery and load balancing
  - [ ] Create `infrastructure/kubernetes/configmaps/` for non-sensitive configuration
  - [ ] Create `infrastructure/kubernetes/secrets/` templates for sensitive data (reference Key Vault)
  - [ ] Create `infrastructure/kubernetes/ingress/` for external access with SSL/TLS
  - [ ] Create `infrastructure/kubernetes/hpa/` for horizontal pod autoscaling
  - [ ] Configure resource limits and requests for each deployment

### Phase 7: Documentation and Rollback Plan (AC: 9)

- [ ] **Task 15: Create Infrastructure Documentation** (AC: 9)
  - [ ] Create `infrastructure/README.md` with overview and setup instructions
  - [ ] Create `infrastructure/DEPLOYMENT_GUIDE.md` with step-by-step deployment process
  - [ ] Create `infrastructure/ROLLBACK_GUIDE.md` with rollback procedures
  - [ ] Create architecture diagram showing all Azure resources and connections
  - [ ] Document CI/CD pipeline flow with diagram
  - [ ] Document local development setup with Docker Compose
  - [ ] Create runbook for common infrastructure operations (scaling, backups, recovery)

### Phase 8: Testing and Validation (AC: All)

- [ ] **Task 16: Integration Testing**
  - [ ] Test full CI pipeline by creating a test PR
  - [ ] Verify all PR checks pass (lint, test, build, E2E)
  - [ ] Test Docker Compose local development environment startup
  - [ ] Verify environment variable validation works
  - [ ] Test Terraform plan/apply in staging environment
  - [ ] Test Azure DevOps infrastructure deployment pipeline
  - [ ] Test Azure DevOps application deployment pipeline to staging
  - [ ] Verify deployed application is accessible and functional
  - [ ] Test rollback procedure using Terraform state
  - [ ] Verify cost estimation accuracy against actual Azure costs

## Dev Notes

### Context: Epic 2 Foundation

This is the first story in Epic 2, which establishes the production infrastructure for the legal platform. Story 2.1 sets up the complete CI/CD pipeline and Infrastructure as Code foundation that all subsequent Epic 2 stories will build upon. The project currently has a basic monorepo structure with development setup, but needs production-grade infrastructure and automated deployment pipelines.

### Current Project State

**Existing Infrastructure:**
- ✅ Monorepo structure established with Turborepo (`package.json` workspaces: apps/*, packages/*, services/*)
- ✅ Development Docker setup (`infrastructure/docker/Dockerfile.dev`, `docker-compose.yml`)
- ✅ Basic GitHub Actions workflow (`.github/workflows/test.yml`)
- ✅ Build scripts configured: `build`, `dev`, `lint`, `test`, `test:e2e`
- ✅ Testing tools: Jest for unit tests, Playwright for E2E tests

**What Needs to Be Created:**
- ❌ Production Dockerfiles for all services
- ❌ Comprehensive docker-compose for local development matching production architecture
- ❌ GitHub Actions PR validation workflow with full test suite
- ❌ Terraform modules for all Azure resources
- ❌ Azure DevOps deployment pipelines
- ❌ Kubernetes manifests for AKS deployment
- ❌ Infrastructure documentation and architecture diagrams

### Architecture References

**Technology Stack:**
[Source: architecture/tech-stack.md#technology-stack-table]

- **IaC Tool:** Terraform 1.7+ for Infrastructure as Code
- **CI/CD:** GitHub Actions (testing/builds) + Azure DevOps (deployment)
- **Build Tool:** Vite 5.0+ for frontend bundling
- **Monorepo Tool:** Turborepo for parallel task execution and caching
- **Container Orchestration:** Azure Kubernetes Service (AKS)
- **Testing:** Jest 29+ (unit/integration), Playwright 1.41+ (E2E), Supertest 6.3+ (API)

**Platform and Infrastructure:**
[Source: architecture/high-level-architecture.md#platform-and-infrastructure-choice]

- **Cloud Platform:** Microsoft Azure
- **Deployment Region:** Primary: West Europe (Amsterdam), Secondary: North Europe (Stockholm) for DR
- **Key Azure Services:**
  - Azure Kubernetes Service (AKS) for container orchestration
  - Azure Database for PostgreSQL 16 with pgvector extension
  - Azure Cache for Redis 7.2+
  - Azure Blob Storage for document storage
  - Azure AD for authentication
  - Application Insights for monitoring and logging

**Repository Structure:**
[Source: architecture/high-level-architecture.md#repository-structure]

```
legal-platform/
├── .github/                    # CI/CD workflows (GitHub Actions)
├── apps/                       # Deployable applications (web, admin)
├── services/                   # Backend microservices (gateway, document, task, ai, integration, notification)
├── packages/                   # Shared packages (types, ui, database, config, logger)
├── infrastructure/             # Infrastructure as Code
│   ├── terraform/              # Terraform modules for Azure resources
│   ├── kubernetes/             # Kubernetes manifests for AKS
│   └── docker/                 # Dockerfiles for services
├── scripts/                    # Build & deployment scripts
├── docs/                       # Documentation
└── turbo.json                  # Turborepo configuration
```

**Architectural Patterns:**
[Source: architecture/high-level-architecture.md#architectural-patterns]

- **Microservices within Monorepo:** Domain-driven service separation with shared codebase
- **Jamstack Architecture:** Static site generation with serverless APIs
- **Backend for Frontend (BFF):** GraphQL layer tailored for frontend needs

**Critical Coding Standards:**
[Source: architecture/coding-standards.md#critical-fullstack-rules]

- **Type Sharing:** Always define types in `packages/shared/types`
- **Environment Variables:** Access only through config objects, never directly
- **Database Access:** Only through repository pattern

### Azure Resources to Provision

**Compute:**
- AKS cluster with system node pool (2 nodes, Standard_D2s_v3) and user node pool (3-10 nodes autoscaling, Standard_D4s_v3)

**Data Layer:**
- PostgreSQL Flexible Server version 16 with pgvector 0.5+ extension enabled
- Azure Cache for Redis Standard C1 tier with persistence
- Azure Blob Storage with GRS redundancy for document storage

**Networking:**
- Virtual Network with subnets for AKS, PostgreSQL, Redis
- Application Gateway or Load Balancer for ingress
- Private endpoints for secure service communication

**Security:**
- Azure Key Vault for secrets management
- Azure AD app registration for service authentication
- SSL/TLS certificates with automatic renewal

**Monitoring:**
- Application Insights for APM and logging
- Log Analytics workspace for centralized logging

### CI/CD Pipeline Flow

**GitHub Actions (on PR):**
1. Install dependencies (pnpm with caching)
2. Type checking (TypeScript)
3. Linting (ESLint)
4. Formatting check (Prettier)
5. Unit tests (Jest with coverage)
6. Build all apps and services
7. E2E tests (Playwright in docker-compose)

**GitHub Actions (on merge to main):**
1. Build Docker images for all services
2. Tag images with commit SHA and `latest`
3. Push to Azure Container Registry

**Azure DevOps (on merge to main):**
1. Pull images from ACR
2. Update Kubernetes manifests
3. Deploy to staging AKS
4. Run smoke tests
5. [Manual approval gate]
6. Deploy to production AKS (blue-green)
7. Health checks and auto-rollback on failure

### Environment Variables Strategy

**Local Development:** `.env` files loaded via dotenv
**Staging/Production:** Azure Key Vault with managed identities

**Required Variables (create `.env.example` templates):**
- `DATABASE_URL` - PostgreSQL connection string
- `REDIS_URL` - Redis connection string
- `AZURE_STORAGE_CONNECTION_STRING` - Blob storage
- `AZURE_AD_CLIENT_ID` - OAuth client ID
- `AZURE_AD_CLIENT_SECRET` - OAuth secret (Key Vault only)
- `APPLICATION_INSIGHTS_KEY` - Monitoring key
- `NEXT_PUBLIC_API_URL` - GraphQL endpoint (frontend)

### Docker Strategy

**Development:** Use existing `Dockerfile.dev` with hot-reload
**Production:** Multi-stage builds for optimized images
- Stage 1: Dependencies installation
- Stage 2: Build assets
- Stage 3: Production runtime with minimal footprint

**Health Checks:** Each service must expose `/health` endpoint for Kubernetes liveness/readiness probes

### Terraform State Management

**Backend Configuration:**
- Store Terraform state in Azure Blob Storage for team collaboration
- Enable state locking to prevent concurrent modifications
- Use separate state files for staging and production environments

**Rollback Plan:**
[Source: Epic 2, Story 2.1 Rollback Plan]
Terraform state allows rollback to previous infrastructure version using `terraform apply` with previous state version.

### Cost Estimation Guidelines

**Expected Monthly Costs (Staging Environment):**
- AKS cluster: ~$150 (2 system nodes + 3 user nodes)
- PostgreSQL Flexible Server: ~$100 (4 vCores, 32 GB RAM)
- Redis Standard C1: ~$70
- Blob Storage: ~$20 (1 TB with GRS)
- Application Insights: ~$50 (5 GB/day)
- **Total Staging: ~$390/month**

**Production costs expected to be 2-3x staging due to scaling and redundancy.**

### Testing

[Source: architecture/testing-strategy.md]

**Testing Pyramid:**
- E2E Tests (10%) - Playwright for CI/CD pipeline validation
- Integration Tests (20%) - Docker Compose stack startup, Terraform plan/apply
- Unit Tests (70%) - N/A for infrastructure story (focus on validation scripts)

**Test Organization:**
- Create integration tests for infrastructure validation
- Test CI/CD pipeline with test PRs
- Validate Terraform configuration with `terraform validate` and `terraform plan`
- Test deployment pipeline in staging before enabling production

**Pipeline Testing:**
1. Create test PR with minor change
2. Verify all GitHub Actions jobs pass
3. Merge to trigger build and ACR push
4. Verify Azure DevOps deployment to staging
5. Validate deployed application functionality
6. Test rollback procedure

### Project Structure Notes

All file paths and component locations align with the architecture structure defined in `docs/architecture/unified-project-structure.md`. New files created in this story follow the established patterns:
- Infrastructure code: `/infrastructure/terraform/`, `/infrastructure/kubernetes/`, `/infrastructure/docker/`
- CI/CD workflows: `/.github/workflows/`, `/azure-pipelines-*.yml`
- Shared configs: `/packages/config/`
- Documentation: `/infrastructure/*.md`

No structural conflicts identified between epic requirements and architecture specifications.

### Key Success Metrics

- [ ] PR validation workflow completes in <10 minutes
- [ ] Docker Compose local stack starts in <2 minutes
- [ ] Terraform apply completes staging environment in <15 minutes
- [ ] Deployment pipeline completes staging deployment in <10 minutes
- [ ] All infrastructure costs within estimated budget (±10%)
- [ ] Zero manual steps required for deployment after initial setup

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-15 | 1.0 | Initial story creation | Bob (Scrum Master) |
