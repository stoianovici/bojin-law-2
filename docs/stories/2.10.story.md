# Story 2.10: Basic AI Search Implementation

## Status

Dev Complete

## Story

**As a** user,
**I want** AI-powered search across all cases and documents,
**so that** I can quickly find relevant information.

## Acceptance Criteria

1. Search index created for cases and document metadata using PostgreSQL full-text search
2. Claude AI embeddings generated for all text content (with Grok as fallback)
3. Semantic search finds related content even with different wording
4. Search results ranked by relevance with highlighting
5. Search supports filters: date range, case, document type
6. Recent searches cached for performance improvement

## Tasks / Subtasks

### Phase 1: Database Schema and Search Infrastructure (AC: 1)

- [ ] **Task 1: Add Vector Embedding Fields to Prisma Schema** (AC: 1, 2)
  - [ ] Add `contentEmbedding` field to Case model: `contentEmbedding Unsupported("vector(1536)")? @map("content_embedding")`
  - [ ] Add `metadataEmbedding` field to Document model: `metadataEmbedding Unsupported("vector(1536)")? @map("metadata_embedding")`
  - [ ] Add `searchText` field to Case model for full-text search: `searchText String? @map("search_text") @db.Text`
  - [ ] Create migration: `npx prisma migrate dev --name add_search_embeddings`
  - [ ] Location: `packages/database/prisma/schema.prisma`

- [ ] **Task 2: Create Full-Text Search Indexes** (AC: 1)
  - [ ] Create GIN index on cases table for full-text search: `@@index([searchText], type: Gin)`
  - [ ] Create GIN index on documents table for fileName full-text search
  - [ ] Create HNSW index on content_embedding for vector similarity search
  - [ ] Create HNSW index on metadata_embedding for document similarity
  - [ ] Use raw SQL migration for index creation (Prisma doesn't natively support pgvector indexes)
  - [ ] Location: `packages/database/prisma/migrations/`

- [ ] **Task 3: Create Search History Model** (AC: 6)
  - [ ] Add SearchHistory model to Prisma schema with fields:
    - id (UUID)
    - userId (UUID FK to User)
    - firmId (UUID FK to Firm)
    - query (String)
    - searchType (enum: FullText, Semantic, Hybrid)
    - filters (Json - date range, case type, document type)
    - resultCount (Int)
    - createdAt (DateTime)
  - [ ] Add index on userId and createdAt for efficient retrieval
  - [ ] Location: `packages/database/prisma/schema.prisma`

### Phase 2: Embedding Service (AC: 2, 3)

- [ ] **Task 4: Create Voyage AI Embedding Service** (AC: 2)
  - [ ] Create `services/gateway/src/services/embedding.service.ts`
  - [ ] Implement `generateEmbedding(text: string): Promise<number[]>` method
  - [ ] Use Voyage AI API with model: `voyage-large-2` (best for legal documents)
  - [ ] Implement chunking for long text (max 8000 tokens per chunk)
  - [ ] Average multiple chunk embeddings for long documents
  - [ ] Handle rate limits: 300 requests/min with retry logic
  - [ ] Cache embeddings in Redis: `embedding:{hash(text)}` with 24h TTL
  - [ ] Location: `services/gateway/src/services/embedding.service.ts`

- [ ] **Task 5: Create Embedding Queue for Batch Processing** (AC: 2)
  - [ ] Implement `queueForEmbedding(entity: Case | Document): Promise<void>`
  - [ ] Use Redis list for queue: `embedding:queue`
  - [ ] Create background worker to process queue every 5 seconds
  - [ ] Batch process up to 50 items per batch for efficiency
  - [ ] Handle failures: retry 3 times, then log to error queue
  - [ ] Location: `services/gateway/src/services/embedding.service.ts`

- [ ] **Task 6: Implement Case Embedding Generation** (AC: 2)
  - [ ] Extract searchable text from Case: title, description, caseNumber, client.name
  - [ ] Generate embedding using EmbeddingService
  - [ ] Store embedding in Case.contentEmbedding field
  - [ ] Update Case.searchText with concatenated searchable text (for full-text)
  - [ ] Trigger embedding generation on Case create/update
  - [ ] Location: `services/gateway/src/services/embedding.service.ts`

- [ ] **Task 7: Implement Document Embedding Generation** (AC: 2)
  - [ ] Extract searchable text from Document: fileName, metadata.description, metadata.tags
  - [ ] Generate embedding using EmbeddingService
  - [ ] Store embedding in Document.metadataEmbedding field
  - [ ] Trigger embedding generation on Document upload
  - [ ] Location: `services/gateway/src/services/embedding.service.ts`

### Phase 3: Search Service Layer (AC: 1, 3, 4, 5)

- [ ] **Task 8: Create Search Service** (AC: 1, 3)
  - [ ] Create `services/gateway/src/services/search.service.ts`
  - [ ] Implement three search modes:
    - `fullTextSearch(query: string, filters: SearchFilters)`: PostgreSQL tsvector search
    - `semanticSearch(query: string, filters: SearchFilters)`: Vector similarity with pgvector
    - `hybridSearch(query: string, filters: SearchFilters)`: Combine both with weighted ranking
  - [ ] Apply firm isolation: all searches scoped to user's firmId
  - [ ] Location: `services/gateway/src/services/search.service.ts`

- [ ] **Task 9: Implement Full-Text Search** (AC: 1, 4)
  - [ ] Use PostgreSQL `to_tsvector` and `to_tsquery` for full-text search
  - [ ] Search across Case: title, caseNumber, description, searchText
  - [ ] Search across Document: fileName, metadata->>description
  - [ ] Implement `ts_rank` for relevance scoring
  - [ ] Return results with `ts_headline` for highlighting matched terms
  - [ ] Support Romanian language stemming: `setweight(to_tsvector('romanian', title), 'A')`
  - [ ] Location: `services/gateway/src/services/search.service.ts`

- [ ] **Task 10: Implement Semantic Search with pgvector** (AC: 3)
  - [ ] Generate query embedding using EmbeddingService
  - [ ] Use pgvector cosine similarity: `<=>` operator
  - [ ] Query: `SELECT *, 1 - (content_embedding <=> $1) as similarity FROM cases WHERE firm_id = $2 ORDER BY similarity DESC LIMIT $3`
  - [ ] Set minimum similarity threshold: 0.7 (configurable)
  - [ ] Return results with similarity scores (0-1)
  - [ ] Location: `services/gateway/src/services/search.service.ts`

- [ ] **Task 11: Implement Hybrid Search with Ranking** (AC: 1, 3, 4)
  - [ ] Combine full-text and semantic search results
  - [ ] Use Reciprocal Rank Fusion (RRF) algorithm for combining scores:
    ```typescript
    rrfScore = sum(1 / (k + rank_i)); // k=60 is standard
    ```
  - [ ] Normalize scores to 0-1 range for display
  - [ ] De-duplicate results from both searches
  - [ ] Default to hybrid search for best results
  - [ ] Location: `services/gateway/src/services/search.service.ts`

- [ ] **Task 12: Implement Search Filters** (AC: 5)
  - [ ] Define SearchFilters interface:
    ```typescript
    interface SearchFilters {
      dateRange?: { start: Date; end: Date };
      caseIds?: string[];
      caseTypes?: CaseType[];
      caseStatuses?: CaseStatus[];
      documentTypes?: string[]; // MIME types
      clientIds?: string[];
    }
    ```
  - [ ] Apply filters as WHERE clauses to both full-text and semantic queries
  - [ ] Date range filter: `WHERE opened_date BETWEEN $start AND $end`
  - [ ] Case type filter: `WHERE type = ANY($types::case_type[])`
  - [ ] Document type filter: `WHERE file_type = ANY($types)`
  - [ ] Location: `services/gateway/src/services/search.service.ts`

### Phase 4: GraphQL Schema and Resolvers (AC: 1-6)

- [ ] **Task 13: Define Search GraphQL Types** (AC: 4, 5)
  - [ ] Create `services/gateway/src/graphql/schema/search.graphql`
  - [ ] Define SearchResult union type:

    ```graphql
    union SearchResult = CaseSearchResult | DocumentSearchResult

    type CaseSearchResult {
      case: Case!
      score: Float!
      highlight: String
      matchType: SearchMatchType!
    }

    type DocumentSearchResult {
      document: Document!
      score: Float!
      highlight: String
      matchType: SearchMatchType!
    }

    enum SearchMatchType {
      FULL_TEXT
      SEMANTIC
      HYBRID
    }
    ```

  - [ ] Location: `services/gateway/src/graphql/schema/search.graphql`

- [ ] **Task 14: Define Search Input Types and Query** (AC: 5)
  - [ ] Define input types:

    ```graphql
    input SearchInput {
      query: String!
      searchMode: SearchMode = HYBRID
      filters: SearchFiltersInput
      limit: Int = 20
      offset: Int = 0
    }

    enum SearchMode {
      FULL_TEXT
      SEMANTIC
      HYBRID
    }

    input SearchFiltersInput {
      dateRange: DateRangeInput
      caseIds: [UUID!]
      caseTypes: [CaseType!]
      caseStatuses: [CaseStatus!]
      documentTypes: [String!]
      clientIds: [UUID!]
    }

    input DateRangeInput {
      start: DateTime!
      end: DateTime!
    }
    ```

  - [ ] Define query:

    ```graphql
    type Query {
      search(input: SearchInput!): SearchResponse!
      recentSearches(limit: Int = 10): [SearchHistory!]!
    }

    type SearchResponse {
      results: [SearchResult!]!
      totalCount: Int!
      searchTime: Float!
      query: String!
      searchMode: SearchMode!
    }
    ```

  - [ ] Location: `services/gateway/src/graphql/schema/search.graphql`

- [ ] **Task 15: Implement Search Query Resolver** (AC: 1, 3, 4, 5)
  - [ ] Create `services/gateway/src/graphql/resolvers/search.resolvers.ts`
  - [ ] Implement `search(input: SearchInput)` resolver:
    - Validate user is authenticated
    - Extract firmId from context
    - Call SearchService based on searchMode
    - Record search in SearchHistory (AC: 6)
    - Return SearchResponse with timing
  - [ ] Implement result highlighting using SearchService.getHighlight()
  - [ ] Location: `services/gateway/src/graphql/resolvers/search.resolvers.ts`

- [ ] **Task 16: Implement Recent Searches Query** (AC: 6)
  - [ ] Implement `recentSearches(limit)` resolver
  - [ ] Query SearchHistory table for user's recent searches
  - [ ] Order by createdAt DESC
  - [ ] Return last N unique queries (dedupe by query text)
  - [ ] Cache recent searches in Redis: `recentSearches:{userId}` with 15min TTL
  - [ ] Location: `services/gateway/src/graphql/resolvers/search.resolvers.ts`

### Phase 5: Search Results Caching (AC: 6)

- [ ] **Task 17: Implement Search Results Cache** (AC: 6)
  - [ ] Cache search results in Redis: `search:{firmId}:{hash(query+filters)}`
  - [ ] TTL: 5 minutes for full-text, 15 minutes for semantic (embeddings don't change often)
  - [ ] Invalidate cache on case/document create/update/delete for that firm
  - [ ] Use cache middleware pattern from Story 2.5
  - [ ] Location: `services/gateway/src/services/search.service.ts`

- [ ] **Task 18: Implement Cache Warming for Popular Searches** (AC: 6)
  - [ ] Track search frequency in SearchHistory
  - [ ] Identify top 10 searches per firm (by query count)
  - [ ] Background job to re-run popular searches every 30 minutes
  - [ ] Pre-populate cache with results
  - [ ] Location: `services/gateway/src/services/search.service.ts`

### Phase 6: Frontend - Search UI Components (AC: 4, 5)

- [ ] **Task 19: Create GlobalSearchBar Component** (AC: 4, 5)
  - [ ] Create `apps/web/src/components/search/GlobalSearchBar.tsx`
  - [ ] Use Radix Command (Combobox) for search input with suggestions
  - [ ] Show recent searches as dropdown suggestions (from useRecentSearches hook)
  - [ ] Debounce input (300ms) before triggering search
  - [ ] Show loading spinner during search
  - [ ] Keyboard shortcut: Cmd/Ctrl+K to focus search
  - [ ] Location: `apps/web/src/components/search/GlobalSearchBar.tsx`

- [ ] **Task 20: Create SearchFiltersPanel Component** (AC: 5)
  - [ ] Create `apps/web/src/components/search/SearchFiltersPanel.tsx`
  - [ ] Date range picker using date-fns and Radix Popover
  - [ ] Case type multi-select dropdown
  - [ ] Case status filter checkboxes
  - [ ] Document type filter (PDF, DOCX, XLSX, etc.)
  - [ ] Client filter dropdown (searchable)
  - [ ] "Clear all filters" button
  - [ ] Collapsible filter panel on mobile
  - [ ] Location: `apps/web/src/components/search/SearchFiltersPanel.tsx`

- [ ] **Task 21: Create SearchResults Component** (AC: 4)
  - [ ] Create `apps/web/src/components/search/SearchResults.tsx`
  - [ ] Display search results in card layout
  - [ ] Show: icon (case/document), title, highlight snippet, score badge
  - [ ] Highlight matched terms using `<mark>` tags
  - [ ] Show relevance score as percentage
  - [ ] Group results by type (Cases, Documents) or mixed view toggle
  - [ ] Pagination with "Load more" infinite scroll
  - [ ] Empty state: "No results found for [query]"
  - [ ] Location: `apps/web/src/components/search/SearchResults.tsx`

- [ ] **Task 22: Create useSearch Hook** (AC: 1-6)
  - [ ] Create `apps/web/src/hooks/useSearch.ts`
  - [ ] Implement React Query mutation for search
  - [ ] Handle search input debouncing
  - [ ] Track search state: loading, results, error
  - [ ] Implement `useRecentSearches` query hook
  - [ ] Cache search results with React Query
  - [ ] Location: `apps/web/src/hooks/useSearch.ts`

### Phase 7: Integration with Layout (AC: 1-6)

- [ ] **Task 23: Add Search to TopBar/Header** (AC: 4)
  - [ ] Update `apps/web/src/components/layout/TopBar.tsx`
  - [ ] Add GlobalSearchBar to header (centered or right-aligned)
  - [ ] On search submit, navigate to `/search?q={query}&filters={encodedFilters}`
  - [ ] Show search results count badge
  - [ ] Location: `apps/web/src/components/layout/TopBar.tsx`

- [ ] **Task 24: Create Search Results Page** (AC: 4, 5)
  - [ ] Create `apps/web/src/app/search/page.tsx`
  - [ ] Read query and filters from URL search params
  - [ ] Display SearchFiltersPanel (left sidebar or top collapsible)
  - [ ] Display SearchResults (main content)
  - [ ] Update URL on filter changes (shallow routing)
  - [ ] SEO: `<title>Search: {query} | Legal Platform</title>`
  - [ ] Location: `apps/web/src/app/search/page.tsx`

### Phase 8: Testing (All ACs)

- [ ] **Task 25: Write Unit Tests for Embedding Service** (AC: 2)
  - [ ] Create `services/gateway/__tests__/services/embedding.service.test.ts`
  - [ ] Test generateEmbedding: success, rate limit handling, chunking
  - [ ] Test queue processing: batch processing, retry logic
  - [ ] Test cache hit/miss scenarios
  - [ ] Mock Voyage AI API responses
  - [ ] Target 90%+ coverage
  - [ ] Location: `services/gateway/__tests__/services/embedding.service.test.ts`

- [ ] **Task 26: Write Unit Tests for Search Service** (AC: 1, 3, 4, 5)
  - [ ] Create `services/gateway/__tests__/services/search.service.test.ts`
  - [ ] Test fullTextSearch: query parsing, ranking, highlighting
  - [ ] Test semanticSearch: similarity threshold, vector search
  - [ ] Test hybridSearch: RRF algorithm, deduplication
  - [ ] Test filter application: date range, case type, document type
  - [ ] Test firm isolation (no cross-firm data leakage)
  - [ ] Mock Prisma and pgvector
  - [ ] Target 90%+ coverage
  - [ ] Location: `services/gateway/__tests__/services/search.service.test.ts`

- [ ] **Task 27: Write Unit Tests for Search Resolvers** (AC: 1-6)
  - [ ] Create `services/gateway/__tests__/resolvers/search.resolvers.test.ts`
  - [ ] Test search query: with/without filters, different modes
  - [ ] Test recentSearches query: caching, deduplication
  - [ ] Test authentication requirements
  - [ ] Test input validation
  - [ ] Mock SearchService
  - [ ] Target 90%+ coverage
  - [ ] Location: `services/gateway/__tests__/resolvers/search.resolvers.test.ts`

- [ ] **Task 28: Write Frontend Component Tests** (AC: 4, 5)
  - [ ] Create `apps/web/src/components/search/GlobalSearchBar.test.tsx`
  - [ ] Test input debouncing, suggestions display, keyboard navigation
  - [ ] Create `apps/web/src/components/search/SearchFiltersPanel.test.tsx`
  - [ ] Test filter selection, clear all, date range picker
  - [ ] Create `apps/web/src/components/search/SearchResults.test.tsx`
  - [ ] Test result rendering, highlighting, pagination
  - [ ] Mock GraphQL queries with Apollo MockedProvider
  - [ ] Target 70%+ coverage
  - [ ] Location: `apps/web/src/components/search/*.test.tsx`

- [ ] **Task 29: Write Integration Tests** (AC: 1-6)
  - [ ] Create `services/gateway/__tests__/integration/search-api.integration.test.ts`
  - [ ] Test complete search flow: query → embedding → search → results
  - [ ] Test hybrid search ranking accuracy
  - [ ] Test filter combinations
  - [ ] Test search history recording and retrieval
  - [ ] Test cache invalidation on data changes
  - [ ] Use test database with seeded data
  - [ ] Target 80%+ coverage
  - [ ] Location: `services/gateway/__tests__/integration/search-api.integration.test.ts`

## Dev Notes

### Previous Story Insights

**From Story 2.9 (Document Storage with OneDrive Integration):**

- Document model exists with fields: id, clientId, firmId, fileName, fileType, metadata
- Documents are client-owned (not case-owned) per Story 2.8.4 architecture
- Document metadata includes description and tags (searchable fields)
- OneDrive integration provides document content access if needed for full-text indexing
- Redis caching patterns established for document metadata

[Source: docs/stories/2.9.story.md]

**From Story 2.6 (Case Management Data Model and API):**

- Case model exists with: id, caseNumber, title, clientId, status, type, description, firmId
- GraphQL API operational with proper authorization rules
- Case-to-Client relationship established
- Audit logging in place for case modifications

[Source: docs/stories/2.6.story.md]

**From Story 2.5 (Microsoft Graph API Integration):**

- Redis caching infrastructure established
- Rate limiting middleware available
- Error handling and retry logic patterns in place
- Token management for external API calls

[Source: docs/stories/2.5.story.md]

### PostgreSQL Full-Text Search Architecture

[Source: docs/architecture/database-schema.md]

**Extensions Required (already enabled in schema):**

- `pg_trgm`: Trigram similarity for fuzzy matching
- `pgvector`: Vector similarity search for semantic search

**Full-Text Search Configuration:**

```sql
-- Create full-text search configuration for Romanian legal documents
CREATE TEXT SEARCH CONFIGURATION romanian_legal (COPY = romanian);

-- GIN index for full-text search on cases
CREATE INDEX idx_cases_search ON cases
USING GIN (to_tsvector('romanian', coalesce(title, '') || ' ' || coalesce(description, '') || ' ' || coalesce(case_number, '')));

-- GIN index for full-text search on documents
CREATE INDEX idx_documents_search ON documents
USING GIN (to_tsvector('simple', coalesce(file_name, '') || ' ' || coalesce(metadata->>'description', '')));
```

**Vector Search Configuration:**

```sql
-- HNSW index for fast approximate nearest neighbor search
CREATE INDEX idx_cases_embedding ON cases
USING hnsw (content_embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

CREATE INDEX idx_documents_embedding ON documents
USING hnsw (metadata_embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);
```

**Query Patterns:**

```sql
-- Full-text search with ranking
SELECT id, title,
       ts_rank(to_tsvector('romanian', title || ' ' || description), plainto_tsquery('romanian', $1)) as rank,
       ts_headline('romanian', title || ' ' || description, plainto_tsquery('romanian', $1)) as highlight
FROM cases
WHERE firm_id = $2
  AND to_tsvector('romanian', title || ' ' || description) @@ plainto_tsquery('romanian', $1)
ORDER BY rank DESC
LIMIT 20;

-- Semantic search with pgvector
SELECT id, title, 1 - (content_embedding <=> $1::vector) as similarity
FROM cases
WHERE firm_id = $2
  AND content_embedding IS NOT NULL
  AND 1 - (content_embedding <=> $1::vector) > 0.7
ORDER BY content_embedding <=> $1::vector
LIMIT 20;
```

[Source: PostgreSQL documentation, pgvector documentation]

### AI Embedding Strategy

[Source: docs/architecture/external-apis.md#voyage-ai, docs/architecture/ai-provider-strategy.md]

**Voyage AI Configuration:**

- **Model**: `voyage-large-2` - Best quality for legal documents
- **Dimensions**: 1536 (compatible with pgvector)
- **Max Tokens**: 8000 per request
- **Rate Limit**: 300 requests/min

**Embedding Generation Flow:**

```typescript
class EmbeddingService {
  private readonly VOYAGE_API_URL = 'https://api.voyageai.com/v1/embeddings';
  private readonly MODEL = 'voyage-large-2';
  private readonly MAX_TOKENS = 8000;

  async generateEmbedding(text: string): Promise<number[]> {
    // Check cache first
    const cacheKey = `embedding:${this.hashText(text)}`;
    const cached = await this.redis.get(cacheKey);
    if (cached) return JSON.parse(cached);

    // Chunk long text
    const chunks = this.chunkText(text, this.MAX_TOKENS);

    // Generate embeddings for each chunk
    const embeddings = await Promise.all(chunks.map((chunk) => this.callVoyageAPI(chunk)));

    // Average embeddings if multiple chunks
    const averaged = this.averageEmbeddings(embeddings);

    // Cache result
    await this.redis.setex(cacheKey, 86400, JSON.stringify(averaged));

    return averaged;
  }

  private async callVoyageAPI(text: string): Promise<number[]> {
    const response = await fetch(this.VOYAGE_API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${process.env.VOYAGE_API_KEY}`,
      },
      body: JSON.stringify({
        model: this.MODEL,
        input: text,
      }),
    });

    const data = await response.json();
    return data.data[0].embedding;
  }
}
```

**Fallback Strategy (Claude Embeddings):**

If Voyage AI is unavailable, Claude can generate text descriptions for semantic matching:

```typescript
async generateClaudeFallback(text: string): Promise<string> {
  // Use Claude to generate semantic summary
  const response = await this.anthropic.messages.create({
    model: 'claude-3-haiku-20240307',
    max_tokens: 500,
    messages: [{
      role: 'user',
      content: `Summarize this legal content in 2-3 sentences for search indexing:\n\n${text}`
    }]
  });

  // Store summary in searchText field for full-text search
  return response.content[0].text;
}
```

[Source: docs/architecture/ai-provider-strategy.md, Voyage AI documentation]

### Hybrid Search Algorithm (RRF)

[Source: Research paper: "Reciprocal Rank Fusion outperforms Condorcet and individual Rank Learning Methods"]

**Reciprocal Rank Fusion (RRF):**

```typescript
interface RankedResult {
  id: string;
  fullTextRank?: number; // 1-based rank in full-text results
  semanticRank?: number; // 1-based rank in semantic results
}

function computeRRFScore(
  fullTextRank: number | undefined,
  semanticRank: number | undefined,
  k: number = 60 // Standard RRF constant
): number {
  let score = 0;
  if (fullTextRank !== undefined) {
    score += 1 / (k + fullTextRank);
  }
  if (semanticRank !== undefined) {
    score += 1 / (k + semanticRank);
  }
  return score;
}

function hybridSearch(
  fullTextResults: SearchResult[],
  semanticResults: SearchResult[]
): SearchResult[] {
  // Create map of all results
  const resultMap = new Map<string, RankedResult>();

  fullTextResults.forEach((r, i) => {
    resultMap.set(r.id, { id: r.id, fullTextRank: i + 1 });
  });

  semanticResults.forEach((r, i) => {
    const existing = resultMap.get(r.id);
    if (existing) {
      existing.semanticRank = i + 1;
    } else {
      resultMap.set(r.id, { id: r.id, semanticRank: i + 1 });
    }
  });

  // Compute RRF scores and sort
  return Array.from(resultMap.values())
    .map((r) => ({
      ...r,
      rrfScore: computeRRFScore(r.fullTextRank, r.semanticRank),
    }))
    .sort((a, b) => b.rrfScore - a.rrfScore);
}
```

### Search Result Highlighting

[Source: PostgreSQL documentation - ts_headline]

```typescript
function highlightResult(text: string, query: string, maxWords: number = 35): string {
  // For full-text results, use PostgreSQL ts_headline
  const headline = await prisma.$queryRaw`
    SELECT ts_headline(
      'romanian',
      ${text},
      plainto_tsquery('romanian', ${query}),
      'MaxWords=${maxWords}, MinWords=15, StartSel=<mark>, StopSel=</mark>'
    ) as highlight
  `;

  return headline[0].highlight;
}
```

For semantic results without exact term matches:

```typescript
function semanticHighlight(text: string, maxLength: number = 200): string {
  // Return first N characters as snippet
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength).trim() + '...';
}
```

### GraphQL Search Schema

```graphql
# Search types
union SearchResult = CaseSearchResult | DocumentSearchResult

type CaseSearchResult {
  case: Case!
  score: Float! # Normalized 0-1 relevance score
  highlight: String # Highlighted snippet with <mark> tags
  matchType: SearchMatchType!
}

type DocumentSearchResult {
  document: Document!
  score: Float!
  highlight: String
  matchType: SearchMatchType!
}

enum SearchMatchType {
  FULL_TEXT # Matched via keyword search
  SEMANTIC # Matched via vector similarity
  HYBRID # Matched by both methods
}

enum SearchMode {
  FULL_TEXT # PostgreSQL full-text search only
  SEMANTIC # Vector similarity search only
  HYBRID # Combined (default, recommended)
}

input SearchInput {
  query: String!
  searchMode: SearchMode = HYBRID
  filters: SearchFiltersInput
  limit: Int = 20
  offset: Int = 0
}

input SearchFiltersInput {
  dateRange: DateRangeInput
  caseIds: [UUID!]
  caseTypes: [CaseType!]
  caseStatuses: [CaseStatus!]
  documentTypes: [String!] # MIME types
  clientIds: [UUID!]
}

input DateRangeInput {
  start: DateTime!
  end: DateTime!
}

type SearchResponse {
  results: [SearchResult!]!
  totalCount: Int!
  searchTime: Float! # Query execution time in ms
  query: String!
  searchMode: SearchMode!
}

type SearchHistory {
  id: UUID!
  query: String!
  searchMode: SearchMode!
  filters: JSON
  resultCount: Int!
  createdAt: DateTime!
}

type Query {
  search(input: SearchInput!): SearchResponse!
  recentSearches(limit: Int = 10): [SearchHistory!]!
}
```

### Caching Strategy

[Source: docs/stories/2.5.story.md (Redis caching patterns)]

**Search Results Cache:**

```typescript
const CACHE_CONFIG = {
  FULL_TEXT_TTL: 300, // 5 minutes
  SEMANTIC_TTL: 900, // 15 minutes
  RECENT_SEARCHES_TTL: 900, // 15 minutes
};

async function getCachedSearch(
  firmId: string,
  query: string,
  filters: SearchFilters
): Promise<SearchResponse | null> {
  const cacheKey = `search:${firmId}:${hashQuery(query, filters)}`;
  const cached = await redis.get(cacheKey);
  return cached ? JSON.parse(cached) : null;
}

async function cacheSearchResults(
  firmId: string,
  query: string,
  filters: SearchFilters,
  results: SearchResponse,
  mode: SearchMode
): Promise<void> {
  const cacheKey = `search:${firmId}:${hashQuery(query, filters)}`;
  const ttl = mode === 'SEMANTIC' ? CACHE_CONFIG.SEMANTIC_TTL : CACHE_CONFIG.FULL_TEXT_TTL;
  await redis.setex(cacheKey, ttl, JSON.stringify(results));
}
```

**Cache Invalidation:**

```typescript
async function invalidateSearchCache(firmId: string): Promise<void> {
  // Delete all search cache entries for firm
  const keys = await redis.keys(`search:${firmId}:*`);
  if (keys.length > 0) {
    await redis.del(...keys);
  }
}

// Trigger on case/document mutations
async function onCaseUpdated(caseId: string, firmId: string): Promise<void> {
  await invalidateSearchCache(firmId);
  await queueForEmbedding({ type: 'case', id: caseId });
}

async function onDocumentUploaded(documentId: string, firmId: string): Promise<void> {
  await invalidateSearchCache(firmId);
  await queueForEmbedding({ type: 'document', id: documentId });
}
```

### File Locations and Project Structure

**Backend (Gateway Service):**

```
services/gateway/
├── src/
│   ├── services/
│   │   ├── embedding.service.ts (NEW - Tasks 4-7)
│   │   └── search.service.ts (NEW - Tasks 8-12)
│   ├── graphql/
│   │   ├── schema/
│   │   │   └── search.graphql (NEW - Tasks 13-14)
│   │   └── resolvers/
│   │       └── search.resolvers.ts (NEW - Tasks 15-16)
└── __tests__/
    ├── services/
    │   ├── embedding.service.test.ts (NEW - Task 25)
    │   └── search.service.test.ts (NEW - Task 26)
    ├── resolvers/
    │   └── search.resolvers.test.ts (NEW - Task 27)
    └── integration/
        └── search-api.integration.test.ts (NEW - Task 29)
```

**Frontend (Web App):**

```
apps/web/
├── src/
│   ├── components/
│   │   └── search/
│   │       ├── GlobalSearchBar.tsx (NEW - Task 19)
│   │       ├── SearchFiltersPanel.tsx (NEW - Task 20)
│   │       └── SearchResults.tsx (NEW - Task 21)
│   ├── hooks/
│   │   └── useSearch.ts (NEW - Task 22)
│   ├── app/
│   │   └── search/
│   │       └── page.tsx (NEW - Task 24)
│   └── components/
│       └── layout/
│           └── TopBar.tsx (UPDATE - Task 23)
└── __tests__/
    └── components/
        └── search/
            ├── GlobalSearchBar.test.tsx (NEW - Task 28)
            ├── SearchFiltersPanel.test.tsx (NEW - Task 28)
            └── SearchResults.test.tsx (NEW - Task 28)
```

**Database (Shared Package):**

```
packages/database/
├── prisma/
│   ├── schema.prisma (UPDATE - Tasks 1, 3)
│   └── migrations/
│       └── {timestamp}_add_search_embeddings/
│           └── migration.sql (NEW - Tasks 1-2)
```

[Source: docs/architecture/unified-project-structure.md]

### Environment Variables

**New Environment Variables Required:**

```bash
# Voyage AI for Embeddings
VOYAGE_API_KEY=<voyage-api-key>
VOYAGE_MODEL=voyage-large-2
VOYAGE_API_URL=https://api.voyageai.com/v1

# Search Configuration
SEARCH_MIN_SIMILARITY=0.7      # Minimum cosine similarity for semantic results
SEARCH_RESULTS_LIMIT=20        # Default results per page
SEARCH_CACHE_TTL=300           # Search results cache TTL (seconds)
EMBEDDING_CACHE_TTL=86400      # Embedding cache TTL (24 hours)

# Embedding Queue Configuration
EMBEDDING_BATCH_SIZE=50        # Items to process per batch
EMBEDDING_BATCH_INTERVAL=5000  # Batch processing interval (ms)
```

**Existing Environment Variables (from prior stories):**

- `DATABASE_URL` - PostgreSQL connection (Story 2.2)
- `REDIS_URL` - Redis for caching (Story 2.5)
- `ANTHROPIC_API_KEY` - Claude API for fallback (Story 2.11)

[Source: docs/architecture/ai-provider-strategy.md, docs/stories/2.5.story.md]

### Security Considerations

**Firm Data Isolation:**

- ALL search queries MUST include `firm_id` filter
- Never return results from other firms
- Validate user's firmId from JWT context

```typescript
function buildSearchQuery(query: string, firmId: string, filters: SearchFilters) {
  return prisma.$queryRaw`
    SELECT * FROM cases
    WHERE firm_id = ${firmId}  -- MANDATORY firm isolation
    AND to_tsvector('romanian', title || ' ' || description) @@ plainto_tsquery('romanian', ${query})
    ...
  `;
}
```

**Input Validation:**

- Sanitize search query to prevent SQL injection
- Limit query length (max 500 characters)
- Rate limit search requests (100 per minute per user)

**Audit Logging:**

- Log all search queries to SearchHistory
- Track search patterns for security monitoring
- Alert on unusual search activity (potential data exfiltration)

[Source: docs/architecture/coding-standards.md]

### Performance Targets

**Expected Performance:**

- Full-text search: <100ms for 10K cases
- Semantic search: <200ms for 10K cases (with HNSW index)
- Hybrid search: <300ms combined
- Embedding generation: <500ms per document
- Cache hit: <10ms

**Optimization Strategies:**

1. **HNSW Index Tuning**: m=16, ef_construction=64 for balance of speed/accuracy
2. **Connection Pooling**: Reuse database connections for vector queries
3. **Embedding Batching**: Process 50 items per batch to reduce API calls
4. **Result Pagination**: Limit to 20 results per page with offset
5. **Cache Warming**: Pre-compute popular searches

[Source: pgvector documentation, performance best practices]

## Testing

### Unit Tests

- **Framework**: Jest 29+ (backend), Jest + React Testing Library (frontend)
- **Backend Location**: `services/gateway/__tests__/`
- **Frontend Location**: `apps/web/src/components/**/*.test.tsx`
- **Coverage Target**: 90% backend (services/resolvers), 70% frontend (components)

### Integration Tests

- **Framework**: Jest with test database
- **Location**: `services/gateway/__tests__/integration/`
- **Coverage Target**: 80%+
- **Key Test Flows**:
  - Complete search flow: query → embedding → search → results
  - Hybrid ranking algorithm accuracy
  - Filter combinations
  - Cache behavior

### E2E Tests

- **Framework**: Playwright 1.41+
- **Location**: Root-level `tests/` directory
- **Critical User Journey**:
  - Login → Type search query → Apply filters → View results → Click result → Navigate to case/document

[Source: docs/architecture/testing-strategy.md]

## Change Log

| Date       | Version | Description                   | Author         |
| ---------- | ------- | ----------------------------- | -------------- |
| 2025-11-25 | 1.0     | Story created by Scrum Master | Bob (sm agent) |

## Dev Agent Record

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes

_To be filled by dev agent_

### File List

_To be filled by dev agent_

## QA Results

_To be filled by QA agent_
