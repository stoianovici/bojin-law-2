# Story 5.8: Platform Monitoring and Operations

**Epic:** 5 - Communication Intelligence & Proactive AI Assistant
**Story Type:** Infrastructure/DevOps
**Priority:** High
**Dependencies:** Story 3.8 (Document System Testing and Performance - New Relic setup)

## Status

Ready for development

## Story

**As a** platform operator,
**I want** comprehensive monitoring and alerting,
**so that** we can maintain high availability.

## Acceptance Criteria

1. Application Insights dashboards for health, performance, errors, activity
2. Alerts configured for downtime, degradation, errors, budget, security
3. Log aggregation and search capabilities
4. Incident response runbook
5. On-call rotation schedule
6. Status page for users

## Tasks / Subtasks

### Phase 1: New Relic Dashboard Configuration (AC: 1)

- [ ] **Task 1: Create Service Health Dashboard** (AC: 1)
  - [ ] Create `infrastructure/newrelic/dashboards/service-health.json`
  - [ ] Configure dashboard widgets:
    - Service uptime for all services (gateway, ai-service, web)
    - Current service status indicators (healthy/degraded/unhealthy)
    - Uptime percentage over last 30 days
    - Service response time overview
  - [ ] Add drill-down to individual service views
  - [ ] Configure auto-refresh at 1-minute intervals
        [Source: services/gateway/newrelic.js, services/ai-service/newrelic.js]

- [ ] **Task 2: Create Performance Dashboard** (AC: 1)
  - [ ] Create `infrastructure/newrelic/dashboards/performance.json`
  - [ ] Configure performance metrics:
    - API response times (p50, p95, p99)
    - GraphQL query performance breakdown
    - Database query performance
    - Redis cache hit/miss rates
    - AI operation latencies (TTFT, total)
  - [ ] Add performance trend charts (hourly/daily/weekly)
  - [ ] Configure throughput metrics (requests/sec)
        [Source: services/ai-service/newrelic.js - AI-specific attributes]

- [ ] **Task 3: Create Error Tracking Dashboard** (AC: 1)
  - [ ] Create `infrastructure/newrelic/dashboards/errors.json`
  - [ ] Configure error metrics:
    - Error rate by service
    - Error breakdown by type (4xx vs 5xx)
    - Top 10 most frequent errors
    - Error stack traces
    - AI provider errors (rate limits, timeouts)
  - [ ] Add error trend charts
  - [ ] Configure error grouping by similarity
        [Source: services/ai-service/newrelic.js:60-66 - error_collector config]

- [ ] **Task 4: Create Activity Dashboard** (AC: 1)
  - [ ] Create `infrastructure/newrelic/dashboards/activity.json`
  - [ ] Configure activity metrics:
    - Active users (concurrent sessions)
    - API requests by endpoint
    - Document operations (create/read/update)
    - AI operations by type
    - Email sync activity
  - [ ] Add time-of-day heatmap
  - [ ] Configure user activity breakdown
        [Source: services/gateway/newrelic.js:131-145 - transaction naming rules]

- [ ] **Task 5: Create AI Operations Dashboard** (AC: 1)
  - [ ] Create `infrastructure/newrelic/dashboards/ai-operations.json`
  - [ ] Configure AI-specific metrics:
    - Token usage by model (input/output)
    - Cost by operation type
    - Provider health status
    - Cache hit rates for AI responses
    - Failover events
  - [ ] Add cost tracking charts (hourly/daily/monthly)
  - [ ] Configure model comparison views
        [Source: services/ai-service/src/monitoring/token-usage-monitor.ts]

### Phase 2: Alert Configuration (AC: 2)

- [ ] **Task 6: Configure Downtime Alerts** (AC: 2)
  - [ ] Create `infrastructure/newrelic/alerts/downtime-policy.json`
  - [ ] Configure alerts:
    - Service unreachable (health check fails for > 1 minute)
    - Database connection failure
    - Redis connection failure
    - External API unavailable (Microsoft Graph, Claude API)
  - [ ] Set notification channels: PagerDuty (critical), Slack (#incidents)
  - [ ] Configure escalation: Page on-call → Page secondary → Page manager after 15min
        [Source: services/ai-service/src/monitoring/AlertsManager.ts:118-154 - CRITICAL alerts]

- [ ] **Task 7: Configure Degradation Alerts** (AC: 2)
  - [ ] Create `infrastructure/newrelic/alerts/degradation-policy.json`
  - [ ] Configure alerts:
    - Response time p95 > 3s for > 5 minutes
    - Error rate > 1% for > 5 minutes
    - Database query latency > 500ms
    - Cache hit rate < 50% for > 10 minutes
  - [ ] Set notification channels: Slack (#performance), Email
  - [ ] Configure thresholds per service type
        [Source: services/ai-service/src/monitoring/AlertsManager.ts:156-201 - WARNING alerts]

- [ ] **Task 8: Configure Error Rate Alerts** (AC: 2)
  - [ ] Create `infrastructure/newrelic/alerts/error-policy.json`
  - [ ] Configure alerts:
    - 5xx error rate > 0.5% (warning), > 2% (critical)
    - Specific error spikes (rate of change detection)
    - Unhandled exceptions
    - AI provider failures (rate limit, timeout)
  - [ ] Configure error aggregation window (5 minutes)
  - [ ] Set up error correlation with deployments
        [Source: services/ai-service/src/monitoring/AlertsManager.ts:130-142 - high error rate]

- [ ] **Task 9: Configure Budget Alerts** (AC: 2)
  - [ ] Create `infrastructure/newrelic/alerts/budget-policy.json`
  - [ ] Configure alerts:
    - Daily AI spend > 80% of budget (warning)
    - Daily AI spend > 100% of budget (critical)
    - Hourly cost spike > 150% of baseline
    - Monthly projection exceeds budget
  - [ ] Set notification channels: Email (finance), Slack (#costs)
  - [ ] Configure budget thresholds per firm (multi-tenant)
        [Source: services/ai-service/src/monitoring/AlertsManager.ts:178-189 - cost spike]
        [Source: services/ai-service/src/monitoring/CostTracker.ts]

- [ ] **Task 10: Configure Security Alerts** (AC: 2)
  - [ ] Create `infrastructure/newrelic/alerts/security-policy.json`
  - [ ] Configure alerts:
    - Failed authentication attempts > 10/minute per IP
    - Suspicious API patterns (rate anomaly detection)
    - Data access anomalies (unusual query patterns)
    - Certificate expiration (30 days warning, 7 days critical)
  - [ ] Set notification channels: PagerDuty, Email (security team)
  - [ ] Configure IP blocking integration
        [Source: services/gateway/newrelic.js:159-165 - security settings]

### Phase 3: Log Aggregation and Search (AC: 3)

- [ ] **Task 11: Upgrade Loggers with Structured Logging for New Relic** (AC: 3)
  - [ ] Update `services/gateway/src/utils/logger.ts` with Winston and structured logging:

    ```typescript
    import winston from 'winston';
    import newrelicFormatter from '@newrelic/winston-enricher';

    interface LogEntry {
      timestamp: string;
      level: 'error' | 'warn' | 'info' | 'debug';
      service: string;
      traceId?: string;
      spanId?: string;
      userId?: string;
      firmId?: string;
      message: string;
      context?: Record<string, any>;
      error?: {
        name: string;
        message: string;
        stack?: string;
      };
    }

    const logger = winston.createLogger({
      level: process.env.LOG_LEVEL || 'info',
      format: winston.format.combine(
        newrelicFormatter(),
        winston.format.timestamp(),
        winston.format.json()
      ),
      defaultMeta: { service: 'gateway' },
      transports: [new winston.transports.Console()],
    });
    ```

  - [ ] Update `services/ai-service/src/lib/logger.ts` with same pattern (service: 'ai-service')
  - [ ] Add correlation IDs to all logs via middleware (extract from `newrelic.getTransaction()`)
  - [ ] Configure log levels per environment (LOG_LEVEL env var)
  - [ ] Install dependencies: `pnpm add winston @newrelic/winston-enricher`
        [Source: docs/architecture/tech-stack.md:26 - Winston + New Relic]
        [Source: services/gateway/src/utils/logger.ts - existing logger to upgrade]
        [Source: services/ai-service/src/lib/logger.ts - existing logger to upgrade]

- [ ] **Task 12: Configure Log Retention and Indexing** (AC: 3)
  - [ ] Create `infrastructure/newrelic/logging/config.json`
  - [ ] Configure log retention:
    - Production: 30 days
    - Staging: 14 days
    - Error logs: 90 days
  - [ ] Configure log parsing rules for structured fields
  - [ ] Set up log-based metrics for key patterns
  - [ ] Create saved searches for common queries

- [ ] **Task 13: Create Log Search Documentation** (AC: 3)
  - [ ] Create `docs/operations/log-search-guide.md`
  - [ ] Document common search queries:
    - Find errors by trace ID
    - Search by user/firm
    - Find slow queries
    - Trace AI operations
  - [ ] Include NRQL query examples
  - [ ] Document log field schema

### Phase 4: Incident Response Runbook (AC: 4)

- [ ] **Task 14: Create Master Incident Response Runbook** (AC: 4)
  - [ ] Create `docs/operations/runbooks/incident-response.md`
  - [ ] Document incident classification:
    - SEV1: Complete outage, data loss risk
    - SEV2: Partial outage, significant degradation
    - SEV3: Minor degradation, workaround available
    - SEV4: Cosmetic issues, low impact
  - [ ] Document response procedures:
    - Initial assessment (5 minutes)
    - Communication (internal + external)
    - Investigation steps
    - Mitigation actions
    - Resolution verification
    - Post-incident review
  - [ ] Include escalation matrix
  - [ ] Add communication templates
        [Source: services/ai-service/src/monitoring/AlertsManager.ts:128 - runbook URLs]

- [ ] **Task 15: Create Service-Specific Runbooks** (AC: 4)
  - [ ] Create `docs/operations/runbooks/gateway-service.md`:
    - GraphQL errors troubleshooting
    - Database connection issues
    - Cache invalidation procedures
    - Rollback procedures
  - [ ] Create `docs/operations/runbooks/ai-service.md`:
    - AI provider failover procedures
    - Rate limit handling
    - Cost spike investigation
    - Model degradation response
  - [ ] Create `docs/operations/runbooks/database.md`:
    - Connection pool exhaustion
    - Slow query investigation
    - Backup restoration
    - Failover procedures
  - [ ] Create `docs/operations/runbooks/redis.md`:
    - Cache eviction issues
    - Memory pressure handling
    - Cluster failover

- [ ] **Task 16: Create Deployment Runbook** (AC: 4)
  - [ ] Create `docs/operations/runbooks/deployment.md`
  - [ ] Document deployment procedures:
    - Pre-deployment checklist
    - Deployment steps
    - Smoke test verification
    - Rollback procedures
  - [ ] Include canary deployment guidelines
  - [ ] Document feature flag procedures
  - [ ] Add database migration guidelines

### Phase 5: On-Call Rotation Schedule (AC: 5)

- [ ] **Task 17: Define On-Call Structure** (AC: 5)
  - [ ] Create `docs/operations/on-call/rotation.md`
  - [ ] Document rotation structure:
    - Primary on-call (first responder)
    - Secondary on-call (escalation)
    - Engineering manager (final escalation)
  - [ ] Define rotation schedule:
    - Weekly rotations
    - Handoff procedures (Fridays 10 AM)
    - Holiday coverage planning
  - [ ] Document on-call expectations:
    - Response time SLAs (< 15 min for SEV1)
    - Required access and tools
    - Compensation policy

- [ ] **Task 18: Configure PagerDuty Integration** (AC: 5)
  - [ ] Create `infrastructure/pagerduty/schedules/primary-oncall.json`
  - [ ] Configure schedules:
    - Primary rotation schedule
    - Secondary rotation schedule
    - Management escalation
  - [ ] Configure escalation policies:
    - Immediate: Page primary
    - After 10 min: Page secondary
    - After 20 min: Page manager
  - [ ] Set up overrides for vacations/holidays
  - [ ] Configure PagerDuty mobile app requirements
        [Source: services/ai-service/src/monitoring/AlertsManager.ts:360-417 - PagerDuty integration]

- [ ] **Task 19: Create On-Call Handbook** (AC: 5)
  - [ ] Create `docs/operations/on-call/handbook.md`
  - [ ] Document:
    - Getting started as on-call
    - Required access and permissions
    - Tools and dashboards overview
    - Common issues and quick fixes
    - When to escalate
    - Post-incident procedures
  - [ ] Include contact list for external vendors
  - [ ] Add FAQ section

### Phase 6: Status Page (AC: 6)

- [ ] **Task 20: Create Status Page API** (AC: 6)
  - [ ] Create `services/gateway/src/routes/status.routes.ts`
  - [ ] Implement endpoints:
    ```typescript
    GET / status; // Current system status
    GET / status / history; // Historical incidents
    GET / status / components; // Individual component status
    GET / status / subscribe; // Email subscription
    ```
  - [ ] Implement status aggregation from health checks
  - [ ] Add incident management (create/update/resolve)
  - [ ] Cache status with 30-second TTL

- [ ] **Task 21: Create Status Page Data Models** (AC: 6)
  - [ ] Add to Prisma schema:

    ```prisma
    model StatusComponent {
      id          String   @id @default(cuid())
      name        String   // 'Web Application', 'API', 'AI Services', etc.
      slug        String   @unique
      description String?
      status      ComponentStatus @default(OPERATIONAL)
      order       Int      @default(0)
      incidents   StatusIncident[]
      createdAt   DateTime @default(now())
      updatedAt   DateTime @updatedAt
    }

    model StatusIncident {
      id           String   @id @default(cuid())
      title        String
      status       IncidentStatus @default(INVESTIGATING)
      impact       IncidentImpact @default(MINOR)
      message      String   @db.Text
      componentId  String
      component    StatusComponent @relation(fields: [componentId], references: [id])
      updates      StatusUpdate[]
      startedAt    DateTime @default(now())
      resolvedAt   DateTime?
      createdAt    DateTime @default(now())
      updatedAt    DateTime @updatedAt
    }

    model StatusUpdate {
      id         String   @id @default(cuid())
      incidentId String
      incident   StatusIncident @relation(fields: [incidentId], references: [id])
      status     IncidentStatus
      message    String   @db.Text
      createdAt  DateTime @default(now())
    }

    enum ComponentStatus {
      OPERATIONAL
      DEGRADED_PERFORMANCE
      PARTIAL_OUTAGE
      MAJOR_OUTAGE
      MAINTENANCE
    }

    enum IncidentStatus {
      INVESTIGATING
      IDENTIFIED
      MONITORING
      RESOLVED
    }

    enum IncidentImpact {
      NONE
      MINOR
      MAJOR
      CRITICAL
    }
    ```

  - [ ] Create migration: `pnpm prisma migrate dev --name add_status_page_models`
  - [ ] Create seed file `packages/database/prisma/seed-status.ts`:
    ```typescript
    const defaultComponents = [
      {
        name: 'Web Application',
        slug: 'web',
        description: 'Next.js frontend application',
        order: 1,
      },
      { name: 'API Gateway', slug: 'api', description: 'GraphQL API service', order: 2 },
      { name: 'AI Services', slug: 'ai', description: 'AI processing and inference', order: 3 },
      {
        name: 'Document Storage',
        slug: 'storage',
        description: 'Cloudflare R2 document storage',
        order: 4,
      },
      {
        name: 'Email Integration',
        slug: 'email',
        description: 'Microsoft Graph email sync',
        order: 5,
      },
      { name: 'Database', slug: 'database', description: 'PostgreSQL database', order: 6 },
    ];
    ```
  - [ ] Update `packages/database/prisma/seed.ts` to include status component seeding

- [ ] **Task 22: Create Status Page GraphQL Schema** (AC: 6)
  - [ ] Create `services/gateway/src/graphql/schema/status.graphql`:

    ```graphql
    type StatusComponent {
      id: ID!
      name: String!
      slug: String!
      description: String
      status: ComponentStatus!
      activeIncidents: [StatusIncident!]!
    }

    type StatusIncident {
      id: ID!
      title: String!
      status: IncidentStatus!
      impact: IncidentImpact!
      message: String!
      component: StatusComponent!
      updates: [StatusUpdate!]!
      startedAt: DateTime!
      resolvedAt: DateTime
    }

    type StatusUpdate {
      id: ID!
      status: IncidentStatus!
      message: String!
      createdAt: DateTime!
    }

    type SystemStatus {
      status: ComponentStatus!
      components: [StatusComponent!]!
      activeIncidents: [StatusIncident!]!
      lastUpdated: DateTime!
    }

    enum ComponentStatus {
      OPERATIONAL
      DEGRADED_PERFORMANCE
      PARTIAL_OUTAGE
      MAJOR_OUTAGE
      MAINTENANCE
    }

    enum IncidentStatus {
      INVESTIGATING
      IDENTIFIED
      MONITORING
      RESOLVED
    }

    enum IncidentImpact {
      NONE
      MINOR
      MAJOR
      CRITICAL
    }

    extend type Query {
      systemStatus: SystemStatus!
      statusComponent(slug: String!): StatusComponent
      statusIncident(id: ID!): StatusIncident
      statusHistory(days: Int = 90): [StatusIncident!]!
    }

    extend type Mutation {
      # Admin only
      createIncident(input: CreateIncidentInput!): StatusIncident!
      updateIncident(id: ID!, input: UpdateIncidentInput!): StatusIncident!
      resolveIncident(id: ID!, message: String!): StatusIncident!
      addIncidentUpdate(incidentId: ID!, input: AddUpdateInput!): StatusUpdate!
      updateComponentStatus(slug: String!, status: ComponentStatus!): StatusComponent!
    }

    input CreateIncidentInput {
      title: String!
      componentSlug: String!
      impact: IncidentImpact!
      message: String!
    }

    input UpdateIncidentInput {
      title: String
      status: IncidentStatus
      impact: IncidentImpact
      message: String
    }

    input AddUpdateInput {
      status: IncidentStatus!
      message: String!
    }
    ```

  - [ ] Create resolvers with admin authorization

- [ ] **Task 23: Create Status Page Frontend** (AC: 6)
  - [ ] Create `apps/web/src/app/status/page.tsx`
  - [ ] Implement components:
    - Overall status banner
    - Component status list
    - Active incidents panel
    - Incident history timeline
    - Subscribe form
  - [ ] Use public layout (no auth required)
  - [ ] Add real-time updates via polling (30 sec)
  - [ ] Mobile-responsive design
  - [ ] Accessibility: Proper ARIA labels, status announcements

- [ ] **Task 24: Create Status Page Components** (AC: 6)
  - [ ] Create `apps/web/src/components/status/StatusBanner.tsx`:
    - Color-coded by overall status
    - Icon indicator
    - "All Systems Operational" or issue summary
  - [ ] Create `apps/web/src/components/status/ComponentList.tsx`:
    - List of all components with status
    - Expandable incident details
    - Color-coded status indicators
  - [ ] Create `apps/web/src/components/status/IncidentTimeline.tsx`:
    - Chronological incident updates
    - Status change indicators
    - Relative timestamps
  - [ ] Create `apps/web/src/components/status/SubscribeForm.tsx`:
    - Email input
    - Component selection
    - Incident type preferences

### Phase 7: Automated Status Updates (AC: 1, 6)

- [ ] **Task 25: Create Status Sync Worker** (AC: 1, 6)
  - [ ] Create `services/gateway/src/workers/status-sync.worker.ts`
  - [ ] Implement automatic status updates:
    - Poll health check endpoints every 30 seconds
    - Update component status based on health
    - Auto-create incidents for sustained outages (> 3 minutes)
    - Auto-resolve incidents when health restored
  - [ ] Configure thresholds for status transitions
  - [ ] Add debouncing to prevent flapping

- [ ] **Task 26: Create Status Notification Service** (AC: 6)
  - [ ] Create `services/gateway/src/services/status-notification.service.ts`
  - [ ] Implement notifications:
    - Email subscribers on incident create/update/resolve
    - Slack #status channel integration
    - RSS feed generation
  - [ ] Configure notification batching (aggregate rapid updates)
  - [ ] Add unsubscribe handling

### Phase 8: Testing (AC: 1-6)

- [ ] **Task 27: Create Test Fixtures and Factories** (AC: 6)
  - [ ] Create `services/gateway/__tests__/fixtures/status.fixtures.ts`:
    ```typescript
    export const mockComponents = [
      { id: 'comp-1', name: 'Web Application', slug: 'web', status: 'OPERATIONAL', order: 1 },
      { id: 'comp-2', name: 'API Gateway', slug: 'api', status: 'OPERATIONAL', order: 2 },
      { id: 'comp-3', name: 'AI Services', slug: 'ai', status: 'DEGRADED_PERFORMANCE', order: 3 },
    ];
    export const mockIncident = {
      id: 'inc-1',
      title: 'AI Service Degradation',
      status: 'INVESTIGATING',
      impact: 'MINOR',
      componentId: 'comp-3',
      message: 'Investigating increased latency',
      startedAt: new Date(),
    };
    export const mockAdminUser = { id: 'admin-1', role: 'ADMIN', firmId: 'firm-1' };
    export const mockRegularUser = { id: 'user-1', role: 'USER', firmId: 'firm-1' };
    ```
  - [ ] Add factory functions for generating test data variations
  - [ ] Location: `services/gateway/__tests__/fixtures/status.fixtures.ts`

- [ ] **Task 28: Unit Tests - Status Service** (AC: 6)
  - [ ] Test status aggregation logic (worst component status = overall status)
  - [ ] Test incident lifecycle management (create → update → resolve)
  - [ ] Test notification triggers (verify channels called per severity)
  - [ ] Mock external services (PagerDuty, Slack, Email)
  - [ ] Location: `services/gateway/src/services/__tests__/status.service.test.ts`

- [ ] **Task 29: Integration Tests - Status API** (AC: 6)
  - [ ] Seed test database with status fixtures before tests
  - [ ] Test GraphQL queries (systemStatus, statusHistory, statusComponent)
  - [ ] Test mutations (createIncident, resolveIncident, updateComponentStatus)
  - [ ] Test authorization (admin only mutations return 403 for regular users)
  - [ ] Test public queries work without authentication
  - [ ] Location: `services/gateway/__tests__/integration/status.test.ts`

- [ ] **Task 30: Component Tests - Status Page** (AC: 6)
  - [ ] Create MSW handlers for mocking GraphQL status queries
  - [ ] Test StatusBanner renders correct state for each ComponentStatus
  - [ ] Test ComponentList displays all components with correct colors
  - [ ] Test IncidentTimeline ordering (newest first)
  - [ ] Test SubscribeForm validation (email format, required fields)
  - [ ] Location: `apps/web/src/components/status/__tests__/`

- [ ] **Task 31: E2E Tests - Monitoring Flow** (AC: 1-6)
  - [ ] Seed E2E database with test components and incidents
  - [ ] Test status page loads publicly (no auth required)
  - [ ] Test incident creation flow (admin login → create → verify display)
  - [ ] Test status updates reflect in UI within 30 seconds
  - [ ] Test subscription flow (submit email → verify success message)
  - [ ] Location: `tests/e2e/status-page.spec.ts`

## Dev Notes

### Previous Story Insights

**From Story 3.8 (Document System Testing and Performance - Done):**

- New Relic APM is already configured for both gateway and ai-service
- `newrelic.js` configuration files exist with AI-specific attributes
- Custom events and transaction naming rules established
- Application logging forwarding enabled
  [Source: services/ai-service/newrelic.js]
  [Source: services/gateway/newrelic.js]

**From Story 2.14 (AI Service Infrastructure):**

- AlertsManager exists with PagerDuty, Slack, Email integration
- HealthChecker monitors database, Redis, Claude API, Skills API
- Alert thresholds defined for service health, error rates, costs
- Daily summary reports implemented
  [Source: services/ai-service/src/monitoring/AlertsManager.ts]
  [Source: services/ai-service/src/monitoring/HealthChecker.ts]

**From Story 4.7 (Task Analytics and Optimization):**

- ROI and performance metrics services established
- Pattern for aggregating metrics from multiple sources
  [Source: services/gateway/src/services/roi-calculator.service.ts]

### Existing Monitoring Infrastructure

| Component           | Location                                            | Status | Coverage          |
| ------------------- | --------------------------------------------------- | ------ | ----------------- |
| AlertsManager       | services/ai-service/src/monitoring/AlertsManager.ts | EXISTS | AI service alerts |
| HealthChecker       | services/ai-service/src/monitoring/HealthChecker.ts | EXISTS | Service health    |
| New Relic (AI)      | services/ai-service/newrelic.js                     | EXISTS | AI service APM    |
| New Relic (Gateway) | services/gateway/newrelic.js                        | EXISTS | Gateway APM       |
| Token Alerts        | services/ai-service/src/monitoring/token-alerts.ts  | EXISTS | Token usage       |
| Cost Tracker        | services/ai-service/src/monitoring/CostTracker.ts   | EXISTS | AI costs          |

### New Relic Dashboard Configuration

```json
// Dashboard JSON structure for New Relic API
{
  "name": "Legal Platform - Service Health",
  "description": "Service health monitoring dashboard",
  "pages": [
    {
      "name": "Overview",
      "widgets": [
        {
          "title": "Service Status",
          "visualization": "viz.billboard",
          "configuration": {
            "nrqlQueries": [
              {
                "query": "SELECT latest(healthy) FROM ServiceHealth FACET serviceName"
              }
            ]
          }
        }
      ]
    }
  ]
}
```

### Alert Policy Configuration

```json
// NRQL Alert Condition
{
  "name": "High Error Rate - Gateway",
  "type": "static",
  "nrql": {
    "query": "SELECT percentage(count(*), WHERE httpResponseCode >= 500) FROM Transaction WHERE appName = 'legal-platform-gateway'"
  },
  "critical": {
    "threshold": 2,
    "thresholdDuration": 300,
    "operator": "above"
  },
  "warning": {
    "threshold": 0.5,
    "thresholdDuration": 300,
    "operator": "above"
  }
}
```

### Incident Classification Matrix

| Severity | Impact                    | Response Time | Examples                      |
| -------- | ------------------------- | ------------- | ----------------------------- |
| SEV1     | Complete outage           | < 15 min      | All services down, data loss  |
| SEV2     | Major feature unavailable | < 30 min      | AI service down, auth failure |
| SEV3     | Degraded performance      | < 2 hours     | Slow responses, high latency  |
| SEV4     | Minor issues              | < 24 hours    | UI bugs, cosmetic issues      |

### Status Page Design

```
+----------------------------------------+
|  Legal Platform Status                  |
|  ✅ All Systems Operational             |
+----------------------------------------+

Components:
  ✅ Web Application      Operational
  ✅ API                  Operational
  ✅ AI Services          Operational
  ✅ Document Storage     Operational
  ✅ Email Integration    Operational

Past Incidents:
  [Dec 4, 2025] API Degraded Performance
    Resolved - Response times normalized

  [Dec 1, 2025] Scheduled Maintenance
    Completed - Database migration

[Subscribe to Updates]
```

### File Locations

```
infrastructure/
├── newrelic/
│   ├── dashboards/
│   │   ├── service-health.json         # NEW
│   │   ├── performance.json            # NEW
│   │   ├── errors.json                 # NEW
│   │   ├── activity.json               # NEW
│   │   └── ai-operations.json          # NEW
│   ├── alerts/
│   │   ├── downtime-policy.json        # NEW
│   │   ├── degradation-policy.json     # NEW
│   │   ├── error-policy.json           # NEW
│   │   ├── budget-policy.json          # NEW
│   │   └── security-policy.json        # NEW
│   └── logging/
│       └── config.json                 # NEW
├── pagerduty/
│   └── schedules/
│       └── primary-oncall.json         # NEW

docs/operations/
├── runbooks/
│   ├── incident-response.md            # NEW
│   ├── gateway-service.md              # NEW
│   ├── ai-service.md                   # NEW
│   ├── database.md                     # NEW
│   └── redis.md                        # NEW
├── on-call/
│   ├── rotation.md                     # NEW
│   └── handbook.md                     # NEW
└── log-search-guide.md                 # NEW

services/gateway/src/
├── routes/
│   └── status.routes.ts                # NEW
├── services/
│   ├── status.service.ts               # NEW
│   └── status-notification.service.ts  # NEW
├── workers/
│   └── status-sync.worker.ts           # NEW
└── graphql/
    ├── schema/
    │   └── status.graphql              # NEW
    └── resolvers/
        └── status.resolvers.ts         # NEW

apps/web/src/
├── app/
│   └── status/
│       └── page.tsx                    # NEW
└── components/
    └── status/
        ├── StatusBanner.tsx            # NEW
        ├── ComponentList.tsx           # NEW
        ├── IncidentTimeline.tsx        # NEW
        └── SubscribeForm.tsx           # NEW

packages/database/prisma/
├── schema.prisma                       # ADD StatusComponent, StatusIncident, StatusUpdate models
└── seed-status.ts                      # NEW - Status component seed data

services/gateway/__tests__/
├── fixtures/
│   └── status.fixtures.ts              # NEW - Test fixtures and factories
└── integration/
    └── status.test.ts                  # NEW - Integration tests

services/gateway/src/services/__tests__/
└── status.service.test.ts              # NEW - Unit tests

apps/web/src/components/status/__tests__/
├── StatusBanner.test.tsx               # NEW
├── ComponentList.test.tsx              # NEW
├── IncidentTimeline.test.tsx           # NEW
└── SubscribeForm.test.tsx              # NEW

tests/e2e/
└── status-page.spec.ts                 # NEW - E2E tests
```

### Testing Requirements

**Test Frameworks:**
| Layer | Framework | Config Location |
|-------|-----------|-----------------|
| Backend Unit | Jest 29+ | `services/gateway/jest.config.js` |
| Backend Integration | Jest + Supertest | `services/gateway/jest.config.js` |
| Frontend Unit | Jest + React Testing Library 14+ | `apps/web/jest.config.js` |
| E2E | Playwright 1.41+ | `playwright.config.ts` |

**Coverage Target:** 80% for new code (enforced by CI)

**Test Patterns:**

- **Unit tests**: Mock all external dependencies, test pure logic
- **Integration tests**: Use test database, seed with fixtures, cleanup after
- **Component tests**: Use MSW for API mocking, test user interactions
- **E2E tests**: Use seeded database, test complete user flows

**Status Page Specific Testing:**

```typescript
// Example unit test pattern
describe('StatusService', () => {
  it('returns MAJOR_OUTAGE when any component is down', () => {
    const components = [{ status: 'OPERATIONAL' }, { status: 'MAJOR_OUTAGE' }];
    expect(aggregateStatus(components)).toBe('MAJOR_OUTAGE');
  });
});
```

[Source: docs/architecture/testing-strategy.md - Testing pyramid: 70% unit, 20% integration, 10% E2E]

### Security Considerations

1. **Status Page Access:** Public read access, admin-only write
2. **Incident Details:** No sensitive information in public messages
3. **Admin Authentication:** Require admin role for mutations
4. **Rate Limiting:** Limit subscribe requests to prevent abuse
5. **PagerDuty API Keys:** Store in environment variables only

### Performance Targets

| Operation                 | Target  | Notes                   |
| ------------------------- | ------- | ----------------------- |
| Status page load          | < 1s    | Public, cached          |
| Health check poll         | < 200ms | Internal                |
| Status update propagation | < 1 min | From health check to UI |
| Dashboard refresh         | < 5s    | New Relic API           |

### Rollback Plan

**N/A - Monitoring only.**

This story adds monitoring infrastructure without modifying core application logic. Individual components can be disabled without affecting platform functionality:

1. **Dashboards:** Can be deleted from New Relic without code changes
2. **Alerts:** Can be disabled in New Relic/PagerDuty UI
3. **Status Page:** Feature flag `STATUS_PAGE_ENABLED` controls visibility
4. **Log Configuration:** Revert to existing Winston setup

## Testing

**Test Location:** Following project testing patterns

| Test Type            | Location                                    | Framework        |
| -------------------- | ------------------------------------------- | ---------------- |
| Backend Service Unit | `services/gateway/src/services/__tests__/`  | Jest             |
| GraphQL Integration  | `services/gateway/__tests__/integration/`   | Jest + Supertest |
| Frontend Components  | `apps/web/src/components/status/__tests__/` | Jest + RTL       |
| E2E                  | `tests/e2e/status-page.spec.ts`             | Playwright       |

**Coverage Target:** 80% for new code

## Change Log

| Date       | Version | Description                                                                                                                                                                                       | Author             |
| ---------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------ |
| 2025-12-05 | 1.0     | Initial story draft from Epic 5.8 requirements                                                                                                                                                    | Bob (Scrum Master) |
| 2025-12-05 | 1.1     | Validation fixes: Task 11 updated to use existing logger paths, Task 21 added migration/seed details, Phase 8 enhanced with test fixtures task, Testing Requirements expanded with inline details | Sarah (PO)         |

---

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes List

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

---

## QA Results

_To be filled by QA Agent_
