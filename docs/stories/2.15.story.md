# Story 2.15: Test Architecture Refactoring - Dependency Injection for Database Services

## Status

Done

## Story

**As a** development team maintaining the legal platform,
**I want** database-dependent services to use dependency injection for testability,
**So that** we can write reliable unit tests without Jest mocking issues and improve test coverage.

## Business Value

- **Test Reliability:** Eliminate flaky tests caused by Jest mocking architecture issues
- **Test Coverage:** Achieve 80%+ coverage for AC6 Template Usage Tracking (currently 0%)
- **Maintainability:** Establish testing patterns for all future database-dependent services
- **Development Velocity:** Reduce debugging time for test failures (currently ~2 hours per AC6 test fix attempt)
- **Code Quality:** Enable proper unit testing isolation following industry best practices

## Dependencies

- âœ… Story 2.12.1 (Adaptive Skills & Romanian Templates) - Service implementation complete
- ðŸ“„ Jest mocking architecture analysis from QA Review #2 & #3
- ðŸ“„ Dependency injection patterns documentation

## Background

### Problem Statement

From Story 2.12.1 QA Review #3:

- AC6 `TemplateUsageTrackingService` has 14 unit tests, all failing
- Error: `TypeError: mockQuery.mockResolvedValueOnce is not a function`
- **Root Cause:** Jest cannot intercept database client imports through TypeScript path aliases (`@/lib/database/client`)
- **Attempted Fixes:** Inline mocks, factory functions, manual `__mocks__`, module imports - all failed
- **Conclusion:** Service implementation is correct, but test architecture prevents proper mocking

### Current Architecture

```typescript
// Service implementation (hard dependency)
import { query } from '@/lib/database/client';

export class TemplateUsageTrackingService {
  async trackUsage(log: CreateTemplateUsageLog): Promise<void> {
    await query('INSERT INTO template_usage_logs ...', [...]); // Cannot mock this
  }
}
```

### Target Architecture (Dependency Injection)

```typescript
// Service implementation (injectable dependency)
import type { DatabaseClient } from '@/lib/database/types';

export class TemplateUsageTrackingService {
  constructor(private db: DatabaseClient = getDefaultClient()) {}

  async trackUsage(log: CreateTemplateUsageLog): Promise<void> {
    await this.db.query('INSERT INTO template_usage_logs ...', [...]); // Easily mocked
  }
}

// Test file
const mockDb = { query: jest.fn() };
const service = new TemplateUsageTrackingService(mockDb);
mockDb.query.mockResolvedValueOnce({ rows: [] }); // Works perfectly!
```

## Acceptance Criteria

### 1. Define Database Client Interface

**Given** services need a consistent database abstraction
**When** implementing dependency injection
**Then** the system should:

- [ ] Create `DatabaseClient` TypeScript interface in `@legal-platform/types`
- [ ] Interface includes: `query<T>(sql, params)`, `transaction()`, `getClient()`
- [ ] Document interface with JSDoc examples
- [ ] Export from `packages/shared/types/src/database.ts`

### 2. Refactor TemplateUsageTrackingService (Priority 1)

**Given** AC6 tests are 0% passing due to mocking issues
**When** refactoring the service
**Then** the implementation should:

- [ ] Accept `DatabaseClient` as optional constructor parameter
- [ ] Default to `getDefaultDatabaseClient()` when not provided
- [ ] Replace all `import { query } from '@/lib/database/client'` with `this.db.query`
- [ ] Maintain backward compatibility (no breaking changes to API)
- [ ] All 14 existing tests pass with proper mocking

### 3. Refactor PatternExtractionService (Priority 2)

**Given** future database operations may be added
**When** applying dependency injection pattern
**Then** the implementation should:

- [ ] Follow same pattern as TemplateUsageTrackingService
- [ ] Maintain all 13 existing tests passing
- [ ] Add database client injection support

### 4. Refactor DiscoveryStatusService (Priority 3)

**Given** admin dashboard uses database client
**When** applying dependency injection pattern
**Then** the implementation should:

- [ ] Refactor to accept DatabaseClient in constructor
- [ ] Update all database queries to use injected client
- [ ] Maintain all existing tests passing

### 5. Create Testing Utilities

**Given** developers need easy test setup
**When** writing new database-dependent tests
**Then** provide test utilities:

- [ ] `createMockDatabaseClient()` factory function
- [ ] Pre-configured mock responses for common queries
- [ ] Example test files demonstrating pattern
- [ ] Update `docs/architecture/testing-strategy.md` with DI patterns

### 6. Achieve Test Coverage Goals

**Given** services are refactored with dependency injection
**When** running test suite
**Then** test coverage should meet:

- [ ] TemplateUsageTrackingService: 80%+ coverage (was 0%)
- [ ] PatternExtractionService: 80%+ coverage (currently 100%)
- [ ] DiscoveryStatusService: 80%+ coverage
- [ ] All tests pass consistently (no flaky tests)
- [ ] No Jest mocking errors in CI/CD pipeline

## Technical Approach

### Phase 1: Foundation (Days 1-2)

**Day 1: Interface Definition**

```typescript
// packages/shared/types/src/database.ts
export interface DatabaseClient {
  query<T = any>(sql: string, params?: any[]): Promise<QueryResult<T>>;
  transaction<T>(callback: (client: DatabaseClient) => Promise<T>): Promise<T>;
  getClient(): Promise<PoolClient>;
  closePool(): Promise<void>;
}

export interface QueryResult<T = any> {
  rows: T[];
  rowCount: number;
  command?: string;
}
```

**Day 2: Default Client Implementation**

```typescript
// apps/web/src/lib/database/client.ts
import type { DatabaseClient } from '@legal-platform/types';

class PostgresDatabaseClient implements DatabaseClient {
  async query<T>(sql: string, params?: any[]): Promise<QueryResult<T>> {
    const pool = getPool();
    return pool.query<T>(sql, params);
  }
  // ... other methods
}

export function getDefaultDatabaseClient(): DatabaseClient {
  return new PostgresDatabaseClient();
}
```

### Phase 2: Service Refactoring (Days 3-5)

**Refactoring Pattern (applied to each service):**

1. **Add constructor with optional dependency:**

```typescript
export class ServiceName {
  private db: DatabaseClient;

  constructor(db?: DatabaseClient) {
    this.db = db || getDefaultDatabaseClient();
  }
}
```

2. **Replace direct imports:**

```typescript
// BEFORE
import { query } from '@/lib/database/client';
await query('SELECT ...', []);

// AFTER
await this.db.query('SELECT ...', []);
```

3. **Update tests:**

```typescript
// Create mock once, reuse across tests
const mockDb: DatabaseClient = {
  query: jest.fn(),
  transaction: jest.fn(),
  getClient: jest.fn(),
  closePool: jest.fn(),
};

const service = new ServiceName(mockDb);
(mockDb.query as jest.Mock).mockResolvedValueOnce({ rows: [...] });
```

### Phase 3: Testing & Documentation (Days 6-7)

- Create test utility library
- Update all test files
- Run full test suite and fix any issues
- Document pattern in architecture docs
- Create example test files

## Testing Strategy

### Unit Tests Required

```typescript
describe('TemplateUsageTrackingService with DI', () => {
  let mockDb: DatabaseClient;
  let service: TemplateUsageTrackingService;

  beforeEach(() => {
    mockDb = {
      query: jest.fn(),
      transaction: jest.fn(),
      getClient: jest.fn(),
      closePool: jest.fn(),
    };
    service = new TemplateUsageTrackingService(mockDb);
  });

  it('should use injected database client', async () => {
    (mockDb.query as jest.Mock).mockResolvedValueOnce({ rows: [], rowCount: 1 });

    await service.trackUsage({
      template_id: 'test-123',
      variables_provided: {},
      success: true,
    });

    expect(mockDb.query).toHaveBeenCalledWith(
      expect.stringContaining('INSERT INTO template_usage_logs'),
      expect.arrayContaining(['test-123'])
    );
  });

  it('should use default client when none provided', () => {
    const defaultService = new TemplateUsageTrackingService();
    expect(defaultService).toBeInstanceOf(TemplateUsageTrackingService);
    // Service should work without errors
  });
});
```

### Integration Tests

- Test services with real PostgreSQL test database
- Verify transaction support works correctly
- Test connection pool behavior

### Regression Tests

- All existing tests must continue passing
- No breaking changes to public APIs
- Services work identically in production

## Success Metrics

### Launch Criteria (Must Have)

- âœ… DatabaseClient interface defined and exported
- âœ… All 3 services refactored (Template Usage, Pattern Extraction, Discovery Status)
- âœ… All 14 AC6 tests passing (currently 0/14)
- âœ… Test coverage â‰¥80% for refactored services
- âœ… Documentation updated

### Quality Gates

- ðŸ“Š Zero test failures in CI/CD pipeline
- ðŸ“Š No increase in production error rates
- ðŸ“Š Test execution time <5 seconds for unit tests
- ðŸ“Š 100% backward compatibility maintained

### Post-Launch Metrics (30 days)

- ðŸŽ¯ Zero test flakiness reports
- ðŸŽ¯ All new database services follow DI pattern
- ðŸŽ¯ Developer satisfaction: "easy to test" feedback

## Risk Mitigation

| Risk                              | Impact | Likelihood | Mitigation                                               |
| --------------------------------- | ------ | ---------- | -------------------------------------------------------- |
| Breaking changes to existing code | High   | Medium     | Thorough regression testing, optional constructor params |
| Performance degradation           | Medium | Low        | Benchmark before/after, DI has negligible overhead       |
| Complex transaction handling      | Medium | Medium     | Start simple, add transaction support incrementally      |
| Team adoption challenges          | Low    | Low        | Clear documentation, example code, pair programming      |

## Implementation Plan

### Week 1: Foundation & Priority Services

**Day 1-2: Interface & Infrastructure**

- Define DatabaseClient interface
- Implement PostgresDatabaseClient wrapper
- Create test utilities

**Day 3-4: TemplateUsageTrackingService (Priority 1)**

- Refactor service with DI
- Fix all 14 failing tests
- Verify 80%+ coverage

**Day 5: PatternExtractionService (Priority 2)**

- Apply DI pattern
- Verify 13 existing tests still pass
- Add any missing tests

**Day 6-7: DiscoveryStatusService + Documentation**

- Refactor DiscoveryStatusService
- Update architecture documentation
- Create testing examples
- Final regression testing

## Definition of Done

- [ ] All 6 acceptance criteria met
- [ ] DatabaseClient interface implemented and exported
- [ ] All 3 services refactored with dependency injection
- [ ] TemplateUsageTrackingService: 14/14 tests passing (was 0/14)
- [ ] PatternExtractionService: 13/13 tests passing (maintained)
- [ ] DiscoveryStatusService: All tests passing
- [ ] Test coverage â‰¥80% for all refactored services
- [ ] Zero breaking changes to public APIs
- [ ] Documentation updated (testing-strategy.md, coding-standards.md)
- [ ] Example test files created
- [ ] All existing tests continue passing
- [ ] CI/CD pipeline green

## Files to Modify

### New Files

- `packages/shared/types/src/database.ts` - DatabaseClient interface
- `apps/web/src/lib/database/client-impl.ts` - PostgresDatabaseClient implementation
- `apps/web/src/lib/testing/mock-database.ts` - Test utilities
- `docs/architecture/dependency-injection-pattern.md` - DI pattern guide
- `apps/web/src/lib/services/__tests__/example-di-test.ts` - Example test file

### Modified Files

- `apps/web/src/lib/services/template-usage-tracking.service.ts`
- `apps/web/src/lib/services/template-usage-tracking.service.test.ts`
- `apps/web/src/lib/services/pattern-extraction.service.ts`
- `apps/web/src/lib/services/pattern-extraction.service.test.ts`
- `apps/web/src/lib/services/discovery-status.service.ts`
- `apps/web/src/lib/services/discovery-status.service.test.ts`
- `apps/web/src/lib/database/client.ts` - Add getDefaultDatabaseClient()
- `packages/shared/types/src/index.ts` - Export database types
- `docs/architecture/testing-strategy.md` - Add DI testing patterns
- `docs/architecture/coding-standards.md` - Add DI best practices

## Follow-up Stories

### Story 2.16: Extend DI Pattern to All Services

- Apply dependency injection to remaining services
- Refactor API route handlers
- Create service container/registry

### Story 2.17: Advanced Testing Infrastructure

- Integration test framework with test database
- Transaction rollback for fast tests
- Test data factories and fixtures

## Integration with Story 2.12.1

This story **unblocks** Story 2.12.1 from production deployment by:

1. Resolving AC6 test failures (0/14 â†’ 14/14 passing)
2. Enabling proper test coverage measurement
3. Removing "test architecture issue" blocker from QA gate

## Estimated Effort

- **Development:** 5-7 days
- **Testing:** 2 days
- **Documentation:** 1 day
- **Total:** 8-10 days (1.5-2 weeks)

## Priority

**High** - Blocks Story 2.12.1 production deployment and affects all future database-dependent services

---

**Story Status:** Draft
**Created:** 2025-11-19
**Author:** James (Dev Agent)
**Epic:** 2.0 - Core Legal Skills Development
**Story Type:** Technical Debt / Infrastructure
**Priority:** High
**Estimated Effort:** 8-10 days
