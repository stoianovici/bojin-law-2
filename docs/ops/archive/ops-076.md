# OPS-076: Proactive Briefings Integration

**Status:** Open | **Priority:** P2-Medium | **Type:** Feature
**Created:** 2025-12-20 | **Depends on:** OPS-066, OPS-071, OPS-077

> **Note (OPS-077):** Morning briefings use `morningBriefingService` wrapper created in OPS-077,
> which wraps the existing `morning-briefing.worker.ts` logic.
>
> **SuggestionWidget Deprecation:** The current `SuggestionWidget` is hidden and will be removed.
> The AssistantPill (OPS-071) replaces it entirely. Do NOT reference `suggestionService` - instead
> use the briefing handler's proactive alerts system.

## Summary

Integrate proactive briefings and alerts into the AI assistant, replacing the old suggestion system.

## Background

The assistant should proactively:

- Show morning briefing when first opened each day
- Alert about upcoming deadlines
- Notify about new emails requiring attention
- Suggest follow-ups based on patterns

This leverages existing MorningBriefingService and SuggestionService.

## Requirements

### Integration Points

```typescript
// services/gateway/src/services/intent-handlers/briefing.handler.ts

import { prisma } from '@legal-platform/database';
import { morningBriefingService } from '../morning-briefing.service';
import type { AssistantContext, UserContext, HandlerResult, AIMessage } from './types'; // From OPS-072

// NOTE: The old SuggestionWidget is deprecated and will be removed.
// This handler replaces its functionality with the proactive alerts system.

// ============================================================================
// Types
// ============================================================================

interface BriefingResult {
  type: 'morning' | 'deadline' | 'email' | 'followup';
  content: string;
  urgency: 'low' | 'medium' | 'high';
  relatedEntityId?: string;
  relatedEntityType?: string;
  actionSuggestion?: string;
}

// ============================================================================
// Handler
// ============================================================================

export class BriefingHandler {
  /**
   * Get morning briefing for user.
   * Called when assistant opens for the first time each day.
   */
  async getMorningBriefing(userContext: UserContext): Promise<HandlerResult> {
    // Note: morningBriefingService.generateBriefing takes a UserContext object
    // Interface: { userId: string; firmId: string }
    const briefing = await morningBriefingService.generateBriefing(userContext);

    const sections = [];

    // Urgent items
    // Note: MorningBriefing interface from morning-briefing.service.ts:
    // - urgentTasks: BriefingTask[] with {id, title, priority, dueDate, caseTitle, caseNumber, isOverdue}
    // - todayTasks: BriefingTask[]
    // - upcomingDeadlines: BriefingDeadline[] with {id, title, dueDate, caseTitle, caseNumber, daysUntilDue}
    // - unreadEmailsCount: number
    // - importantEmails: BriefingEmail[]
    // - generatedAt: Date
    // - aiSummary?: string
    if (briefing.urgentTasks.length > 0) {
      sections.push(
        `**Urgente azi:**\n${briefing.urgentTasks
          .map((t) => `• ${t.title}${t.caseTitle ? ` - ${t.caseTitle}` : ''}`)
          .join('\n')}`
      );
    }

    // Today's tasks
    if (briefing.todayTasks.length > 0) {
      sections.push(
        `**De făcut azi:**\n${briefing.todayTasks.map((t) => `• ${t.title}`).join('\n')}`
      );
    }

    // Upcoming deadlines
    if (briefing.upcomingDeadlines.length > 0) {
      sections.push(
        `**Termene apropiate:**\n${briefing.upcomingDeadlines
          .map(
            (d) =>
              `• În ${d.daysUntilDue} zile: ${d.title}${d.caseTitle ? ` (${d.caseTitle})` : ''}`
          )
          .join('\n')}`
      );
    }

    // New emails (note: property is unreadEmailsCount, not unreadEmails)
    if (briefing.unreadEmailsCount > 0) {
      sections.push(`**Emailuri noi:** ${briefing.unreadEmailsCount} necitite`);
    }

    if (sections.length === 0) {
      return {
        success: true,
        message: 'Bună dimineața! Nu aveți sarcini urgente sau termene apropiate.',
      };
    }

    return {
      success: true,
      data: briefing,
      message: `Bună dimineața! Iată rezumatul zilei:\n\n${sections.join('\n\n')}`,
    };
  }

  /**
   * Get proactive alerts based on current context.
   * Called periodically or on context change.
   */
  async getProactiveAlerts(
    context: AssistantContext,
    userContext: UserContext
  ): Promise<BriefingResult[]> {
    const alerts: BriefingResult[] = [];

    // Check for deadline alerts
    const upcomingDeadlines = await this.checkDeadlineAlerts(userContext);
    alerts.push(...upcomingDeadlines);

    // Check for unanswered emails
    const unansweredEmails = await this.checkUnansweredEmails(userContext);
    alerts.push(...unansweredEmails);

    // Check for case-specific alerts if in case context
    if (context.currentCaseId) {
      const caseAlerts = await this.checkCaseAlerts(context.currentCaseId, userContext);
      alerts.push(...caseAlerts);
    }

    return alerts;
  }

  /**
   * Generate proactive messages based on alerts.
   * Replaces the old suggestionService.getContextualSuggestions approach.
   */
  async getProactiveMessages(
    context: AssistantContext,
    userContext: UserContext
  ): Promise<AIMessage[]> {
    const alerts = await this.getProactiveAlerts(context, userContext);

    return alerts.map((alert, index) => ({
      id: `proactive-${Date.now()}-${index}`,
      role: 'Assistant' as const,
      content: alert.content,
      intent: this.mapAlertTypeToIntent(alert.type),
      proposedAction: alert.actionSuggestion
        ? {
            type: alert.type,
            displayText: alert.actionSuggestion,
            payload: {
              entityId: alert.relatedEntityId,
              entityType: alert.relatedEntityType,
            },
            status: 'Proposed' as const,
            requiresConfirmation: false, // Proactive alerts are informational
          }
        : undefined,
      createdAt: new Date().toISOString(),
    }));
  }

  private mapAlertTypeToIntent(type: string): string {
    const mapping: Record<string, string> = {
      deadline: 'QueryTasks',
      email: 'SearchEmails',
      followup: 'GeneralChat',
      morning: 'MorningBriefing',
    };
    return mapping[type] || 'GeneralChat';
  }

  // Private helpers

  private async checkDeadlineAlerts(userContext: UserContext): Promise<BriefingResult[]> {
    const tasks = await prisma.task.findMany({
      where: {
        assignedTo: userContext.userId,
        status: 'Pending',
        dueDate: {
          gte: new Date(),
          lte: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000), // 3 days
        },
      },
      include: { case: true },
      orderBy: { dueDate: 'asc' },
      take: 5,
    });

    return tasks.map((t) => ({
      type: 'deadline' as const,
      content: `Termen apropiat: ${t.title} (${t.case?.title || 'Fără dosar'}) - ${this.formatDate(t.dueDate)}`,
      urgency: this.getUrgency(t.dueDate),
      relatedEntityId: t.id,
      relatedEntityType: 'Task',
      actionSuggestion: 'Vezi detalii',
    }));
  }

  private async checkUnansweredEmails(userContext: UserContext): Promise<BriefingResult[]> {
    // Note: Email model does NOT have a 'direction' field.
    // Email model has: from (Json: {name?, address}), receivedDateTime, conversationId
    // To determine if an email is "received" vs "sent", we need the user's email address
    // and compare with the 'from' field.

    // Step 1: Get user's email address
    const user = await prisma.user.findUnique({
      where: { id: userContext.userId },
      select: { email: true },
    });

    if (!user?.email) return [];

    // Step 2: Get conversations where user has sent a reply (user is in 'from')
    const conversationsWithReplies = await this.getConversationsWithReplies(
      userContext.userId,
      user.email
    );

    // Step 3: Find old received emails (where user is NOT the sender)
    // and the conversation has no reply from user
    //
    // NOTE: Prisma JSON path filtering may have limitations. If the path filtering
    // doesn't work reliably, use raw SQL or filter in JavaScript after query:
    //   const allEmails = await prisma.email.findMany({...});
    //   const oldEmails = allEmails.filter(e => {
    //     const from = e.from as { address: string };
    //     return from.address !== user.email;
    //   });
    const oldEmails = await prisma.email.findMany({
      where: {
        userId: userContext.userId,
        receivedDateTime: { lte: new Date(Date.now() - 48 * 60 * 60 * 1000) },
        // Exclude conversations where user already replied
        conversationId: { notIn: conversationsWithReplies },
      },
      take: 10, // Fetch extra to allow for filtering
    });

    // Filter out emails sent by the user (JavaScript fallback for JSON field)
    const receivedEmails = oldEmails
      .filter((e) => {
        const from = e.from as { address: string };
        return from.address.toLowerCase() !== user.email.toLowerCase();
      })
      .slice(0, 3);

    // Note: Email model has `from` (Json: {name?, address}) not `senderName`
    return receivedEmails.map((e) => {
      const fromData = e.from as { name?: string; address: string };
      return {
        type: 'email' as const,
        content: `Email fără răspuns de la ${fromData.name || fromData.address}: "${e.subject}"`,
        urgency: 'medium' as const,
        relatedEntityId: e.id,
        relatedEntityType: 'Email',
        actionSuggestion: 'Redactează răspuns',
      };
    });
  }

  /**
   * Get conversation IDs where user has sent at least one reply
   * (i.e., emails where the user's email is in the 'from' field)
   */
  private async getConversationsWithReplies(userId: string, userEmail: string): Promise<string[]> {
    // Find emails where user is the sender (their email matches from.address)
    const sentEmails = await prisma.email.findMany({
      where: {
        userId,
        from: { path: ['address'], equals: userEmail },
        conversationId: { not: '' },
      },
      select: { conversationId: true },
      distinct: ['conversationId'],
    });
    return sentEmails.map((e) => e.conversationId);
  }

  private async checkCaseAlerts(
    caseId: string,
    userContext: UserContext
  ): Promise<BriefingResult[]> {
    // Case-specific alerts (missing documents, incomplete tasks, etc.)
    return [];
  }

  private getUrgency(dueDate: Date): 'low' | 'medium' | 'high' {
    const daysUntil = (dueDate.getTime() - Date.now()) / (24 * 60 * 60 * 1000);
    if (daysUntil <= 1) return 'high';
    if (daysUntil <= 3) return 'medium';
    return 'low';
  }

  // Note: Task model uses dueDate (Date), Email model uses receivedDateTime (Date)
  private formatDate(date: Date | null): string {
    if (!date) return 'Nespecificat';
    return date.toLocaleDateString('ro-RO', { weekday: 'short', day: 'numeric', month: 'short' });
  }
}

export const briefingHandler = new BriefingHandler();
```

### Frontend Integration

In `AssistantPill.tsx`:

```typescript
// On first open of the day, show morning briefing
useEffect(() => {
  if (isOpen && !hasShownBriefingToday) {
    requestBriefing();
  }
}, [isOpen]);
```

## Acceptance Criteria

- [ ] BriefingHandler class implemented
- [ ] Morning briefing shows on first open
- [ ] Deadline alerts generated proactively
- [ ] Unanswered email detection works
- [ ] Old suggestions converted to assistant format
- [ ] Urgency levels properly assigned
- [ ] Romanian output formatting
- [ ] Integration with AssistantPill component
- [ ] Unit tests

## Files to Create

- `services/gateway/src/services/intent-handlers/briefing.handler.ts`
- `services/gateway/src/services/intent-handlers/briefing.handler.test.ts`

## Files to Modify

- `apps/web/src/components/assistant/AssistantPill.tsx` (add briefing trigger)
- `apps/web/src/hooks/useAssistant.ts` (add briefing query)

## Session Log

### Session 1 - 2025-12-20

**Work Completed:**

1. **Created briefing.handler.ts** (`services/gateway/src/services/intent-handlers/briefing.handler.ts`)
   - Implements `BriefingHandler` class with:
     - `getMorningBriefing()` - Returns formatted briefing with urgent tasks, today's tasks, deadlines, and unread email count
     - `getProactiveAlerts()` - Returns deadline alerts, unanswered email alerts, and case-specific alerts
     - `getProactiveMessages()` - Converts alerts to AIMessage format for the assistant UI
   - Integrates with `morningBriefingService` from OPS-077
   - All output in Romanian

2. **Created briefing.handler.test.ts** - Comprehensive unit tests covering:
   - Morning briefing formatting
   - Deadline alert detection
   - Unanswered email detection
   - Case-specific alerts
   - Urgency calculation
   - Date formatting

3. **Updated GraphQL schema** (`services/gateway/src/graphql/schema/ai-assistant.graphql`)
   - Added `MorningBriefing`, `BriefingTask`, `BriefingDeadline` types
   - Added `morningBriefing` query

4. **Updated AI assistant resolvers** (`services/gateway/src/graphql/resolvers/ai-assistant.resolvers.ts`)
   - Added `morningBriefing` query resolver that calls `briefingHandler.getMorningBriefing()`

5. **Updated useAssistant hook** (`apps/web/src/hooks/useAssistant.ts`)
   - Added `GET_MORNING_BRIEFING` query
   - Added `MorningBriefingData` type
   - Added `requestBriefing()` function
   - Added `briefingLoading` state

6. **Updated AssistantPill.tsx** (`apps/web/src/components/assistant/AssistantPill.tsx`)
   - Added briefing trigger on first open of the day
   - Uses localStorage to track if briefing was shown today
   - Automatically requests briefing when assistant opens with no messages

**Preflight Status:**

- ✅ TypeScript compiles
- ✅ Prettier format check
- ⚠️ ESLint (non-blocking)
- ⚠️ Unit tests (non-blocking - unrelated MSAL crypto issue)
- ✅ Production build succeeds
- ✅ Web Docker build
- ✅ Gateway Docker build

**Status:** Implemented - Ready for verification
