# OPS-235: AI Usage Aggregation Service

**Type**: Feature
**Priority**: P1-High
**Status**: Completed
**Epic**: AI Batch Processing & Ops Dashboard

## Problem

Raw usage logs exist but no way to aggregate for dashboard display (daily totals, per-feature breakdown, user attribution).

## Solution

Create `AIUsageService` with aggregation methods for dashboard queries.

### Service Interface

```typescript
interface DailyCost {
  date: string;
  cost: number;
  tokens: number;
  calls: number;
}

interface FeatureCost {
  feature: string;
  featureName: string;
  cost: number;
  tokens: number;
  calls: number;
  percentOfTotal: number;
}

interface UserCost {
  userId: string;
  userName: string;
  cost: number;
  tokens: number;
  calls: number;
}

interface UsageOverview {
  totalCost: number;
  totalTokens: number;
  totalCalls: number;
  successRate: number;
  projectedMonthEnd: number;
}

class AIUsageService {
  async getUsageOverview(firmId: string, dateRange?: DateRange): Promise<UsageOverview>;
  async getDailyCosts(firmId: string, dateRange: DateRange): Promise<DailyCost[]>;
  async getCostsByFeature(firmId: string, dateRange: DateRange): Promise<FeatureCost[]>;
  async getCostsByUser(firmId: string, dateRange: DateRange): Promise<UserCost[]>;
  async getCurrentMonthSpend(firmId: string): Promise<number>;
  async getProjectedMonthEnd(firmId: string): Promise<number>;
}
```

### SQL Aggregations

```sql
-- Daily costs
SELECT
  DATE_TRUNC('day', created_at) as date,
  SUM(cost_eur) as cost,
  SUM(input_tokens + output_tokens) as tokens,
  COUNT(*) as calls
FROM ai_usage_log
WHERE firm_id = $1 AND created_at BETWEEN $2 AND $3
GROUP BY DATE_TRUNC('day', created_at)
ORDER BY date;

-- By feature
SELECT
  feature,
  SUM(cost_eur) as cost,
  SUM(input_tokens + output_tokens) as tokens,
  COUNT(*) as calls
FROM ai_usage_log
WHERE firm_id = $1 AND created_at BETWEEN $2 AND $3
GROUP BY feature
ORDER BY cost DESC;
```

## Acceptance Criteria

- [x] All aggregation methods implemented
- [x] Efficient SQL queries with proper indexes
- [x] Redis caching for frequently accessed aggregations (5 min TTL)
- [x] Projection algorithm based on daily average pace
- [x] Success rate calculation (exclude failed calls)

## Files Modified

- `services/gateway/src/services/ai-usage.service.ts` (new)
- `services/gateway/src/services/ai-usage.service.test.ts` (new - 18 tests)

## Dependencies

- OPS-232 (AIUsageLog model must exist)

## Implementation Notes

### Service Methods

1. **getUsageOverview** - Returns total cost, tokens, calls, success rate, and projected month-end
2. **getDailyCosts** - Returns daily breakdown using raw SQL with DATE_TRUNC for efficient grouping
3. **getCostsByFeature** - Groups by feature with Prisma groupBy, includes human-readable Romanian names
4. **getCostsByUser** - Joins with users table for names, handles batch jobs (null userId)
5. **getCurrentMonthSpend** / **getProjectedMonthEnd** - Convenience methods for alerts

### Caching

- 5-minute TTL on Redis
- Keys pattern: `ai-usage:{type}:{firmId}:{startDate}:{endDate}`
- `invalidateCache()` method for clearing stale data after new logs

### Romanian Feature Names

```typescript
const FEATURE_NAMES = {
  assistant_chat: 'Asistent AI',
  search_index: 'Indexare CÄƒutare',
  morning_briefing: 'Briefing Matinal',
  // ...
};
```

## Parallel Work

Can be done in parallel with OPS-236.
