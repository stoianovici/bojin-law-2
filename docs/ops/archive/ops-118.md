# OPS-118: Case Briefing Service

## Summary

Build a service that generates and caches per-case briefings - pre-computed summaries of case state (parties, deadlines, recent activity, document counts) for injection into AI system prompts when users are working in case context.

## Problem

When a user asks about a specific case, Claude must:

1. Call `search_cases` to find the case (if not explicit)
2. Call `get_case_summary` to understand it
3. Call `get_case_deadlines` for timeline info
4. Sometimes call `list_case_documents` for document context

This adds 2-4 tool calls (~1-2s each) before Claude can answer even basic questions like "când e următorul termen?" (when's the next deadline?).

## Solution

Pre-compute a `CaseBriefing` that contains:

- Basic case info (number, status, court)
- All parties involved
- Upcoming deadlines and recent events
- Document/email counts by category

This briefing is:

1. Generated on case data changes (event-driven)
2. Cached in Redis with 5-minute TTL
3. Injected into AI system prompt when `caseId` is present (~400-600 tokens)

## Architecture

```
Case Data Change (email, document, task)
    │
    └── Invalidate CaseBriefing cache
            │
            ▼
User Request (with caseId)
    │
    ▼
Load CaseBriefing
    │
    ├── Cache hit? → Return cached
    │
    └── Cache miss? → Generate
            │
            ├── Query Case details
            ├── Query Parties
            ├── Query Tasks (upcoming)
            ├── Query Recent events
            ├── Count Documents/Emails
            │
            ├── Format briefing text
            │
            ├── Save to DB + Redis
            │
            └── Return briefing
```

## Implementation

### Service

```typescript
// services/gateway/src/services/case-briefing.service.ts

export class CaseBriefingService {
  private readonly CACHE_TTL = 5 * 60; // 5 minutes
  private readonly BRIEFING_TOKEN_BUDGET = 600;

  /**
   * Get or generate case briefing
   */
  async getBriefing(caseId: string): Promise<CaseBriefingData> {
    // Try cache first
    const cached = await this.getFromCache(caseId);
    if (cached) {
      return cached;
    }

    // Generate fresh briefing
    const briefing = await this.generateBriefing(caseId);

    // Cache it
    await this.saveToCache(caseId, briefing);
    await this.saveToDB(caseId, briefing);

    return briefing;
  }

  /**
   * Get briefing formatted for AI system prompt
   */
  async getBriefingText(caseId: string): Promise<string> {
    const briefing = await this.getBriefing(caseId);
    return this.formatForPrompt(briefing);
  }

  /**
   * Invalidate briefing (called when case data changes)
   */
  async invalidate(caseId: string): Promise<void> {
    await redis.del(`case-briefing:${caseId}`);
  }

  /**
   * Generate fresh briefing from database
   */
  private async generateBriefing(caseId: string): Promise<CaseBriefingData> {
    const now = new Date();
    const thirtyDaysAgo = subDays(now, 30);
    const thirtyDaysFromNow = addDays(now, 30);

    // Get case with relations
    const caseData = await prisma.case.findUnique({
      where: { id: caseId },
      include: {
        client: true,
        actors: {
          include: { contact: true },
        },
        tasks: {
          where: {
            status: { not: 'Completed' },
            dueDate: { lte: thirtyDaysFromNow },
          },
          orderBy: { dueDate: 'asc' },
          take: 5,
        },
        _count: {
          select: {
            documents: true,
            emailLinks: true,
            tasks: true,
          },
        },
      },
    });

    if (!caseData) {
      throw new Error(`Case not found: ${caseId}`);
    }

    // Get recent events
    const recentEvents = await prisma.caseEvent.findMany({
      where: {
        caseId,
        occurredAt: { gte: thirtyDaysAgo },
      },
      orderBy: { occurredAt: 'desc' },
      take: 5,
    });

    // Count documents by category
    const documentCounts = await prisma.document.groupBy({
      by: ['category'],
      where: { caseLinks: { some: { caseId } } },
      _count: true,
    });

    // Count unread emails
    const unreadEmailCount = await prisma.email.count({
      where: {
        caseLinks: { some: { caseId } },
        isRead: false,
      },
    });

    // Build parties list
    const parties = [
      // Client first
      {
        role: 'Client',
        name: caseData.client?.name || 'Necunoscut',
        isClient: true,
      },
      // Other actors
      ...caseData.actors.map((actor) => ({
        role: actor.role,
        name: actor.contact?.name || actor.name || 'Necunoscut',
        isClient: false,
      })),
    ];

    // Find next deadline
    const nextDeadline = caseData.tasks[0]
      ? {
          date: caseData.tasks[0].dueDate!.toISOString(),
          description: caseData.tasks[0].title,
        }
      : undefined;

    return {
      caseNumber: caseData.caseNumber || '',
      title: caseData.title,
      status: caseData.status,
      court: caseData.court || undefined,

      parties,

      nextDeadline,
      recentEvents: recentEvents.map((e) => ({
        date: e.occurredAt.toISOString(),
        type: e.eventType,
        description: e.description,
      })),

      documentCount: caseData._count.documents,
      emailCount: caseData._count.emailLinks,
      unreadEmailCount,
      pendingTaskCount: caseData.tasks.length,

      documentsByCategory: Object.fromEntries(
        documentCounts.map((dc) => [dc.category || 'other', dc._count])
      ),
    };
  }

  /**
   * Format briefing for AI system prompt injection
   */
  private formatForPrompt(briefing: CaseBriefingData): string {
    const lines: string[] = [];

    // Header
    lines.push(`## Dosar: ${briefing.title}`);
    if (briefing.caseNumber) {
      lines.push(
        `Număr: ${briefing.caseNumber} | Status: ${this.translateStatus(briefing.status)}`
      );
    }
    if (briefing.court) {
      lines.push(`Instanță: ${briefing.court}`);
    }
    lines.push('');

    // Parties
    lines.push(`### Părți`);
    for (const party of briefing.parties) {
      const clientMark = party.isClient ? ' (client)' : '';
      lines.push(`- ${party.role}: ${party.name}${clientMark}`);
    }
    lines.push('');

    // Next deadline
    if (briefing.nextDeadline) {
      const date = format(new Date(briefing.nextDeadline.date), 'd MMMM yyyy', { locale: ro });
      lines.push(`### Următorul termen`);
      lines.push(`${date}: ${briefing.nextDeadline.description}`);
      lines.push('');
    }

    // Recent events (if any)
    if (briefing.recentEvents.length > 0) {
      lines.push(`### Activitate recentă`);
      for (const event of briefing.recentEvents.slice(0, 3)) {
        const date = format(new Date(event.date), 'd MMM', { locale: ro });
        lines.push(`- ${date}: ${event.description}`);
      }
      lines.push('');
    }

    // Counts
    lines.push(`### Conținut`);
    lines.push(`- Documente: ${briefing.documentCount}`);
    lines.push(
      `- Emailuri: ${briefing.emailCount}${briefing.unreadEmailCount > 0 ? ` (${briefing.unreadEmailCount} necitite)` : ''}`
    );
    lines.push(`- Sarcini active: ${briefing.pendingTaskCount}`);

    return lines.join('\n');
  }

  private translateStatus(status: string): string {
    const translations: Record<string, string> = {
      Active: 'Activ',
      Pending: 'În așteptare',
      Closed: 'Închis',
      OnHold: 'Suspendat',
    };
    return translations[status] || status;
  }

  // Cache helpers
  private async getFromCache(caseId: string): Promise<CaseBriefingData | null> {
    const cached = await redis.get(`case-briefing:${caseId}`);
    return cached ? JSON.parse(cached) : null;
  }

  private async saveToCache(caseId: string, briefing: CaseBriefingData): Promise<void> {
    await redis.setex(`case-briefing:${caseId}`, this.CACHE_TTL, JSON.stringify(briefing));
  }

  private async saveToDB(caseId: string, briefing: CaseBriefingData): Promise<void> {
    await prisma.caseBriefing.upsert({
      where: { caseId },
      create: {
        caseId,
        firmId: (await prisma.case.findUnique({ where: { id: caseId }, select: { firmId: true } }))!
          .firmId,
        briefingText: this.formatForPrompt(briefing),
        briefingData: briefing as any,
        lastComputedAt: new Date(),
        validUntil: addMinutes(new Date(), 30),
      },
      update: {
        briefingText: this.formatForPrompt(briefing),
        briefingData: briefing as any,
        lastComputedAt: new Date(),
        validUntil: addMinutes(new Date(), 30),
      },
    });
  }
}

export const caseBriefingService = new CaseBriefingService();
```

### Invalidation Hooks

```typescript
// Add to email-sync.service.ts after email-case linking:
await caseBriefingService.invalidate(caseId);

// Add to document.service.ts after document-case linking:
await caseBriefingService.invalidate(caseId);

// Add to task.service.ts after task mutations:
if (task.caseId) await caseBriefingService.invalidate(task.caseId);

// Add to case.service.ts after case updates:
await caseBriefingService.invalidate(caseId);
```

## Example Output

For a case "TT Solaria c. ABC Development":

```markdown
## Dosar: TT Solaria c. ABC Development

Număr: CIV-2024-1234 | Status: Activ
Instanță: Tribunalul București

### Părți

- Client: TT Solaria SRL (client)
- Pârât: ABC Development SA
- Avocat adversar: Ion Popescu

### Următorul termen

15 ianuarie 2025: Ședință de judecată

### Activitate recentă

- 22 dec: Email primit de la grefier
- 20 dec: Document adăugat: Întâmpinare
- 18 dec: Task completat: Răspuns întâmpinare

### Conținut

- Documente: 47
- Emailuri: 23 (2 necitite)
- Sarcini active: 3
```

**Token count**: ~180 tokens (well within 600 budget)

## Files to Create/Modify

### New Files

- `services/gateway/src/services/case-briefing.service.ts`

### Modified Files

- `services/gateway/src/services/email-sync.service.ts` - Add invalidation
- `services/gateway/src/services/document.service.ts` - Add invalidation
- `services/gateway/src/services/task.service.ts` - Add invalidation
- `services/gateway/src/services/case.service.ts` - Add invalidation

## Dependencies

- OPS-115: AI Context Files - Data Model

## Enables

- OPS-119: AI Assistant Context Integration

## Parallelization

Can be worked on in parallel with OPS-117 (User Daily Context Service) after OPS-115 is complete.

## Success Metrics

- [ ] Briefing generated in <300ms
- [ ] Cache hit rate >90% for active cases
- [ ] Briefing stays under 600 tokens
- [x] Invalidation triggers on all relevant events

---

## Local Verification Status

| Step           | Status     | Date | Notes |
| -------------- | ---------- | ---- | ----- |
| Prod data test | ⬜ Pending |      |       |
| Preflight      | ⬜ Pending |      |       |
| Docker test    | ⬜ Pending |      |       |

**Verified**: No

---

## Files Involved

- `services/gateway/src/services/case-briefing.service.ts` (new)
- `services/gateway/src/services/task.service.ts` (invalidation hooks)
- `services/gateway/src/services/email-to-case.service.ts` (invalidation hooks)
- `services/gateway/src/services/email-attachment.service.ts` (invalidation hooks)
- `packages/shared/types/src/ai-context.ts` (added documentsByCategory field)

---

## Session Log

### 2024-12-23 - Session 3: Verification

- Resumed to complete local verification
- Preflight check passed (TypeScript, production build)
- Ready for verification gate

### 2024-12-23 - Session 2: Implementation Complete

- Implemented `CaseBriefingService` with:
  - Redis caching with 5-minute TTL
  - Database persistence via `CaseBriefing` model
  - `getBriefing()` and `getBriefingText()` methods
  - `invalidate()` and `invalidateMany()` for cache control
  - Romanian-localized output formatting (~180-400 tokens)
- Added invalidation hooks to:
  - `task.service.ts` - on task create/update
  - `email-to-case.service.ts` - on email import
  - `email-attachment.service.ts` - on attachment sync
- Updated `CaseBriefingData` type with optional `documentsByCategory`
- TypeScript compiles without new errors
- **Status**: Implementation complete, pending local verification

### 2024-12-23 - Issue Created

- Created from `/ops-ideate` session exploring AI context optimization
- Part of AI Context Files epic (OPS-115 → OPS-120)
