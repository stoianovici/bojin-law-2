# OPS-072: Task & Calendar Intent Handler

**Status:** Verifying | **Priority:** P2-Medium | **Type:** Feature
**Created:** 2025-12-20 | **Depends on:** OPS-066, OPS-071, OPS-077

> **Note (OPS-077):** This handler uses `NaturalLanguageCommandService` (not `taskParserService`)
> for task parsing. The existing service already supports CREATE_TASK intent detection.
>
> **Shared Types:** Intent handlers share common types (`AssistantContext`, `UserContext`, `HandlerResult`).
> Create `services/gateway/src/services/intent-handlers/types.ts` as the first step to avoid duplication.

## Summary

Implement the intent handler for task creation, task queries, and calendar scheduling.

## Background

Users should be able to:

- "Creează o sarcină pentru mâine să pregătesc dosarul Ionescu"
- "Ce am de făcut săptămâna asta?"
- "Programează o întâlnire cu clientul vineri la 10"

This handler leverages existing TaskService and TaskParser.

## Requirements

### Shared Types (types.ts)

```typescript
// services/gateway/src/services/intent-handlers/types.ts

// ============================================================================
// Shared Types for Intent Handlers
// ============================================================================

export interface AssistantContext {
  currentScreen?: string;
  currentCaseId?: string;
  currentDocumentId?: string;
  selectedEmailId?: string;
  selectedText?: string;
}

export interface UserContext {
  userId: string;
  firmId: string;
  role?: string;
  email?: string;
}

export interface ProposedAction {
  type: string;
  displayText: string;
  payload: Record<string, unknown>;
  requiresConfirmation?: boolean;
  confirmationPrompt?: string;
  entityPreview?: Record<string, unknown>;
}

export interface HandlerResult {
  success: boolean;
  data?: unknown;
  proposedAction?: ProposedAction;
  message?: string;
}

export interface AIMessage {
  id: string;
  role: 'User' | 'Assistant' | 'System';
  content: string;
  intent?: string;
  confidence?: number;
  proposedAction?: ProposedAction & { status: string };
  createdAt: string;
}
```

### Handler Implementation

```typescript
// services/gateway/src/services/intent-handlers/task.handler.ts

import { TaskService } from '../task.service';
import { NaturalLanguageCommandService, CommandIntent } from '../natural-language-command.service';
import { calendarSuggestionService } from '../calendar-suggestion.service';
import { prisma } from '@legal-platform/database';
import type { AssistantContext, UserContext, HandlerResult } from './types';

// Note: TaskService is class-based, instantiate with user context per request
// naturalLanguageCommandService uses processCommand(input, userContext) interface

// ============================================================================
// Handler-specific Types (not shared)
// ============================================================================

interface TaskHandlerParams {
  // For CreateTask
  rawText?: string;
  title?: string;
  dueDate?: string;
  priority?: string;
  assigneeId?: string;
  caseId?: string;

  // For QueryTasks
  timeRange?: 'today' | 'week' | 'month' | 'all';
  status?: 'pending' | 'completed' | 'overdue';

  // For ScheduleEvent
  eventTitle?: string;
  eventDate?: string;
  eventTime?: string;
  attendees?: string[];
}

// Note: HandlerResult is imported from ./types

// ============================================================================
// Handler
// ============================================================================

export class TaskIntentHandler {
  async handleCreateTask(
    params: TaskHandlerParams,
    context: AssistantContext,
    userContext: UserContext
  ): Promise<HandlerResult> {
    // Use natural language command service if raw text provided
    if (params.rawText) {
      // Note: processCommand is the actual method name, takes input object + userContext
      const nlService = new NaturalLanguageCommandService();
      const parsed = await nlService.processCommand(
        {
          input: params.rawText,
          caseId: context.currentCaseId || '',
        },
        { userId: userContext.userId, firmId: userContext.firmId }
      );

      // Verify intent is CREATE_TASK
      if (parsed.intent !== CommandIntent.CREATE_TASK) {
        return {
          success: false,
          message: 'Nu am putut interpreta cererea ca o sarcină nouă.',
        };
      }

      // extractedParams contains the parsed task data
      const taskData = parsed.extractedParams;

      // Build preview from parsed data (extractedParams uses CommandParams interface)
      // Properties: title, description, dueDate, priority, taskType, durationMinutes
      const preview = {
        titlu: taskData?.title || 'Sarcină nouă',
        termen: taskData?.dueDate ? this.formatDate(taskData.dueDate) : 'Nespecificat',
        prioritate: this.translatePriority(taskData?.priority || 'Medium'),
        dosar: 'Din context', // Case resolved from context.currentCaseId
        atribuit: 'Tu',
      };

      return {
        success: true,
        proposedAction: {
          type: 'CreateTask',
          displayText: `Creează sarcină: ${taskData?.title || 'Sarcină nouă'}`,
          payload: {
            title: taskData?.title,
            description: taskData?.description,
            dueDate: taskData?.dueDate,
            priority: taskData?.priority || 'Medium',
            caseId: context.currentCaseId,
            assignedTo: userContext.userId,
            type: taskData?.taskType || 'Research',
          },
          confirmationPrompt: 'Creez această sarcină?',
          entityPreview: preview,
        },
      };
    }

    // Direct params provided
    // ... similar logic
  }

  async handleQueryTasks(
    params: TaskHandlerParams,
    userContext: UserContext
  ): Promise<HandlerResult> {
    // Note: TaskService is class-based, instantiate per request (no constructor params)
    const taskService = new TaskService();

    // Use getTasksByAssignee (not getUserTasks which doesn't exist)
    // Method signature: getTasksByAssignee(userId, firmId, filters?)
    const dateRange = this.getDateRangeFilter(params.timeRange || 'week');
    const tasks = await taskService.getTasksByAssignee(userContext.userId, userContext.firmId, {
      statuses:
        params.status === 'completed'
          ? ['Completed']
          : params.status === 'pending'
            ? ['Pending', 'InProgress']
            : params.status === 'overdue'
              ? ['Pending']
              : undefined,
      dueDateFrom: dateRange.start,
      dueDateTo: dateRange.end,
    });

    // Filter overdue tasks in JS if needed (those with past dueDate)
    const filteredTasks =
      params.status === 'overdue'
        ? tasks.filter((t) => t.dueDate && t.dueDate < new Date())
        : tasks;

    const summary = this.summarizeTasks(filteredTasks);

    return {
      success: true,
      data: { tasks: filteredTasks, summary },
      message: summary,
    };
  }

  private getDateRangeFilter(timeRange: string): { start?: Date; end?: Date } {
    const now = new Date();
    switch (timeRange) {
      case 'today':
        const startOfDay = new Date(now);
        startOfDay.setHours(0, 0, 0, 0);
        const endOfDay = new Date(now);
        endOfDay.setHours(23, 59, 59, 999);
        return { start: startOfDay, end: endOfDay };
      case 'week':
        return { start: new Date(), end: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) };
      case 'month':
        return { start: new Date(), end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) };
      default:
        return {};
    }
  }

  async handleScheduleEvent(
    params: TaskHandlerParams,
    context: AssistantContext,
    userContext: UserContext
  ): Promise<HandlerResult> {
    const suggestion = await calendarSuggestionService.createSuggestion({
      title: params.eventTitle!,
      startDateTime: this.parseDateTime(params.eventDate!, params.eventTime),
      caseId: context.currentCaseId,
      attendees: params.attendees,
    });

    return {
      success: true,
      proposedAction: {
        type: 'ScheduleEvent',
        displayText: `Programează: ${params.eventTitle}`,
        payload: suggestion,
        confirmationPrompt: 'Adaug în calendar?',
        entityPreview: {
          eveniment: params.eventTitle,
          data: this.formatDate(params.eventDate!),
          ora: params.eventTime || 'Toată ziua',
        },
      },
    };
  }

  // Helper methods
  private formatDate(date: string): string {
    /* ... */
  }
  private translatePriority(priority: string): string {
    /* ... */
  }
  private summarizeTasks(tasks: Task[]): string {
    /* ... */
  }
  private parseDateTime(date: string, time?: string): Date {
    /* ... */
  }
}

export const taskIntentHandler = new TaskIntentHandler();
```

### Example Interactions

**Create Task:**

```
User: "Creează o sarcină pentru mâine să pregătesc documentele pentru termenul Ionescu"

AI: Am pregătit sarcina:
┌─────────────────────────────────────────┐
│ Titlu: Pregătire documente termen       │
│ Termen: Mâine, 21 dec 2025              │
│ Prioritate: Înaltă                      │
│ Dosar: Ionescu vs. ABC SRL              │
│ Atribuit: Tu                            │
│                                         │
│ [Anulează]          [Confirmă]          │
└─────────────────────────────────────────┘
```

**Query Tasks:**

```
User: "Ce am de făcut săptămâna asta?"

AI: Săptămâna aceasta ai 5 sarcini:
• Azi: Pregătire dosar Ionescu (Urgent)
• Mâine: Revizuire contract Popescu
• Joi: Întâlnire client Marinescu
• Vineri: Depunere acte Tribunalul București (2)

Vrei să vezi detalii despre una din ele?
```

## Acceptance Criteria

- [x] TaskIntentHandler class implemented
- [x] CreateTask uses existing TaskParser
- [x] QueryTasks returns formatted summary
- [x] ScheduleEvent creates calendar suggestion
- [x] Action previews are user-friendly in Romanian
- [x] Case attribution from context works
- [x] Integration with existing services
- [x] Unit tests for all intent types

## Files to Create

- `services/gateway/src/services/intent-handlers/types.ts` (shared types for all handlers)
- `services/gateway/src/services/intent-handlers/task.handler.ts`
- `services/gateway/src/services/intent-handlers/task.handler.test.ts`

## Session Log

### Session 1 (2025-12-20)

**Work Completed:**

1. Created shared types file `services/gateway/src/services/intent-handlers/types.ts`
   - `AssistantContext` for UI state context
   - `UserContext` for authentication/authorization
   - `ProposedAction` for confirmable actions
   - `HandlerResult` for handler responses
   - `AIMessage` for conversation messages
   - `IntentHandler` base interface

2. Implemented `TaskIntentHandler` in `services/gateway/src/services/intent-handlers/task.handler.ts`
   - `handleCreateTask()` - parses natural language using `NaturalLanguageCommandService`
   - `handleQueryTasks()` - retrieves and summarizes tasks for user
   - `handleScheduleEvent()` - prepares calendar event suggestions
   - Helper methods for date formatting, priority translation, task summarization

3. Created unit tests in `services/gateway/src/services/intent-handlers/task.handler.test.ts`
   - Tests for all three handler methods
   - Edge cases (missing context, no tasks, overdue filtering)
   - Romanian localization verification

4. Fixed TypeScript errors in other intent handlers:
   - `case-query.handler.ts`: Fixed `Client.contactInfo` field usage
   - `email.handler.ts`: Fixed `AIOperationType.ContentSummarization` → `CommunicationIntelligence`
   - `document.handler.ts`: Fixed `Document.textContent` → metadata extraction, `linkedAt` ordering

5. Preflight passed (6 checks, 2 non-blocking warnings)

**Files Created/Modified:**

- `services/gateway/src/services/intent-handlers/types.ts` (new)
- `services/gateway/src/services/intent-handlers/task.handler.ts` (new)
- `services/gateway/src/services/intent-handlers/task.handler.test.ts` (new)
- `services/gateway/src/services/intent-handlers/case-query.handler.ts` (fixed)
- `services/gateway/src/services/intent-handlers/email.handler.ts` (fixed)
- `services/gateway/src/services/intent-handlers/document.handler.ts` (fixed)

**Status:** Ready for local verification
