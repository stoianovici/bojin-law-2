# OPS-117: User Daily Context Service

## Summary

Build a service that generates and caches a user's daily context - a pre-computed summary of their current state (new items, today's schedule, urgent tasks, active cases) for injection into AI system prompts.

## Problem

Currently, the AI assistant knows very little about the user's state:

- No knowledge of "what's new" since last login
- Must call tools to discover today's schedule
- Cannot prioritize based on user's workload
- Morning briefing requires 3-4 tool calls (~3s)

## Solution

Pre-compute a `UserDailyContext` that contains:

- New items since last interaction
- Today's schedule
- Urgent/overdue items
- Active cases summary

This context is:

1. Regenerated on demand (first request of day or after invalidation)
2. Cached in Redis with 30-minute TTL
3. Injected into AI system prompt (~600-800 tokens)

## Architecture

```
User Request
    â”‚
    â–¼
Load UserDailyContext
    â”‚
    â”œâ”€â”€ Cache hit? â†’ Return cached
    â”‚
    â””â”€â”€ Cache miss? â†’ Generate
            â”‚
            â”œâ”€â”€ Query UserActivityEvents
            â”œâ”€â”€ Query Tasks (today, overdue)
            â”œâ”€â”€ Query Calendar (today)
            â”œâ”€â”€ Query Cases (active)
            â”‚
            â”œâ”€â”€ Compute summary
            â”‚
            â”œâ”€â”€ Save to DB + Redis
            â”‚
            â””â”€â”€ Return context
```

## Implementation

### Service

```typescript
// services/gateway/src/services/user-context.service.ts

export class UserContextService {
  private readonly CACHE_TTL = 30 * 60; // 30 minutes
  private readonly CONTEXT_TOKEN_BUDGET = 800;

  /**
   * Get or generate user's daily context
   */
  async getContext(userId: string, firmId: string): Promise<UserContextData> {
    // Try cache first
    const cached = await this.getFromCache(userId);
    if (cached && !this.isStale(cached)) {
      return cached.contextData;
    }

    // Generate fresh context
    const context = await this.generateContext(userId, firmId);

    // Cache it
    await this.saveToCache(userId, context);
    await this.saveToDB(userId, firmId, context);

    return context;
  }

  /**
   * Get context formatted for AI system prompt
   */
  async getContextForPrompt(userId: string, firmId: string): Promise<string> {
    const context = await this.getContext(userId, firmId);
    return this.formatForPrompt(context);
  }

  /**
   * Invalidate context (called when events occur)
   */
  async invalidate(userId: string): Promise<void> {
    await redis.del(`user-context:${userId}`);
  }

  /**
   * Generate fresh context from database
   */
  private async generateContext(userId: string, firmId: string): Promise<UserContextData> {
    const now = new Date();
    const todayStart = startOfDay(now);
    const todayEnd = endOfDay(now);
    const yesterday = subDays(now, 1);

    // Parallel queries for speed
    const [recentEvents, todayTasks, overdueTasks, todayCalendar, activeCases, unreadEmailCount] =
      await Promise.all([
        // Recent activity (last 24h)
        prisma.userActivityEvent.findMany({
          where: { userId, occurredAt: { gte: yesterday } },
          orderBy: { occurredAt: 'desc' },
          take: 10,
        }),

        // Tasks due today
        prisma.task.findMany({
          where: {
            assignedToId: userId,
            dueDate: { gte: todayStart, lte: todayEnd },
            status: { not: 'Completed' },
          },
          include: { case: { select: { id: true, title: true } } },
        }),

        // Overdue tasks
        prisma.task.findMany({
          where: {
            assignedToId: userId,
            dueDate: { lt: todayStart },
            status: { not: 'Completed' },
          },
          include: { case: { select: { id: true, title: true } } },
          take: 5,
        }),

        // Today's calendar
        prisma.calendarEvent.findMany({
          where: {
            userId,
            startTime: { gte: todayStart, lte: todayEnd },
          },
          orderBy: { startTime: 'asc' },
        }),

        // Active cases with recent activity
        prisma.case.findMany({
          where: {
            firmId,
            status: 'Active',
            OR: [
              { assignedUsers: { some: { id: userId } } },
              { tasks: { some: { assignedToId: userId } } },
            ],
          },
          include: {
            _count: { select: { documents: true, emailLinks: true } },
            tasks: {
              where: { status: { not: 'Completed' } },
              orderBy: { dueDate: 'asc' },
              take: 1,
            },
          },
          take: 10,
        }),

        // Unread email count
        prisma.email.count({
          where: { userId, isRead: false },
        }),
      ]);

    // Count new items
    const newEmails = recentEvents.filter(
      (e) => e.eventType === 'EMAIL_RECEIVED' || e.eventType === 'EMAIL_FROM_COURT'
    ).length;
    const newDocs = recentEvents.filter((e) => e.eventType === 'DOCUMENT_UPLOADED').length;

    return {
      newEmailsCount: newEmails,
      newDocumentsCount: newDocs,
      pendingTasksCount: todayTasks.length,
      overdueTasksCount: overdueTasks.length,

      todayEvents: [
        ...todayCalendar.map((e) => ({
          id: e.id,
          type: this.mapEventType(e.type),
          title: e.title,
          time: format(e.startTime, 'HH:mm'),
          caseId: e.caseId,
        })),
        ...todayTasks.map((t) => ({
          id: t.id,
          type: 'task' as const,
          title: t.title,
          caseId: t.caseId,
          caseName: t.case?.title,
        })),
      ].sort((a, b) => (a.time || '').localeCompare(b.time || '')),

      urgentItems: [
        ...overdueTasks.map((t) => ({
          type: 'overdue_task' as const,
          title: t.title,
          entityId: t.id,
          caseId: t.caseId,
          daysOverdue: differenceInDays(now, t.dueDate),
        })),
        ...recentEvents
          .filter((e) => e.eventType === 'EMAIL_FROM_COURT')
          .map((e) => ({
            type: 'court_email' as const,
            title: e.entityTitle || 'Email de la instanÈ›Äƒ',
            entityId: e.entityId,
          })),
      ],

      recentActivity: recentEvents.slice(0, 5).map((e) => ({
        type: e.eventType,
        title: e.entityTitle || '',
        entityId: e.entityId,
        occurredAt: e.occurredAt.toISOString(),
      })),

      activeCases: activeCases.map((c) => ({
        id: c.id,
        name: c.title,
        nextDeadline: c.tasks[0]?.dueDate?.toISOString(),
        unreadEmails: 0, // Would need join
        recentActivity: recentEvents.some(
          (e) => e.metadata?.caseId === c.id || e.metadata?.caseIds?.includes(c.id)
        ),
      })),
    };
  }

  /**
   * Format context for AI system prompt injection
   */
  private formatForPrompt(context: UserContextData): string {
    const lines: string[] = [];

    // New items summary
    if (context.newEmailsCount || context.newDocumentsCount) {
      lines.push(`### Nou de ieri`);
      if (context.newEmailsCount) lines.push(`- ${context.newEmailsCount} emailuri noi`);
      if (context.newDocumentsCount) lines.push(`- ${context.newDocumentsCount} documente noi`);
      lines.push('');
    }

    // Today's schedule
    if (context.todayEvents.length > 0) {
      lines.push(`### Programul de azi`);
      for (const event of context.todayEvents) {
        const time = event.time ? `${event.time} ` : '';
        const caseRef = event.caseName ? ` (${event.caseName})` : '';
        lines.push(`- ${time}${event.title}${caseRef}`);
      }
      lines.push('');
    }

    // Urgent items
    if (context.urgentItems.length > 0) {
      lines.push(`### âš ï¸ Urgente`);
      for (const item of context.urgentItems) {
        if (item.type === 'overdue_task') {
          lines.push(`- [ÃŽNTÃ‚RZIAT ${item.daysOverdue}z] ${item.title}`);
        } else if (item.type === 'court_email') {
          lines.push(`- [INSTANÈšÄ‚] ${item.title}`);
        } else {
          lines.push(`- ${item.title}`);
        }
      }
      lines.push('');
    }

    // Active cases summary
    if (context.activeCases.length > 0) {
      lines.push(`### Dosare active (${context.activeCases.length})`);
      for (const c of context.activeCases.slice(0, 5)) {
        const deadline = c.nextDeadline
          ? ` - termen ${format(new Date(c.nextDeadline), 'd MMM', { locale: ro })}`
          : '';
        const activity = c.recentActivity ? ' ðŸ”µ' : '';
        lines.push(`- ${c.name}${deadline}${activity}`);
      }
    }

    return lines.join('\n');
  }

  // Cache helpers
  private async getFromCache(
    userId: string
  ): Promise<{ contextData: UserContextData; computedAt: Date } | null> {
    const cached = await redis.get(`user-context:${userId}`);
    return cached ? JSON.parse(cached) : null;
  }

  private async saveToCache(userId: string, context: UserContextData): Promise<void> {
    await redis.setex(
      `user-context:${userId}`,
      this.CACHE_TTL,
      JSON.stringify({ contextData: context, computedAt: new Date() })
    );
  }

  private isStale(cached: { computedAt: Date }): boolean {
    return differenceInMinutes(new Date(), new Date(cached.computedAt)) > 30;
  }
}

export const userContextService = new UserContextService();
```

## Integration with AI Assistant

```typescript
// In ai-assistant.service.ts, buildSystemPrompt():

const userContext = await userContextService.getContextForPrompt(context.userId, context.firmId);

const systemPrompt = `
${BASE_SYSTEM_PROMPT}

## Context utilizator

${userContext}

## Context dosar curent

${caseContext ? caseBriefingService.getBriefingText(context.caseId) : 'Niciun dosar selectat.'}
`;
```

## Files to Create/Modify

### New Files

- `services/gateway/src/services/user-context.service.ts`

### Modified Files

- `services/gateway/src/services/ai-assistant.service.ts` - Load context
- `services/gateway/src/services/ai-system-prompt.ts` - Inject context

## Dependencies

- OPS-115: AI Context Files - Data Model
- OPS-116: Event Emission Infrastructure (for rich context)

## Enables

- OPS-119: AI Assistant Context Integration
- OPS-120: Notification Engine

## Parallelization

Can be worked on in parallel with OPS-118 (Case Briefing Service) after OPS-115 is complete.

## Success Metrics

- [ ] Context generated in <500ms
- [ ] Cache hit rate >80% during active usage
- [ ] Context stays under 800 tokens
- [ ] Invalidation triggers on relevant events

---

## Session Log

### 2024-12-23 - Issue Created

- Created from `/ops-ideate` session exploring AI context optimization
- Part of AI Context Files epic (OPS-115 â†’ OPS-120)

### 2024-12-23 - Session 1 - Implementation Complete

**Work Done:**

- Created `services/gateway/src/services/user-context.service.ts` with:
  - `getContext()` - retrieves or generates user daily context
  - `getContextForPrompt()` - formats context for AI prompt injection
  - `invalidate()` / `invalidateMany()` - cache invalidation methods
  - Redis caching layer with 30-minute TTL
  - DB persistence to `UserDailyContext` table
- Updated `services/gateway/src/services/ai-system-prompt.ts`:
  - Added `userDailyContext` field to `SystemPromptContext`
  - Added `{userDailyContext}` placeholder to template
  - Updated `buildSystemPrompt()` to inject context
- Updated `services/gateway/src/services/ai-assistant.service.ts`:
  - Integrated `userContextService.getContextForPrompt()` into `buildContextualSystemPrompt()`

**TypeScript Status:** Compiles clean for all new code

**Preflight Status:**

- Gateway builds successfully
- Docker builds pass
- Pre-existing test failures (Apollo client mock issue - not related to OPS-117)

**Ready for Local Verification**
