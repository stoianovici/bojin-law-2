# OPS-073: Case Query Intent Handler

**Status:** Implemented | **Priority:** P2-Medium | **Type:** Feature
**Created:** 2025-12-20 | **Depends on:** OPS-066, OPS-071
**Sessions:** 1 | **Last Active:** 2025-12-20

## Summary

Implement the intent handler for case information queries and summaries.

## Background

Users should be able to:

- "Care e statusul dosarului Ionescu?"
- "Când e următorul termen în dosarul 2024-1234?"
- "Fă-mi un rezumat al dosarului curent"
- "Cine sunt actorii din acest dosar?"

This handler leverages existing CaseSummaryService and search.

## Requirements

### Handler Implementation

```typescript
// services/gateway/src/services/intent-handlers/case-query.handler.ts

import { prisma } from '@legal-platform/database';
import { caseSummaryService } from '../case-summary.service';
import type { AssistantContext, UserContext, HandlerResult } from './types'; // From OPS-072

// ============================================================================
// Types
// ============================================================================

interface CaseQueryParams {
  queryType: 'status' | 'deadline' | 'summary' | 'actors' | 'documents' | 'general';
  caseId?: string;
  caseReference?: string; // e.g., "2024-1234" or "Ionescu"
  question?: string; // Free-form question
}

// ============================================================================
// Handler
// ============================================================================

export class CaseQueryHandler {
  async handle(
    params: CaseQueryParams,
    context: AssistantContext,
    userContext: UserContext
  ): Promise<HandlerResult> {
    // Resolve case ID
    const caseId =
      params.caseId ||
      context.currentCaseId ||
      (await this.findCaseByReference(params.caseReference, userContext.firmId));

    if (!caseId) {
      return {
        success: false,
        message: 'Nu am putut identifica dosarul. Specificați numărul sau numele dosarului.',
      };
    }

    // Route to specific handler
    switch (params.queryType) {
      case 'status':
        return this.handleStatusQuery(caseId, userContext);
      case 'deadline':
        return this.handleDeadlineQuery(caseId, userContext);
      case 'summary':
        return this.handleSummaryQuery(caseId, userContext);
      case 'actors':
        return this.handleActorsQuery(caseId, userContext);
      case 'documents':
        return this.handleDocumentsQuery(caseId, userContext);
      default:
        return this.handleGeneralQuery(caseId, params.question!, userContext);
    }
  }

  private async handleStatusQuery(
    caseId: string,
    userContext: UserContext
  ): Promise<HandlerResult> {
    const caseData = await prisma.case.findUnique({
      where: { id: caseId, firmId: userContext.firmId },
      include: {
        client: true,
        tasks: { where: { status: 'Pending' }, take: 3 },
      },
    });

    if (!caseData) {
      return { success: false, message: 'Dosarul nu a fost găsit.' };
    }

    const statusText = this.formatCaseStatus(caseData);

    return {
      success: true,
      data: caseData,
      message: statusText,
    };
  }

  private async handleDeadlineQuery(
    caseId: string,
    userContext: UserContext
  ): Promise<HandlerResult> {
    const tasks = await prisma.task.findMany({
      where: {
        caseId,
        case: { firmId: userContext.firmId },
        status: 'Pending',
        dueDate: { gte: new Date() },
      },
      orderBy: { dueDate: 'asc' },
      take: 5,
    });

    if (tasks.length === 0) {
      return {
        success: true,
        message: 'Nu există termene viitoare în acest dosar.',
      };
    }

    const deadlinesText = tasks
      .map((t) => `• ${this.formatDate(t.dueDate)}: ${t.title}`)
      .join('\n');

    return {
      success: true,
      data: tasks,
      message: `Următoarele termene:\n${deadlinesText}`,
    };
  }

  private async handleSummaryQuery(
    caseId: string,
    userContext: UserContext
  ): Promise<HandlerResult> {
    // Note: caseSummaryService.generateSummary(caseId, firmId) generates and stores summary
    // Query database directly for cached summary, or generate if stale/missing

    // Check for cached summary in database
    // CaseSummary model has: id, caseId (unique), executiveSummary, currentStatus,
    // keyDevelopments (Json), openIssues (Json), generatedAt, isStale, dataVersionHash
    const cachedSummary = await prisma.caseSummary.findUnique({
      where: { caseId },
      include: { case: { select: { firmId: true } } },
    });

    // Verify firm access
    if (cachedSummary && cachedSummary.case.firmId !== userContext.firmId) {
      return { success: false, message: 'Dosarul nu a fost găsit.' };
    }

    // If no summary or marked as stale, regenerate
    if (!cachedSummary || cachedSummary.isStale) {
      // Generate new summary (stores in database)
      await caseSummaryService.generateSummary(caseId, userContext.firmId);

      // Fetch the newly generated summary
      const newSummary = await prisma.caseSummary.findUnique({
        where: { caseId },
      });

      if (!newSummary) {
        return {
          success: false,
          message: 'Nu am putut genera rezumatul. Încercați din nou.',
        };
      }

      return this.formatSummaryResponse(newSummary);
    }

    return this.formatSummaryResponse(cachedSummary);
  }

  // Note: keyDevelopments and openIssues are Json fields in Prisma schema
  // They need to be cast to string[] when accessed
  private formatSummaryResponse(summary: {
    executiveSummary: string;
    currentStatus: string;
    keyDevelopments: unknown; // Json field from Prisma
    openIssues: unknown; // Json field from Prisma
  }): HandlerResult {
    // Cast Json fields to string arrays
    const keyDev = (summary.keyDevelopments || []) as string[];
    const issues = (summary.openIssues || []) as string[];

    const summaryText = `
**Rezumat dosar:**
${summary.executiveSummary}

**Status curent:**
${summary.currentStatus}

**Dezvoltări cheie:**
${keyDev.map((d) => `• ${d}`).join('\n')}

**Probleme deschise:**
${issues.map((i) => `• ${i}`).join('\n')}
    `.trim();

    return {
      success: true,
      data: summary,
      message: summaryText,
    };
  }

  private async handleActorsQuery(
    caseId: string,
    userContext: UserContext
  ): Promise<HandlerResult> {
    const caseData = await prisma.case.findUnique({
      where: { id: caseId, firmId: userContext.firmId },
      include: {
        client: true,
        actors: { include: { contact: true } },
        teamMembers: { include: { user: true } },
      },
    });

    if (!caseData) {
      return { success: false, message: 'Dosarul nu a fost găsit.' };
    }

    const actorsText = this.formatActors(caseData);

    return {
      success: true,
      data: caseData,
      message: actorsText,
    };
  }

  private async handleDocumentsQuery(
    caseId: string,
    userContext: UserContext
  ): Promise<HandlerResult> {
    const documents = await prisma.caseDocument.findMany({
      where: { caseId, case: { firmId: userContext.firmId } },
      include: { document: true },
      orderBy: { createdAt: 'desc' },
      take: 10,
    });

    if (documents.length === 0) {
      return {
        success: true,
        message: 'Nu există documente în acest dosar.',
      };
    }

    const docsText = documents
      .map((d) => `• ${d.document.fileName} (${this.formatDate(d.createdAt)})`)
      .join('\n');

    return {
      success: true,
      data: documents,
      message: `Ultimele documente:\n${docsText}`,
    };
  }

  private async handleGeneralQuery(
    caseId: string,
    question: string,
    userContext: UserContext
  ): Promise<HandlerResult> {
    // Use AI to answer based on case context
    // This would call the AI service with case data as context
    // For now, return a fallback

    return {
      success: true,
      message: 'Pentru întrebări complexe, vă recomand să verificați direct detaliile dosarului.',
    };
  }

  // Helper to find case by reference (number or client name)
  private async findCaseByReference(
    reference: string | undefined,
    firmId: string
  ): Promise<string | null> {
    if (!reference) return null;

    const caseData = await prisma.case.findFirst({
      where: {
        firmId,
        OR: [
          { caseNumber: { contains: reference, mode: 'insensitive' } },
          { title: { contains: reference, mode: 'insensitive' } },
          { client: { name: { contains: reference, mode: 'insensitive' } } },
        ],
      },
    });

    return caseData?.id ?? null;
  }

  // Formatting helpers
  private formatCaseStatus(caseData: any): string {
    /* ... */
  }
  private formatActors(caseData: any): string {
    /* ... */
  }
  private formatDate(date: Date): string {
    /* ... */
  }
}

export const caseQueryHandler = new CaseQueryHandler();
```

## Acceptance Criteria

- [x] CaseQueryHandler class implemented
- [x] Status queries return formatted case status
- [x] Deadline queries list upcoming tasks
- [x] Summary queries use CaseSummaryService
- [x] Actors query lists all case participants
- [x] Documents query lists recent documents
- [x] Case resolution by number/name works
- [x] Context case ID used when not specified
- [x] Romanian output formatting
- [x] Unit tests for all query types (26 tests)

## Files to Create

- `services/gateway/src/services/intent-handlers/case-query.handler.ts`
- `services/gateway/src/services/intent-handlers/case-query.handler.test.ts`

## Session Log

- [2025-12-20] Session 1 started. Implementing CaseQueryHandler.
- [2025-12-20] Created `case-query.handler.ts` with:
  - CaseQueryHandler class with 6 query types (status, deadline, summary, actors, documents, general)
  - Case resolution by ID, context, or reference search
  - Romanian output formatting with proper translations
  - Integration with CaseSummaryService for AI summaries
  - Firm isolation enforcement
- [2025-12-20] Created `case-query.handler.test.ts` with 26 passing tests:
  - Case resolution tests (4 tests)
  - Status query tests (4 tests)
  - Deadline query tests (3 tests)
  - Summary query tests (5 tests)
  - Actors query tests (3 tests)
  - Documents query tests (3 tests)
  - General query tests (2 tests)
  - Date/priority translation tests (2 tests)
- [2025-12-20] Preflight passed (TypeScript, builds, Docker)

#### Local Verification Status

| Step           | Status     | Date       | Notes                         |
| -------------- | ---------- | ---------- | ----------------------------- |
| Prod data test | ⬜ Pending |            |                               |
| Preflight      | ✅ Passed  | 2025-12-20 | TypeScript, builds, Docker OK |
| Docker test    | ⬜ Pending |            |                               |

**Verified**: Partial (preflight passed, awaiting full verification)
