# OPS-125: Auto-Add Sender as Case Contact on Assignment

**Type:** Feature
**Priority:** P2-Medium
**Status:** Verifying
**Created:** 2025-12-23
**Last Active:** 2025-12-23
**Sessions:** 1
**Epic:** Communications UX Overhaul

### Local Verification Status

| Step           | Status | Notes   |
| -------------- | ------ | ------- |
| Prod data test | ⬜     | Pending |
| Preflight      | ⬜     | Pending |
| Docker test    | ⬜     | Pending |

### Session Log

- [2025-12-23] Session 1 started. Analyzed codebase - found email-thread.service.ts, email.resolvers.ts, classification-scoring.ts patterns
- [2025-12-23] Implementation complete:
  - Added `Other` role to CaseActorRole enum in Prisma schema
  - Updated `assignThreadToCase` in email-thread.service.ts to auto-add sender as CaseActor
  - Added `AssignThreadResult` type to email.graphql schema
  - Updated resolver to return newContactAdded, contactName, contactEmail
  - Updated ConversationView.tsx, MessageView.tsx, MoveThreadModal.tsx frontends
  - All TypeScript checks pass

## Problem

When a user manually assigns an unassigned email to a case, they're implicitly saying "this sender is related to this case." Currently, this knowledge is lost - future emails from the same sender will still appear as "neatribuite" (unassigned).

Users must repeatedly assign emails from the same sender to the same case.

## Context

- Email classification uses case contacts to auto-assign threads (OPS-039, OPS-059)
- "Neatribuite" section shows emails that couldn't be auto-classified
- Court/authority emails have separate INSTANȚE flow (OPS-040) - should NOT auto-add
- User manually assigning = strong signal that sender belongs to case

## Solution

When assigning an unassigned email thread to a case:

1. Check if sender is already a case contact → skip if yes
2. Check if sender is a court/authority domain → skip if yes
3. Auto-add sender email as a CaseContact with role "Other"
4. Show toast notification: "Ion Popescu adăugat ca contact la dosarul X"
5. Future emails from this sender will auto-classify to this case

### Flow Diagram

```
User clicks "Atribuie la dosar" on unassigned email
                    │
                    ▼
        ┌─────────────────────────┐
        │ assignThreadToCase()    │
        │ mutation executes       │
        └───────────┬─────────────┘
                    │
                    ▼
        ┌─────────────────────────┐
        │ Is sender a court/      │──Yes──▶ Skip (use INSTANȚE flow)
        │ authority domain?       │
        └───────────┬─────────────┘
                    │ No
                    ▼
        ┌─────────────────────────┐
        │ Is sender already a     │──Yes──▶ Skip (already known)
        │ contact on this case?   │
        └───────────┬─────────────┘
                    │ No
                    ▼
        ┌─────────────────────────┐
        │ Create CaseContact      │
        │ email: sender.address   │
        │ name: sender.name       │
        │ role: "Other"           │
        └───────────┬─────────────┘
                    │
                    ▼
        ┌─────────────────────────┐
        │ Return mutation result  │
        │ + newContactAdded: true │
        └─────────────────────────┘
```

## Implementation

### Backend: Update assignThreadToCase Mutation

```typescript
// services/gateway/src/services/email-thread.service.ts

async assignThreadToCase(
  conversationId: string,
  caseId: string,
  userContext: UserContext
): Promise<{ thread: EmailThread; newContactAdded: boolean; contactName?: string }> {
  // 1. Find the thread and its emails
  const thread = await prisma.emailThread.findFirst({
    where: { conversationId, firmId: userContext.firmId },
    include: {
      emails: {
        orderBy: { receivedDateTime: 'desc' },
        take: 1,
        select: { from: true },
      },
    },
  });

  if (!thread) throw new Error('Thread not found');

  // 2. Get sender from latest email
  const latestEmail = thread.emails[0];
  const senderAddress = latestEmail?.from?.address;
  const senderName = latestEmail?.from?.name;

  let newContactAdded = false;
  let contactName: string | undefined;

  // 3. Check if we should auto-add sender as contact
  if (senderAddress) {
    const shouldAddContact = await this.shouldAutoAddContact(
      senderAddress,
      caseId,
      userContext.firmId
    );

    if (shouldAddContact) {
      await prisma.caseContact.create({
        data: {
          caseId,
          email: senderAddress.toLowerCase(),
          name: senderName || senderAddress,
          role: 'Other',
          firmId: userContext.firmId,
        },
      });
      newContactAdded = true;
      contactName = senderName || senderAddress;
    }
  }

  // 4. Assign thread to case (existing logic)
  const updatedThread = await prisma.emailThread.update({
    where: { id: thread.id },
    data: { caseId },
  });

  return { thread: updatedThread, newContactAdded, contactName };
}

private async shouldAutoAddContact(
  email: string,
  caseId: string,
  firmId: string
): Promise<boolean> {
  const emailLower = email.toLowerCase();

  // Skip if court/authority domain
  if (this.isCourtOrAuthorityEmail(emailLower)) {
    return false;
  }

  // Skip if already a contact on this case
  const existingContact = await prisma.caseContact.findFirst({
    where: {
      caseId,
      email: emailLower,
      firmId,
    },
  });

  return !existingContact;
}

private isCourtOrAuthorityEmail(email: string): boolean {
  // Use existing court detection logic from OPS-040
  const courtDomains = [
    'just.ro',
    'mpublic.ro',
    'mai.gov.ro',
    'anaf.ro',
    'onrc.ro',
    // ... other authority domains
  ];

  return courtDomains.some(domain => email.endsWith(`@${domain}`));
}
```

### GraphQL Schema Update

```graphql
type AssignThreadResult {
  thread: EmailThread!
  newContactAdded: Boolean!
  contactName: String
}

type Mutation {
  assignThreadToCase(conversationId: String!, caseId: ID!): AssignThreadResult!
}
```

### Frontend: Show Toast on Contact Added

```tsx
// In MessageView.tsx or ConversationView.tsx

const handleAssignToCase = async () => {
  const result = await assignThreadToCase({
    variables: { conversationId, caseId: selectedCaseId },
  });

  const { newContactAdded, contactName } = result.data.assignThreadToCase;

  // Show success notification
  if (newContactAdded && contactName) {
    addNotification({
      type: 'success',
      title: 'Email atribuit',
      message: `${contactName} adăugat ca contact la dosar. Emailurile viitoare vor fi atribuite automat.`,
    });
  } else {
    addNotification({
      type: 'success',
      title: 'Email atribuit',
      message: 'Conversația a fost atribuită la dosar.',
    });
  }
};
```

## Acceptance Criteria

- [x] When assigning unassigned email to case, sender is auto-added as CaseActor
- [x] Contact role is set to "Other" (added to CaseActorRole enum)
- [x] Court/authority emails are excluded (uses GlobalEmailSource table)
- [x] Existing contacts are not duplicated (checks CaseActor table)
- [x] Client contacts are not duplicated (checks Case.client.contactInfo.email)
- [x] Toast notification shows when contact is added (Romanian text)
- [ ] Future emails from same sender auto-classify to case (needs integration testing)

## Files to Modify

| File                                                         | Change                          |
| ------------------------------------------------------------ | ------------------------------- |
| `services/gateway/src/services/email-thread.service.ts`      | Add contact auto-creation logic |
| `services/gateway/src/graphql/schema/email.graphql`          | Update mutation return type     |
| `services/gateway/src/graphql/resolvers/email.resolvers.ts`  | Return newContactAdded          |
| `apps/web/src/components/communication/MessageView.tsx`      | Show toast on contact added     |
| `apps/web/src/components/communication/ConversationView.tsx` | Same toast logic                |

## Edge Cases

1. **Multiple senders in thread**: Use the most recent non-user sender
2. **User's own email**: Don't add user as contact to their own cases
3. **Generic emails** (info@, office@): Consider excluding? Or let user decide?
4. **Email already contact on different case**: Still add to new case (many-to-many)

## Dependencies

- OPS-040: Court Email Detection (reuse domain list)
- OPS-039: Multi-Case Classification (contact-based classification)

## Related Issues

- OPS-121: Conversation-First Thread View (assign button in ConversationView)
- OPS-122: Attachment Preview Panel (part of same epic)
