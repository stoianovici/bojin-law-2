# OPS-070: useAssistant Hook

**Status:** Implemented | **Priority:** P1-High | **Type:** Feature
**Created:** 2025-12-20 | **Depends on:** OPS-069, OPS-068 | **Blocks:** OPS-071
**Sessions:** 1 | **Last Active:** 2025-12-20

## Summary

Create a React hook that connects the Zustand store to GraphQL mutations and provides a clean API for assistant components.

## Background

The hook bridges the store and GraphQL layer:

- Sends messages via GraphQL mutation
- Updates store with responses
- Handles action confirmations
- Manages loading and error states

## Requirements

### Hook Implementation

```typescript
// apps/web/src/hooks/useAssistant.ts

import { useMutation, useLazyQuery } from '@apollo/client';
import { useCallback, useEffect, useState } from 'react';
import { useAssistantStore } from '../stores/assistant.store';
import { gql } from '@apollo/client';

// ============================================================================
// GraphQL Operations
// ============================================================================

const AI_MESSAGE_FRAGMENT = gql`
  fragment AIMessageFields on AIMessage {
    id
    role
    content
    intent
    confidence
    proposedAction {
      type
      displayText
      payload
      status
      requiresConfirmation
      confirmationPrompt
      entityPreview
    }
    createdAt
  }
`;

const GET_ACTIVE_CONVERSATION = gql`
  ${AI_MESSAGE_FRAGMENT}
  query GetActiveConversation($caseId: ID) {
    activeConversation(caseId: $caseId) {
      id
      status
      messages {
        ...AIMessageFields
      }
    }
  }
`;

const SEND_MESSAGE = gql`
  ${AI_MESSAGE_FRAGMENT}
  mutation SendAssistantMessage($input: SendMessageInput!) {
    sendAssistantMessage(input: $input) {
      message {
        ...AIMessageFields
      }
      conversation {
        id
        status
      }
      suggestedFollowUps
    }
  }
`;

const CONFIRM_ACTION = gql`
  mutation ConfirmAction($input: ConfirmActionInput!) {
    confirmAction(input: $input) {
      success
      message
      entityId
      entityType
      navigationUrl
      error
    }
  }
`;

// ============================================================================
// Hook
// ============================================================================

interface UseAssistantReturn {
  // State
  isOpen: boolean;
  isExpanded: boolean;
  isLoading: boolean;
  error: string | null;
  messages: AIMessage[];
  pendingAction: ProposedAction | null;
  suggestedFollowUps: string[]; // Tracked in local state, updated from mutation response
  unreadCount: number;

  // Actions
  toggleOpen: () => void;
  toggleExpanded: () => void;
  sendMessage: (content: string) => Promise<void>;
  confirmAction: (
    confirmed: boolean,
    modifications?: Record<string, unknown>
  ) => Promise<ActionResult>;
  clearConversation: () => void;
  setContext: (context: { caseId?: string; screen?: string }) => void;

  // Computed
  hasActiveConversation: boolean;
  hasPendingConfirmation: boolean;
}

export function useAssistant(): UseAssistantReturn {
  const store = useAssistantStore();
  const [suggestedFollowUps, setSuggestedFollowUps] = useState<string[]>([]);

  const [sendMessageMutation] = useMutation(SEND_MESSAGE);
  const [confirmActionMutation] = useMutation(CONFIRM_ACTION);
  const [loadConversation] = useLazyQuery(GET_ACTIVE_CONVERSATION);

  // Extract stable values to avoid stale closures
  const isOpen = store.isOpen;
  const conversationId = store.conversationId;
  const currentCaseId = store.context.currentCaseId;
  const setConversation = store.setConversation;

  // Load existing conversation on mount
  useEffect(() => {
    if (isOpen && !conversationId) {
      loadConversation({
        variables: { caseId: currentCaseId },
        onCompleted: (data) => {
          if (data.activeConversation) {
            setConversation(data.activeConversation.id, data.activeConversation.messages);
          }
        },
      });
    }
  }, [isOpen, conversationId, currentCaseId, loadConversation, setConversation]);

  const sendMessage = useCallback(
    async (content: string) => {
      store.setLoading(true);
      store.setError(null);

      // Optimistically add user message
      store.addMessage({
        id: `temp-${Date.now()}`,
        role: 'User',
        content,
        createdAt: new Date().toISOString(),
      });

      try {
        const result = await sendMessageMutation({
          variables: {
            input: {
              conversationId: store.conversationId,
              content,
              caseId: store.context.currentCaseId,
              context: store.context,
            },
          },
        });

        const response = result.data?.sendAssistantMessage;
        if (response) {
          // Update conversation ID if new
          if (!store.conversationId) {
            store.setConversation(response.conversation.id, []);
          }

          // Add assistant message
          store.addMessage(response.message);

          // Update suggested follow-ups from response
          setSuggestedFollowUps(response.suggestedFollowUps || []);
        }
      } catch (error) {
        store.setError(
          error instanceof Error ? error.message : 'A apărut o eroare. Încercați din nou.'
        );
      } finally {
        store.setLoading(false);
      }
    },
    [store, sendMessageMutation]
  );

  const confirmAction = useCallback(
    async (confirmed: boolean, modifications?: Record<string, unknown>): Promise<ActionResult> => {
      if (!store.pendingAction) {
        return { success: false, message: 'Nu există acțiune în așteptare.' };
      }

      store.setLoading(true);

      try {
        const messageId = store.messages.find((m) => m.proposedAction?.status === 'Proposed')?.id;

        if (!messageId) {
          throw new Error('Message not found');
        }

        const result = await confirmActionMutation({
          variables: {
            input: {
              messageId,
              confirmed,
              modifications,
            },
          },
        });

        const actionResult = result.data?.confirmAction;

        // Clear pending action
        store.setPendingAction(null);

        // Add confirmation message
        store.addMessage({
          id: `confirm-${Date.now()}`,
          role: 'Assistant',
          content: actionResult.message,
          createdAt: new Date().toISOString(),
        });

        return actionResult;
      } catch (error) {
        store.setError(
          error instanceof Error ? error.message : 'A apărut o eroare la executarea acțiunii.'
        );
        return {
          success: false,
          message: 'A apărut o eroare.',
          error: error instanceof Error ? error.message : 'Unknown error',
        };
      } finally {
        store.setLoading(false);
      }
    },
    [store, confirmActionMutation]
  );

  return {
    // State
    isOpen: store.isOpen,
    isExpanded: store.isExpanded,
    isLoading: store.isLoading,
    error: store.error,
    messages: store.messages,
    pendingAction: store.pendingAction,
    suggestedFollowUps, // From local state, updated by sendMessage
    unreadCount: store.unreadCount,

    // Actions
    toggleOpen: store.toggleOpen,
    toggleExpanded: store.toggleExpanded,
    sendMessage,
    confirmAction,
    clearConversation: store.clearConversation,
    setContext: store.setContext,

    // Computed
    hasActiveConversation: !!store.conversationId,
    hasPendingConfirmation: !!store.pendingAction,
  };
}
```

## Acceptance Criteria

- [x] Hook connects store to GraphQL operations
- [x] Optimistic updates for user messages
- [x] Conversation loaded on first open
- [x] Error handling with Romanian messages
- [x] Action confirmation flow works
- [x] Context updates trigger conversation refresh if needed
- [x] Unit tests with mocked Apollo client

## Files to Create

- `apps/web/src/hooks/useAssistant.ts`
- `apps/web/src/hooks/useAssistant.test.ts`

## Testing

```typescript
describe('useAssistant', () => {
  it('sends message and adds response');
  it('handles send message error');
  it('confirms action and clears pending');
  it('rejects action and adds message');
  it('loads conversation on open');
  it('updates context without resetting conversation');
});
```

## Session Log

### Session 1 (2025-12-20)

**Work Completed:**

1. Created `apps/web/src/hooks/useAssistant.ts` with:
   - GraphQL fragments, queries, and mutations for AI assistant API
   - `useAssistant` hook connecting Zustand store to GraphQL layer
   - Optimistic updates for user messages
   - Async conversation loading on first open
   - Action confirmation/rejection with store updates
   - Error handling with Romanian error messages
   - Type exports: `ActionResult`, `UseAssistantReturn`

2. Created `apps/web/src/hooks/useAssistant.test.tsx` with:
   - 14 unit tests covering all hook functionality
   - Tests for: initial state, toggle open/expanded, set context, clear conversation
   - Tests for: send message (optimistic), error handling, action confirm/reject
   - Tests for: conversation loading, context preservation, computed properties

**Test Results:**

- All 14 tests passing

**Files Created:**

- `apps/web/src/hooks/useAssistant.ts`
- `apps/web/src/hooks/useAssistant.test.tsx`

**TypeScript:**

- No compilation errors in useAssistant files

#### Local Verification Status

| Step           | Status     | Notes                                   |
| -------------- | ---------- | --------------------------------------- |
| Prod data test | ⬜ Pending | Requires frontend integration (OPS-071) |
| Preflight      | ⬜ Pending | Unit tests pass (14/14)                 |
| Docker test    | ⬜ Pending |                                         |

**Verified**: Partial (unit tests pass, awaiting integration with UI components)
