# OPS-075: Document Intent Handler

**Status:** Implemented | **Priority:** P2-Medium | **Type:** Feature
**Created:** 2025-12-20 | **Depends on:** OPS-066, OPS-071, OPS-077

> **Note (OPS-077):** Document generation uses `documentGenerationService` created in OPS-077.
> Document search uses existing `searchService` with hybrid search mode.

## Summary

Implement the intent handler for document search, summarization, and generation.

## Background

Users should be able to:

- "Găsește contractul de reprezentare din dosarul Ionescu"
- "Rezumă acest document"
- "Generează o cerere de chemare în judecată"
- "Ce documente am în acest dosar?"

This handler leverages existing SearchService and DocumentGenerationService.

## Requirements

### Handler Implementation

```typescript
// services/gateway/src/services/intent-handlers/document.handler.ts

import { prisma } from '@legal-platform/database';
import { searchService, SearchMode } from '../search.service';
import { documentGenerationService } from '../document-generation.service';
import { aiService } from '../ai.service';
import type { AssistantContext, UserContext, HandlerResult } from './types'; // From OPS-072

// ============================================================================
// Types
// ============================================================================

interface DocumentHandlerParams {
  // For FindDocument
  query?: string;
  documentType?: string; // contract, cerere, sentinta, etc.

  // For SummarizeDocument
  documentId?: string;

  // For GenerateDocument
  templateType?: 'Contract' | 'Motion' | 'Letter' | 'Memo' | 'Pleading';
  instructions?: string;
}

// ============================================================================
// Handler
// ============================================================================

export class DocumentIntentHandler {
  async handleFindDocument(
    params: DocumentHandlerParams,
    context: AssistantContext,
    userContext: UserContext
  ): Promise<HandlerResult> {
    // Note: searchService uses SearchMode enum, not string
    const results = await searchService.search({
      query: params.query || params.documentType || '',
      firmId: userContext.firmId,
      searchMode: SearchMode.HYBRID,
      filters: {
        caseIds: context.currentCaseId ? [context.currentCaseId] : undefined,
        documentTypes: params.documentType ? [params.documentType] : undefined,
      },
      limit: 5,
    });

    const documents = results.results.filter((r) => r.__typename === 'DocumentSearchResult');

    if (documents.length === 0) {
      return {
        success: true,
        message: 'Nu am găsit documente care să corespundă căutării.',
      };
    }

    const docList = documents
      .map((d) => `• ${d.document.fileName} (scor: ${Math.round(d.score * 100)}%)`)
      .join('\n');

    return {
      success: true,
      data: documents,
      message: `Am găsit ${documents.length} documente:\n${docList}\n\nDoriți să deschid unul dintre ele?`,
    };
  }

  async handleSummarizeDocument(
    params: DocumentHandlerParams,
    context: AssistantContext,
    userContext: UserContext
  ): Promise<HandlerResult> {
    const documentId = params.documentId || context.currentDocumentId;

    if (!documentId) {
      return {
        success: false,
        message: 'Selectați documentul pe care doriți să-l rezumați.',
      };
    }

    // Get document content
    const document = await prisma.document.findUnique({
      where: { id: documentId },
      select: { id: true, fileName: true, textContent: true, firmId: true },
    });

    if (!document || document.firmId !== userContext.firmId) {
      return {
        success: false,
        message: 'Documentul nu a fost găsit.',
      };
    }

    if (!document.textContent) {
      return {
        success: false,
        message: 'Documentul nu are conținut text extractabil.',
      };
    }

    // Generate summary via AI
    const summary = await aiService.generate({
      model: 'sonnet',
      prompt: `
Rezumă următorul document juridic în română, evidențiind:
1. Tipul documentului
2. Părțile implicate
3. Obiectul principal
4. Obligațiile cheie
5. Termene importante

Document:
${document.textContent.substring(0, 10000)}
      `,
    });

    return {
      success: true,
      data: { documentId, summary: summary.content },
      message: `**Rezumat: ${document.fileName}**\n\n${summary.content}`,
    };
  }

  async handleGenerateDocument(
    params: DocumentHandlerParams,
    context: AssistantContext,
    userContext: UserContext
  ): Promise<HandlerResult> {
    if (!params.templateType) {
      return {
        success: false,
        message: 'Specificați tipul documentului: contract, cerere, scrisoare, notă.',
      };
    }

    // Get case context for document generation
    const caseData = context.currentCaseId
      ? await prisma.case.findUnique({
          where: { id: context.currentCaseId },
          include: { client: true, actors: { include: { contact: true } } },
        })
      : null;

    // Build document preview
    const preview = {
      tip: this.translateDocType(params.templateType),
      dosar: caseData?.title || 'Fără dosar',
      client: caseData?.client?.name || 'Nespecificat',
    };

    return {
      success: true,
      proposedAction: {
        type: 'GenerateDocument',
        displayText: `Generează ${this.translateDocType(params.templateType)}`,
        payload: {
          templateType: params.templateType,
          caseId: context.currentCaseId,
          instructions: params.instructions,
          caseContext: caseData
            ? {
                title: caseData.title,
                caseNumber: caseData.caseNumber,
                clientName: caseData.client?.name,
                actors: caseData.actors.map((a) => ({
                  role: a.role,
                  name: a.contact.name,
                })),
              }
            : null,
        },
        confirmationPrompt: 'Generez acest document?',
        entityPreview: preview,
      },
    };
  }

  async handleListDocuments(
    context: AssistantContext,
    userContext: UserContext
  ): Promise<HandlerResult> {
    if (!context.currentCaseId) {
      return {
        success: false,
        message: 'Deschideți un dosar pentru a vedea documentele.',
      };
    }

    const documents = await prisma.caseDocument.findMany({
      where: { caseId: context.currentCaseId },
      include: { document: true },
      orderBy: { createdAt: 'desc' },
      take: 10,
    });

    if (documents.length === 0) {
      return {
        success: true,
        message: 'Nu există documente în acest dosar.',
      };
    }

    const docList = documents
      .map((d) => `• ${d.document.fileName} (${this.formatDate(d.createdAt)})`)
      .join('\n');

    return {
      success: true,
      data: documents,
      message: `Documente în dosar (${documents.length}):\n${docList}`,
    };
  }

  // Helpers
  private translateDocType(type: string): string {
    const types: Record<string, string> = {
      Contract: 'Contract',
      Motion: 'Cerere',
      Letter: 'Scrisoare',
      Memo: 'Notă internă',
      Pleading: 'Întâmpinare',
    };
    return types[type] || type;
  }

  private formatDate(date: Date): string {
    return date.toLocaleDateString('ro-RO', { day: 'numeric', month: 'short' });
  }
}

export const documentIntentHandler = new DocumentIntentHandler();
```

## Acceptance Criteria

- [x] DocumentIntentHandler class implemented
- [x] FindDocument uses hybrid search
- [x] SummarizeDocument calls AI service
- [x] GenerateDocument creates action with preview
- [x] ListDocuments works for current case
- [x] Context document ID used when available
- [x] Firm isolation enforced
- [x] Romanian output formatting
- [x] Unit tests for all intent types (20 tests, all passing)

## Files Created

- `services/gateway/src/services/intent-handlers/document.handler.ts`
- `services/gateway/src/services/intent-handlers/document.handler.test.ts`

## Implementation Notes

The implementation differs slightly from the specification:

1. **Document text content**: Uses `metadata.extractedText` instead of `textContent` field (Document model stores extracted text in JSON metadata)
2. **CaseDocument ordering**: Uses `linkedAt` instead of `createdAt` (schema uses `linkedAt` for when document was linked to case)
3. **Search interface**: Uses positional parameters `(query, firmId, mode, filters, limit, offset)` rather than object pattern
4. **Added `Other` document type**: Matches `DocumentType` from `document-generation.service.ts`

## Session Log

- [2025-12-20T09:00] Session 1 started. Status: Open
- [2025-12-20T09:05] Created `document.handler.ts` following pattern from `task.handler.ts`
- [2025-12-20T09:10] Created `document.handler.test.ts` with 20 unit tests
- [2025-12-20T09:15] Fixed TypeScript errors:
  - Document model uses `metadata.extractedText` not `textContent`
  - CaseDocument uses `linkedAt` not `createdAt`
- [2025-12-20T09:20] Fixed test mocks to match actual schema fields
- [2025-12-20T09:22] All 20 tests passing
- [2025-12-20T09:25] TypeScript compilation verified - all packages pass

#### Local Verification Status

| Step           | Status    | Notes                                    |
| -------------- | --------- | ---------------------------------------- |
| Prod data test | ⬜ N/A    | Backend service, no UI to test           |
| Preflight      | ✅ Passed | TypeScript compiles, all tests pass      |
| Docker test    | ⬜ N/A    | Backend service, verified via type-check |

**Verified**: Yes (backend service - TypeScript compilation verified)
