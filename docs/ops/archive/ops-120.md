# OPS-120: Notification Engine

## Summary

Build a background notification engine that processes user activity events and sends proactive notifications (push, in-app, email digest) based on AI-powered importance assessment.

## Problem

Currently, users only learn about important events when they:

1. Open the app and manually check
2. Ask the AI assistant
3. Receive external notifications (court emails, etc.)

There's no proactive alerting for:

- New court emails requiring immediate attention
- Approaching deadlines
- Overdue tasks
- Important document arrivals
- Case status changes

## Solution

A notification engine that:

1. Processes `UserActivityEvent` records (from OPS-116)
2. Uses AI to assess notification worthiness
3. Batches low-priority items, sends urgent ones immediately
4. Supports multiple channels (push, in-app, email digest)

## Architecture

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚    Background Worker (cron)     â”‚
                    â”‚    Runs every 5 minutes         â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   For each user with events:    â”‚
                    â”‚   1. Load unnotified events     â”‚
                    â”‚   2. Load user context          â”‚
                    â”‚   3. AI assessment (optional)   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚                     â”‚                     â”‚
              â–¼                     â–¼                     â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  URGENT events  â”‚   â”‚  HIGH events    â”‚   â”‚  NORMAL events  â”‚
    â”‚  â†’ Push NOW     â”‚   â”‚  â†’ Push if      â”‚   â”‚  â†’ Batch for    â”‚
    â”‚  â†’ Mark notifiedâ”‚   â”‚    online       â”‚   â”‚    daily digest â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Implementation

### Notification Service

```typescript
// services/gateway/src/services/notification.service.ts

export class NotificationService {
  /**
   * Process pending events for all users (called by cron)
   */
  async processAllPendingEvents(): Promise<void> {
    // Find users with unnotified events
    const usersWithEvents = await prisma.userActivityEvent.groupBy({
      by: ['userId'],
      where: { notified: false },
      _count: true,
    });

    for (const { userId } of usersWithEvents) {
      await this.processUserEvents(userId);
    }
  }

  /**
   * Process events for a single user
   */
  async processUserEvents(userId: string): Promise<void> {
    const events = await activityEventService.getUnnotified(userId, { limit: 50 });
    if (events.length === 0) return;

    // Group by importance
    const urgent = events.filter((e) => e.importance === 'URGENT');
    const high = events.filter((e) => e.importance === 'HIGH');
    const normal = events.filter((e) => e.importance === 'NORMAL');

    // Process urgent immediately
    for (const event of urgent) {
      await this.sendPushNotification(userId, event);
      await activityEventService.markNotified([event.id]);
    }

    // Process high if user is online or batched
    const userOnline = await this.isUserOnline(userId);
    if (userOnline && high.length > 0) {
      await this.sendInAppNotification(userId, high);
      await activityEventService.markNotified(high.map((e) => e.id));
    }

    // Normal events go to daily digest (mark as notified to prevent reprocessing)
    if (normal.length > 0) {
      await this.queueForDigest(userId, normal);
      await activityEventService.markNotified(normal.map((e) => e.id));
    }
  }

  /**
   * Send push notification for urgent event
   */
  private async sendPushNotification(userId: string, event: UserActivityEvent): Promise<void> {
    const notification = this.formatNotification(event);

    // Get user's push subscriptions
    const subscriptions = await prisma.pushSubscription.findMany({
      where: { userId, active: true },
    });

    for (const sub of subscriptions) {
      await webpush.sendNotification(sub.subscription, JSON.stringify(notification));
    }

    // Also send in-app
    await this.createInAppNotification(userId, notification);
  }

  /**
   * Send in-app notification batch
   */
  private async sendInAppNotification(userId: string, events: UserActivityEvent[]): Promise<void> {
    const notification =
      events.length === 1
        ? this.formatNotification(events[0])
        : this.formatBatchNotification(events);

    await this.createInAppNotification(userId, notification);
  }

  /**
   * Queue events for daily digest email
   */
  private async queueForDigest(userId: string, events: UserActivityEvent[]): Promise<void> {
    await prisma.digestQueue.createMany({
      data: events.map((e) => ({
        userId,
        eventId: e.id,
        eventType: e.eventType,
        eventTitle: e.entityTitle,
        eventData: e.metadata,
        scheduledFor: this.getNextDigestTime(),
      })),
    });
  }

  /**
   * Format notification content
   */
  private formatNotification(event: UserActivityEvent): NotificationContent {
    const templates: Record<ActivityEventType, (e: UserActivityEvent) => NotificationContent> = {
      EMAIL_FROM_COURT: (e) => ({
        title: 'âš–ï¸ Email de la instanÈ›Äƒ',
        body: e.entityTitle || 'Ai primit un email de la instanÈ›Äƒ',
        icon: 'court',
        action: { type: 'open_email', entityId: e.entityId },
      }),

      TASK_OVERDUE: (e) => ({
        title: 'âš ï¸ SarcinÄƒ Ã®ntÃ¢rziatÄƒ',
        body: e.entityTitle || 'Ai o sarcinÄƒ Ã®ntÃ¢rziatÄƒ',
        icon: 'warning',
        action: { type: 'open_task', entityId: e.entityId },
      }),

      TASK_DUE_TODAY: (e) => ({
        title: 'ğŸ“… Termen azi',
        body: e.entityTitle || 'Ai o sarcinÄƒ cu termen azi',
        icon: 'calendar',
        action: { type: 'open_task', entityId: e.entityId },
      }),

      CASE_HEARING_TODAY: (e) => ({
        title: 'âš–ï¸ È˜edinÈ›Äƒ azi',
        body: e.entityTitle || 'Ai o È™edinÈ›Äƒ programatÄƒ azi',
        icon: 'court',
        action: { type: 'open_case', entityId: e.entityId },
      }),

      EMAIL_RECEIVED: (e) => ({
        title: 'ğŸ“§ Email nou',
        body: e.entityTitle || 'Ai primit un email nou',
        icon: 'email',
        action: { type: 'open_email', entityId: e.entityId },
      }),

      DOCUMENT_UPLOADED: (e) => ({
        title: 'ğŸ“„ Document nou',
        body: e.entityTitle || 'Un document nou a fost adÄƒugat',
        icon: 'document',
        action: { type: 'open_document', entityId: e.entityId },
      }),

      TASK_ASSIGNED: (e) => ({
        title: 'âœ… SarcinÄƒ nouÄƒ',
        body: e.entityTitle || 'Èši-a fost asignatÄƒ o sarcinÄƒ nouÄƒ',
        icon: 'task',
        action: { type: 'open_task', entityId: e.entityId },
      }),

      // ... other event types
    };

    const formatter = templates[event.eventType] || this.defaultFormatter;
    return formatter(event);
  }

  private formatBatchNotification(events: UserActivityEvent[]): NotificationContent {
    const typeCount = events.reduce(
      (acc, e) => {
        acc[e.eventType] = (acc[e.eventType] || 0) + 1;
        return acc;
      },
      {} as Record<string, number>
    );

    const parts: string[] = [];
    if (typeCount.EMAIL_RECEIVED) parts.push(`${typeCount.EMAIL_RECEIVED} emailuri`);
    if (typeCount.DOCUMENT_UPLOADED) parts.push(`${typeCount.DOCUMENT_UPLOADED} documente`);
    if (typeCount.TASK_ASSIGNED) parts.push(`${typeCount.TASK_ASSIGNED} sarcini`);

    return {
      title: 'ğŸ”” Activitate nouÄƒ',
      body: parts.join(', '),
      icon: 'notification',
      action: { type: 'open_inbox' },
    };
  }
}

export const notificationService = new NotificationService();
```

### AI-Powered Importance Override (Optional)

For edge cases, use AI to assess importance:

```typescript
/**
 * Use AI to assess if an event warrants immediate notification
 * Only called for ambiguous cases
 */
async assessWithAI(event: UserActivityEvent, userContext: UserContextData): Promise<EventImportance> {
  const prompt = `
Tu eÈ™ti un asistent pentru un avocat. EvalueazÄƒ dacÄƒ acest eveniment necesitÄƒ o notificare imediatÄƒ.

Contextul utilizatorului:
- Are ${userContext.overdueTasksCount} sarcini Ã®ntÃ¢rziate
- Are ${userContext.todayEvents.length} evenimente programate azi
- ${userContext.urgentItems.length > 0 ? 'Deja are urgenÈ›e' : 'Nu are urgenÈ›e'}

Eveniment nou:
- Tip: ${event.eventType}
- Titlu: ${event.entityTitle}
- Detalii: ${JSON.stringify(event.metadata)}

RÄƒspunde cu unul din: URGENT, HIGH, NORMAL, LOW
- URGENT: NecesitÄƒ atenÈ›ie imediatÄƒ (ex: email de la instanÈ›Äƒ, termen mÃ¢ine)
- HIGH: Important dar poate aÈ™tepta cÃ¢teva ore
- NORMAL: Include Ã®n rezumatul zilnic
- LOW: Poate fi ignorat
`;

  const response = await anthropic.messages.create({
    model: 'claude-haiku-3',
    max_tokens: 10,
    messages: [{ role: 'user', content: prompt }],
  });

  const result = response.content[0].type === 'text'
    ? response.content[0].text.trim().toUpperCase()
    : 'NORMAL';

  return ['URGENT', 'HIGH', 'NORMAL', 'LOW'].includes(result)
    ? result as EventImportance
    : 'NORMAL';
}
```

### Background Job

```typescript
// services/gateway/src/jobs/notification-processor.job.ts

import cron from 'node-cron';
import { notificationService } from '../services/notification.service';

// Run every 5 minutes
cron.schedule('*/5 * * * *', async () => {
  try {
    logger.info('Starting notification processing');
    await notificationService.processAllPendingEvents();
    logger.info('Notification processing complete');
  } catch (error) {
    logger.error('Notification processing failed', { error });
  }
});

// Daily digest at 7:00 AM Bucharest time
cron.schedule('0 7 * * *', async () => {
  try {
    logger.info('Starting daily digest generation');
    await notificationService.sendDailyDigests();
    logger.info('Daily digest complete');
  } catch (error) {
    logger.error('Daily digest failed', { error });
  }
});
```

### In-App Notification UI

```typescript
// GraphQL schema addition

type InAppNotification {
  id: ID!
  title: String!
  body: String!
  icon: String
  read: Boolean!
  action: NotificationAction
  createdAt: DateTime!
}

type NotificationAction {
  type: String!
  entityId: ID
}

type Query {
  unreadNotifications: [InAppNotification!]!
  notificationCount: Int!
}

type Mutation {
  markNotificationRead(id: ID!): InAppNotification!
  markAllNotificationsRead: Boolean!
}

type Subscription {
  notificationReceived: InAppNotification!
}
```

## Data Model Additions

```prisma
model InAppNotification {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])

  title       String
  body        String
  icon        String?

  read        Boolean  @default(false)
  actionType  String?
  actionData  Json?

  createdAt   DateTime @default(now())

  @@index([userId, read, createdAt])
}

model PushSubscription {
  id           String   @id @default(cuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id])

  endpoint     String
  subscription Json     // { endpoint, keys: { p256dh, auth } }
  active       Boolean  @default(true)

  createdAt    DateTime @default(now())

  @@index([userId, active])
}

model DigestQueue {
  id           String   @id @default(cuid())
  userId       String

  eventId      String
  eventType    String
  eventTitle   String?
  eventData    Json?

  scheduledFor DateTime
  sent         Boolean  @default(false)

  createdAt    DateTime @default(now())

  @@index([userId, scheduledFor, sent])
}
```

## Files to Create/Modify

### New Files

- `services/gateway/src/services/notification.service.ts`
- `services/gateway/src/jobs/notification-processor.job.ts`
- `services/gateway/src/graphql/resolvers/notification.resolvers.ts`
- `services/gateway/src/graphql/schema/notification.graphql`
- `packages/database/prisma/migrations/XXX_notifications/migration.sql`

### Modified Files

- `packages/database/prisma/schema.prisma` - Add notification models
- `services/gateway/src/index.ts` - Register cron jobs

## Dependencies

- OPS-115: AI Context Files - Data Model
- OPS-116: Event Emission Infrastructure
- OPS-117: User Daily Context Service (for AI assessment context)

## Parallelization

Can be worked on after OPS-116 and OPS-117 are substantially complete. The data model additions (InAppNotification, PushSubscription, DigestQueue) can be added to OPS-115's migration.

## Success Metrics

- [ ] Urgent events notified within 5 minutes
- [ ] Push notification delivery rate >95%
- [ ] Daily digest emails sent by 7:30 AM
- [ ] User engagement with notifications >30%
- [ ] False positive rate <10% (notifications that weren't useful)

## Future Enhancements

1. **User preferences**: Allow users to configure notification thresholds
2. **Quiet hours**: Respect user's do-not-disturb settings
3. **Notification grouping**: Intelligent grouping of related events
4. **AI learning**: Learn from user's notification interactions

---

## Local Verification Status

| Step           | Status     | Date       | Notes             |
| -------------- | ---------- | ---------- | ----------------- |
| Prod data test | â¬œ Pending |            |                   |
| Preflight      | âœ… Passed  | 2024-12-23 | All checks passed |
| Docker test    | âœ… Passed  | 2024-12-23 | Part of preflight |

**Verified**: Partial (preflight passes, needs prod data testing)

---

## Session Log

### 2024-12-23 - Session 1: Full Implementation

**Work Completed:**

- Added Prisma models for notifications:
  - `InAppNotification` - in-app notification storage
  - `PushSubscription` - web push subscription management
  - `DigestQueue` - daily digest email queue
- Added migration: `20251223220000_add_notification_models`
- Added User model relations for the new models
- Created `ActivityNotificationService` (`activity-notification.service.ts`):
  - Processes events by importance (URGENT/HIGH/NORMAL)
  - Formats notifications in Romanian
  - Manages push subscriptions
  - Handles daily digest queue
  - Redis-based online user tracking
- Created `notification-processor.worker.ts`:
  - Runs every 5 minutes to process events
  - Checks for pending digests every hour
  - Cleanup function for old data
- Extended GraphQL schema (`notification.graphql`):
  - `InAppNotification` type
  - `NotificationAction` type
  - `PushSubscriptionInput` input
  - Queries: `inAppNotifications`, `inAppNotificationCount`
  - Mutations: `markInAppNotificationRead`, `markAllInAppNotificationsRead`, `subscribeToPush`, `unsubscribeFromPush`
- Extended notification resolvers with new queries/mutations
- Registered worker in gateway `index.ts`

**Technical Notes:**

- Named service `ActivityNotificationService` to avoid conflict with existing `NotificationService` (for case approvals)
- Worker starts with 5-minute interval, configurable via `NOTIFICATION_PROCESSOR_INTERVAL_MS` env var
- Push notifications are stubbed (logs to console), ready for web-push integration

**Preflight Status:** âœ… All 6 checks passed, 2 warnings (pre-existing)

### 2024-12-23 - Issue Created

- Created from `/ops-ideate` session exploring AI context optimization
- Part of AI Context Files epic (OPS-115 â†’ OPS-120)
