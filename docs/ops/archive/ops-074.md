# OPS-074: Email Intent Handler

**Status:** Resolved | **Priority:** P2-Medium | **Type:** Feature
**Created:** 2025-12-20 | **Depends on:** OPS-066, OPS-071, OPS-077

> **Note (OPS-077):** Thread summaries use `generateCaseConversationSummary` mutation from
> `communication-intelligence.resolvers.ts`. Email drafting uses `emailDraftingService` wrapper
> created in OPS-077 (extracts logic from `email-drafting.resolvers.ts`).

## Summary

Implement the intent handler for email search, thread summarization, and draft generation.

## Background

Users should be able to:

- "Caută emailurile de la instanță din acest dosar"
- "Rezumă discuția cu clientul despre contract"
- "Scrie un răspuns formal la emailul selectat"
- "Ce emailuri noi am primit azi?"

This handler leverages existing EmailSearchService and EmailDraftingService.

## Requirements

### Handler Implementation

```typescript
// services/gateway/src/services/intent-handlers/email.handler.ts

import { prisma } from '@legal-platform/database';
import { emailSearchService } from '../email-search.service';
import { emailDraftingService } from '../email-drafting.service';
import { aiService } from '../ai.service';
import type { AssistantContext, UserContext, HandlerResult } from './types'; // From OPS-072

// Note: Thread summaries use the generateCaseConversationSummary mutation
// from communication-intelligence.resolvers.ts. We call it via the
// communicationIntelligenceService wrapper.

// ============================================================================
// Types
// ============================================================================

interface EmailHandlerParams {
  // For SearchEmails
  // Note: EmailSearchFilters interface uses: userId, caseId, search, hasAttachments,
  // isUnread, dateFrom, dateTo, uncategorizedOnly, importance
  query?: string;
  sender?: string; // Will be used in search text, not as separate filter
  timeRange?: 'today' | 'week' | 'month' | 'all';
  hasAttachments?: boolean;
  isUnread?: boolean; // Actual field name (not unreadOnly)

  // For SummarizeThread
  threadId?: string;
  emailId?: string;

  // For DraftEmail
  replyToEmailId?: string;
  tone?: 'formal' | 'professional' | 'brief';
  recipientType?: 'Client' | 'Court' | 'OpposingCounsel' | 'ThirdParty';
  instructions?: string;
}

// ============================================================================
// Handler
// ============================================================================

export class EmailIntentHandler {
  async handleSearchEmails(
    params: EmailHandlerParams,
    context: AssistantContext,
    userContext: UserContext
  ): Promise<HandlerResult> {
    // Build search query - combine query and sender if both provided
    const searchText = [params.query, params.sender].filter(Boolean).join(' ');
    const dateRange = this.getDateRange(params.timeRange);

    // Note: emailSearchService.searchEmails uses EmailSearchFilters interface
    // Returns EmailSearchResponse: { emails, totalCount, hasMore }
    const results = await emailSearchService.searchEmails(
      {
        userId: userContext.userId,
        caseId: context.currentCaseId,
        search: searchText || undefined,
        hasAttachments: params.hasAttachments,
        isUnread: params.isUnread,
        dateFrom: dateRange.start,
        dateTo: dateRange.end,
      },
      10
    );

    if (results.totalCount === 0) {
      return {
        success: true,
        message: 'Nu am găsit emailuri care să corespundă căutării.',
      };
    }

    // Note: Email model has `from` (Json: {name?, address}) not `senderName`
    // Field is `receivedDateTime` not `receivedAt`
    const emailList = results.emails
      .map(
        (e) =>
          `• ${e.from.name || e.from.address}: "${e.subject}" (${this.formatDate(e.receivedDateTime)})`
      )
      .join('\n');

    return {
      success: true,
      data: results,
      message: `Am găsit ${results.totalCount} emailuri:\n${emailList}`,
    };
  }

  async handleSummarizeThread(
    params: EmailHandlerParams,
    context: AssistantContext,
    userContext: UserContext
  ): Promise<HandlerResult> {
    const emailId = params.emailId || context.selectedEmailId;

    if (!emailId) {
      return {
        success: false,
        message: 'Selectați un email sau specificați thread-ul pentru rezumat.',
      };
    }

    // Get the email and its thread
    const email = await prisma.email.findUnique({
      where: { id: emailId },
      include: { case: true },
    });

    if (!email || !email.caseId) {
      return {
        success: false,
        message: 'Emailul nu a fost găsit sau nu este asociat unui dosar.',
      };
    }

    // Use the communication intelligence service for thread summary
    // This calls generateCaseConversationSummary internally
    const summary = await this.generateThreadSummary(email.caseId, emailId, userContext);

    return {
      success: true,
      data: summary,
      message: `**Rezumat conversație:**\n\n${summary.summary}\n\n**Puncte cheie:**\n${summary.keyPoints.map((p: string) => `• ${p}`).join('\n')}`,
    };
  }

  /**
   * Generate thread summary using AI service.
   * Implementation pattern from communication-intelligence.resolvers.ts:
   * 1. Fetch all emails in the conversation thread
   * 2. Build context with email content and metadata
   * 3. Call aiService.generate() with summarization prompt
   */
  private async generateThreadSummary(
    caseId: string,
    emailId: string,
    userContext: UserContext
  ): Promise<{ summary: string; keyPoints: string[] }> {
    // Get the thread emails
    const threadEmails = await prisma.email.findMany({
      where: {
        caseId,
        userId: userContext.userId,
        conversationId: (
          await prisma.email.findUnique({
            where: { id: emailId },
            select: { conversationId: true },
          })
        )?.conversationId,
      },
      orderBy: { receivedDateTime: 'asc' },
    });

    if (threadEmails.length === 0) {
      return { summary: 'Nu există emailuri în acest thread.', keyPoints: [] };
    }

    // Build thread context for AI
    const threadContext = threadEmails
      .map((e) => {
        const from = e.from as { name?: string; address: string };
        return `[${e.receivedDateTime.toISOString()}] ${from.name || from.address}:\n${e.bodyPreview}`;
      })
      .join('\n\n---\n\n');

    // Generate summary via AI
    const result = await aiService.generate({
      model: 'sonnet',
      prompt: `
Analizează următoarea conversație email și generează:
1. Un rezumat concis (2-3 propoziții)
2. Lista punctelor cheie (maxim 5)

Conversație:
${threadContext}

Răspunde în format JSON:
{
  "summary": "...",
  "keyPoints": ["...", "..."]
}
      `,
    });

    // Parse AI response
    try {
      const parsed = JSON.parse(result.content);
      return {
        summary: parsed.summary || 'Rezumat indisponibil.',
        keyPoints: parsed.keyPoints || [],
      };
    } catch {
      return {
        summary: result.content,
        keyPoints: [],
      };
    }
  }

  async handleDraftEmail(
    params: EmailHandlerParams,
    context: AssistantContext,
    userContext: UserContext
  ): Promise<HandlerResult> {
    const emailId = params.replyToEmailId || context.selectedEmailId;

    if (!emailId) {
      return {
        success: false,
        message: 'Selectați emailul la care doriți să răspundeți.',
      };
    }

    // Generate draft
    // Note: emailDraftingService.generateDraft takes:
    // - input: GenerateDraftInput { emailId, tone?, recipientType?, instructions? }
    // - userContext: UserContext { userId, firmId, accessToken? }
    const draft = await emailDraftingService.generateDraft(
      {
        emailId,
        tone: params.tone || 'Professional',
        recipientType: params.recipientType || 'Client',
        instructions: params.instructions,
      },
      { userId: userContext.userId, firmId: userContext.firmId }
    );

    return {
      success: true,
      proposedAction: {
        type: 'DraftEmail',
        displayText: 'Răspuns email generat',
        payload: {
          emailId,
          draftId: draft.id,
          subject: draft.subject,
          body: draft.body,
          tone: params.tone || 'professional',
        },
        confirmationPrompt: 'Folosiți acest răspuns?',
        entityPreview: {
          subiect: draft.subject,
          ton: this.translateTone(params.tone || 'professional'),
          previzualizare: draft.body.substring(0, 200) + '...',
        },
      },
    };
  }

  async handleRecentEmails(
    context: AssistantContext,
    userContext: UserContext
  ): Promise<HandlerResult> {
    // Note: emailSearchService.searchEmails uses EmailSearchFilters interface
    const results = await emailSearchService.searchEmails(
      {
        userId: userContext.userId,
        caseId: context.currentCaseId,
        dateFrom: new Date(Date.now() - 24 * 60 * 60 * 1000),
        isUnread: true,
      },
      10
    );

    if (results.totalCount === 0) {
      return {
        success: true,
        message: 'Nu aveți emailuri necitite în ultimele 24 de ore.',
      };
    }

    // Note: Email model has `from` (Json: {name?, address}) not `senderName`
    const emailList = results.emails
      .map((e) => `• ${e.from.name || e.from.address}: "${e.subject}"`)
      .join('\n');

    return {
      success: true,
      data: results,
      message: `Aveți ${results.totalCount} emailuri noi:\n${emailList}`,
    };
  }

  // Helpers
  // Note: Returns dateFrom/dateTo compatible with EmailSearchFilters
  private getDateRange(timeRange?: string): { start?: Date; end?: Date } {
    const now = new Date();
    switch (timeRange) {
      case 'today':
        return { start: new Date(new Date().setHours(0, 0, 0, 0)) };
      case 'week':
        return { start: new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000) };
      case 'month':
        return { start: new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000) };
      default:
        return {};
    }
  }

  private translateTone(tone: string): string {
    const tones: Record<string, string> = {
      formal: 'Formal',
      professional: 'Profesional',
      brief: 'Scurt',
    };
    return tones[tone] || tone;
  }

  // Note: Email model uses receivedDateTime (Date), not receivedAt
  private formatDate(date: Date): string {
    return date.toLocaleDateString('ro-RO', { day: 'numeric', month: 'short' });
  }
}

export const emailIntentHandler = new EmailIntentHandler();
```

## Acceptance Criteria

- [x] EmailIntentHandler class implemented
- [x] SearchEmails uses EmailSearchService
- [x] SummarizeThread uses AI Service (ThreadAnalysis/CommunicationIntelligence)
- [x] DraftEmail uses EmailDraftingService
- [x] Recent emails query works
- [x] Context email ID used when available
- [x] Tone selection for drafts
- [x] Action preview for drafts
- [x] Romanian output formatting
- [x] Unit tests for all intent types (30 tests passing)

## Files to Create

- `services/gateway/src/services/intent-handlers/email.handler.ts`
- `services/gateway/src/services/intent-handlers/email.handler.test.ts`

## Session Log

- [2025-12-20] Session 1 started. Implemented EmailIntentHandler with 4 methods:
  - `handleSearchEmails`: Search emails with filters (query, sender, timeRange, attachments, unread)
  - `handleSummarizeThread`: Summarize email thread using AI service with CommunicationIntelligence operation type
  - `handleDraftEmail`: Generate draft reply using EmailDraftingService, returns proposed action with confirmation
  - `handleRecentEmails`: Get recent unread emails from last 24 hours
- Created comprehensive unit tests (30 tests) with Jest mocks
- All tests passing, TypeScript compiles successfully
