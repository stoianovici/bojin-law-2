# OPS-084: Direct Sonnet Conversation with Tool Calling

**Status:** Verifying | **Priority:** P0-Critical | **Type:** Feature
**Created:** 2025-12-21 | **Depends on:** OPS-082, OPS-083 | **Blocks:** OPS-085, OPS-086

## Summary

Replace the two-stage Haiku orchestrator with a single Claude Sonnet conversation using native tool calling. This is the core change that fixes Romanian prompt parsing.

## Background

Current flow:

```
Message → Haiku (intent) → Handler → Haiku (NL parse) → Action
```

New flow:

```
Message → Sonnet (with tools) → Tool Calls → Execute → Response
```

## Requirements

### New AI Assistant Service

```typescript
// services/gateway/src/services/ai-assistant.service.ts

import Anthropic from '@anthropic-ai/sdk';
import { AI_TOOLS, AIToolName } from './ai-tools.schema';
import { buildSystemPrompt } from './ai-system-prompt';
import { ConversationService } from './conversation.service';
import { ToolExecutor } from './tool-executor.service';

interface AssistantContext {
  userId: string;
  firmId: string;
  caseId?: string;
  caseName?: string;
}

interface AssistantResponse {
  message: string;
  pendingAction?: {
    toolName: string;
    parameters: Record<string, unknown>;
    preview: string;
  };
  suggestedFollowUps?: string[];
}

export class AIAssistantService {
  private anthropic: Anthropic;
  private conversationService: ConversationService;
  private toolExecutor: ToolExecutor;

  constructor() {
    this.anthropic = new Anthropic();
    this.conversationService = new ConversationService();
    this.toolExecutor = new ToolExecutor();
  }

  async processMessage(
    conversationId: string,
    userMessage: string,
    context: AssistantContext
  ): Promise<AssistantResponse> {
    // Get conversation history
    const history = await this.conversationService.getMessages(conversationId);

    // Build system prompt with context
    const systemPrompt = buildSystemPrompt({
      currentDate: new Date().toISOString().split('T')[0],
      userName: await this.getUserName(context.userId),
      userRole: await this.getUserRole(context.userId),
      caseId: context.caseId,
      caseName: context.caseName,
    });

    // Add user message to history
    const messages = [
      ...history.map((m) => ({
        role: m.role as 'user' | 'assistant',
        content: m.content,
      })),
      { role: 'user' as const, content: userMessage },
    ];

    // Call Claude Sonnet with tools
    const response = await this.anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 1024,
      system: systemPrompt,
      messages,
      tools: AI_TOOLS.map((t) => ({
        name: t.name,
        description: t.description,
        input_schema: t.input_schema,
      })),
    });

    // Save messages
    await this.conversationService.addMessage(conversationId, 'user', userMessage);

    // Process response
    return this.processResponse(response, conversationId, context);
  }

  private async processResponse(
    response: Anthropic.Message,
    conversationId: string,
    context: AssistantContext
  ): Promise<AssistantResponse> {
    const textBlocks = response.content.filter((b) => b.type === 'text');
    const toolBlocks = response.content.filter((b) => b.type === 'tool_use');

    // If no tool calls, just return the text
    if (toolBlocks.length === 0) {
      const message = textBlocks.map((b) => b.text).join('\n');
      await this.conversationService.addMessage(conversationId, 'assistant', message);
      return { message };
    }

    // Handle tool call - prepare for confirmation
    const toolCall = toolBlocks[0] as Anthropic.ToolUseBlock;
    const preview = await this.toolExecutor.preview(
      toolCall.name as AIToolName,
      toolCall.input as Record<string, unknown>,
      context
    );

    const message = textBlocks.map((b) => b.text).join('\n') || preview.description;

    await this.conversationService.addMessage(conversationId, 'assistant', message, {
      pendingToolCall: {
        id: toolCall.id,
        name: toolCall.name,
        input: toolCall.input,
      },
    });

    return {
      message,
      pendingAction: {
        toolName: toolCall.name,
        parameters: toolCall.input as Record<string, unknown>,
        preview: preview.summary,
      },
    };
  }

  async confirmAction(
    conversationId: string,
    context: AssistantContext
  ): Promise<AssistantResponse> {
    // Get pending tool call from last message
    const lastMessage = await this.conversationService.getLastMessage(conversationId);
    const pendingToolCall = lastMessage?.metadata?.pendingToolCall;

    if (!pendingToolCall) {
      return { message: 'Nu există nicio acțiune de confirmat.' };
    }

    // Execute the tool
    const result = await this.toolExecutor.execute(
      pendingToolCall.name as AIToolName,
      pendingToolCall.input,
      context
    );

    // Clear pending action and add result message
    await this.conversationService.clearPendingAction(conversationId);

    const message = result.success ? result.successMessage : `Eroare: ${result.error}`;

    await this.conversationService.addMessage(conversationId, 'assistant', message);

    return {
      message,
      suggestedFollowUps: result.suggestedFollowUps,
    };
  }

  async rejectAction(conversationId: string): Promise<AssistantResponse> {
    await this.conversationService.clearPendingAction(conversationId);

    const message = 'Am anulat acțiunea. Cu ce altceva te pot ajuta?';
    await this.conversationService.addMessage(conversationId, 'assistant', message);

    return { message };
  }
}
```

## Key Changes from Current Architecture

| Aspect                 | Current (Orchestrator)            | New (Assistant)        |
| ---------------------- | --------------------------------- | ---------------------- |
| Model                  | Haiku for intent, Haiku for parse | Sonnet for everything  |
| Intent detection       | Rigid prompt with examples        | Natural tool selection |
| Parameter extraction   | Second prompt, regex              | Tool input schemas     |
| Romanian understanding | Limited examples                  | Native understanding   |
| Context handling       | Lost between stages               | Single conversation    |
| Code complexity        | 800+ lines across files           | ~200 lines             |

## Migration Notes

1. Keep old orchestrator during migration (feature flag)
2. New service is separate file, no conflicts
3. GraphQL resolvers updated in OPS-086 to use new service
4. Old orchestrator removed in OPS-087

## Acceptance Criteria

- [ ] Single Sonnet call handles intent + parameter extraction
- [ ] Tool calling works for all defined tools
- [ ] Conversation history maintained
- [ ] Pending actions tracked for confirmation
- [ ] Error handling for API failures
- [ ] "adauga un task de finalizat pana vinerea viitoare" works correctly

## Files to Create/Modify

- `services/gateway/src/services/ai-assistant.service.ts` (new)

## Session Log

- [2025-12-21] Issue created
- [2025-12-21] Session 2: Implemented ai-assistant.service.ts with direct Sonnet conversation using native tool calling. Updated GraphQL resolvers to use new service. TypeScript compilation passes. Ready for local verification.
