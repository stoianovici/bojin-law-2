# OPS-055: Chronology Tab Counts - Server-Side Totals

**Status:** Fixing | **Priority:** P1-High | **Type:** Bug
**Created:** 2025-12-19 | **Sessions:** 1 | **Last Active:** 2025-12-19
**Related:** OPS-054 (CaseChronology Integration)

## Summary

Tab counts in chronology show counts from LOADED events, not TOTAL events. This creates confusing UX where header shows "172 evenimente" but tab badges show much lower numbers that grow as user paginates.

## Symptom

- Header: "172 evenimente" (correct - from API totalCount)
- Documente tab: "20" (wrong - only counting loaded events)
- Comunicări tab: no badge (0 loaded, even if more exist)
- Sarcini tab: no badge (0 loaded, even if more exist)
- Clicking "Încarcă mai multe" causes tab counts to grow

## Root Cause

```typescript
// CaseChronology.tsx:222
const tabCounts = useMemo(() => countEventsByTab(events), [events]);
```

- `events` is the LOADED events array (10-20 items initially)
- `countEventsByTab()` counts from this small array
- Tab badges reflect loaded count, not database total
- As pagination loads more, counts recalculate and "grow"

## Acceptance Criteria

- [ ] Tab counts reflect TOTAL events in database, not loaded events
- [ ] Counts don't change when paginating (they're already the total)
- [ ] "Toate" tab count matches header "X evenimente"
- [ ] API provides counts per event type efficiently

## Implementation Options

### Option A: Add counts to existing query (Recommended)

Add `countsByType` field to `caseEvents` query response:

```graphql
type CaseEventConnection {
  edges: [CaseEventEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
  countsByType: CaseEventCounts! # NEW
}

type CaseEventCounts {
  documents: Int! # DocumentUploaded + DocumentSigned + DocumentDeleted
  communications: Int! # EmailReceived + EmailSent + EmailCourt + NoteCreated + NoteUpdated
  tasks: Int! # TaskCreated + TaskCompleted
}
```

Backend aggregates counts in single query using Prisma groupBy.

### Option B: Separate counts query

Add standalone `caseEventCounts(caseId: ID!)` query. More flexible but extra network request.

## Files to Modify

**Backend:**

- `services/gateway/src/services/case-event.service.ts` - Add count aggregation
- `services/gateway/src/graphql/schema/case-event.graphql` - Add types
- `services/gateway/src/graphql/resolvers/case-event.resolvers.ts` - Wire up

**Frontend:**

- `apps/web/src/hooks/useCaseEvents.ts` - Extract counts from response
- `apps/web/src/components/case/CaseChronology.tsx` - Use server counts

## Local Verification Status

| Step           | Status     | Date | Notes |
| -------------- | ---------- | ---- | ----- |
| Prod data test | ⬜ Pending |      |       |
| Preflight      | ⬜ Pending |      |       |
| Docker test    | ⬜ Pending |      |       |

**Verified**: No

## Session Log

- [2025-12-19] Issue created via /ops-investigate. Root cause identified in CaseChronology.tsx:222
- [2025-12-19] Session 1 started. Implementing Option A (countsByType in query response)
- [2025-12-19] Implementation complete:
  - Added `CaseEventCounts` type to GraphQL schema with all/documents/communications/tasks
  - Added category mappings in case-event.service.ts (DOCUMENT_EVENT_TYPES, etc.)
  - Added Prisma groupBy aggregation in getCaseEvents to calculate counts efficiently
  - Updated useCaseEvents hook to fetch and expose countsByCategory
  - Updated CaseChronology to use server counts instead of countEventsByTab(events)

---
