# OPS-100: Mapa Service Layer

**Type:** Feature
**Priority:** P1-High
**Status:** Fixed
**Created:** 2024-12-22

## Summary

Implement the backend service layer for Mapa CRUD operations, slot management, and template instantiation.

## Dependencies

- **Requires:** OPS-099 (Mapa Data Model)

## Service: `mapa.service.ts`

```typescript
// services/gateway/src/services/mapa.service.ts

/**
 * Mapa Service
 * Manages document binders (mape) with slots for expected documents
 */

// ============================================================================
// Types
// ============================================================================

interface CreateMapaInput {
  caseId: string;
  name: string;
  description?: string;
  templateId?: string; // Create from template
}

interface CreateMapaSlotInput {
  name: string;
  description?: string;
  category?: string;
  required?: boolean;
  order: number;
}

interface UpdateMapaInput {
  name?: string;
  description?: string;
}

interface AssignDocumentInput {
  slotId: string;
  caseDocumentId: string;
}

interface MapaCompletionStatus {
  totalSlots: number;
  filledSlots: number;
  requiredSlots: number;
  filledRequiredSlots: number;
  isComplete: boolean;
  missingRequired: string[]; // Names of missing required slots
}

// ============================================================================
// Service Methods
// ============================================================================

class MapaService {
  // --- Mapa CRUD ---

  async createMapa(input: CreateMapaInput, userContext: UserContext): Promise<Mapa>;
  async createMapaFromTemplate(
    templateId: string,
    caseId: string,
    userContext: UserContext
  ): Promise<Mapa>;
  async getMapa(id: string, userContext: UserContext): Promise<Mapa | null>;
  async getCaseMape(caseId: string, userContext: UserContext): Promise<Mapa[]>;
  async updateMapa(id: string, input: UpdateMapaInput, userContext: UserContext): Promise<Mapa>;
  async deleteMapa(id: string, userContext: UserContext): Promise<boolean>;

  // --- Slot Management ---

  async addSlot(
    mapaId: string,
    input: CreateMapaSlotInput,
    userContext: UserContext
  ): Promise<MapaSlot>;
  async addSlots(
    mapaId: string,
    inputs: CreateMapaSlotInput[],
    userContext: UserContext
  ): Promise<MapaSlot[]>;
  async updateSlot(
    slotId: string,
    input: Partial<CreateMapaSlotInput>,
    userContext: UserContext
  ): Promise<MapaSlot>;
  async deleteSlot(slotId: string, userContext: UserContext): Promise<boolean>;
  async reorderSlots(
    mapaId: string,
    slotIds: string[],
    userContext: UserContext
  ): Promise<MapaSlot[]>;

  // --- Document Assignment ---

  async assignDocument(
    slotId: string,
    caseDocumentId: string,
    userContext: UserContext
  ): Promise<MapaSlot>;
  async unassignDocument(slotId: string, userContext: UserContext): Promise<MapaSlot>;
  async bulkAssignDocuments(
    assignments: AssignDocumentInput[],
    userContext: UserContext
  ): Promise<MapaSlot[]>;

  // --- Status & Analytics ---

  async getCompletionStatus(
    mapaId: string,
    userContext: UserContext
  ): Promise<MapaCompletionStatus>;
  async getMapaWithSlots(id: string, userContext: UserContext): Promise<MapaWithSlots>;

  // --- Template Operations ---

  async createTemplate(input: CreateTemplateInput, userContext: UserContext): Promise<MapaTemplate>;
  async getFirmTemplates(userContext: UserContext): Promise<MapaTemplate[]>;
  async updateTemplate(
    id: string,
    input: UpdateTemplateInput,
    userContext: UserContext
  ): Promise<MapaTemplate>;
  async deleteTemplate(id: string, userContext: UserContext): Promise<boolean>;
}
```

## Key Implementation Details

### 1. Create Mapa from Template

```typescript
async createMapaFromTemplate(
  templateId: string,
  caseId: string,
  userContext: UserContext
): Promise<Mapa> {
  const template = await prisma.mapaTemplate.findUnique({
    where: { id: templateId }
  });

  if (!template || template.firmId !== userContext.firmId) {
    throw new Error('Template not found');
  }

  const slotDefs = template.slotDefinitions as SlotDefinition[];

  return prisma.mapa.create({
    data: {
      caseId,
      name: template.name,
      description: template.description,
      templateId,
      createdById: userContext.userId,
      slots: {
        create: slotDefs.map((slot, index) => ({
          name: slot.name,
          description: slot.description,
          category: slot.category,
          required: slot.required ?? true,
          order: slot.order ?? index,
        }))
      }
    },
    include: { slots: true }
  });
}
```

### 2. Completion Status Calculation

```typescript
async getCompletionStatus(
  mapaId: string,
  userContext: UserContext
): Promise<MapaCompletionStatus> {
  const slots = await prisma.mapaSlot.findMany({
    where: { mapaId },
    select: {
      name: true,
      required: true,
      caseDocumentId: true
    }
  });

  const totalSlots = slots.length;
  const filledSlots = slots.filter(s => s.caseDocumentId !== null).length;
  const requiredSlots = slots.filter(s => s.required).length;
  const filledRequiredSlots = slots.filter(s => s.required && s.caseDocumentId !== null).length;
  const missingRequired = slots
    .filter(s => s.required && s.caseDocumentId === null)
    .map(s => s.name);

  return {
    totalSlots,
    filledSlots,
    requiredSlots,
    filledRequiredSlots,
    isComplete: filledRequiredSlots === requiredSlots,
    missingRequired
  };
}
```

### 3. Slot Reordering

```typescript
async reorderSlots(
  mapaId: string,
  slotIds: string[],
  userContext: UserContext
): Promise<MapaSlot[]> {
  // Validate all slots belong to this mapa
  const existingSlots = await prisma.mapaSlot.findMany({
    where: { mapaId }
  });

  const existingIds = new Set(existingSlots.map(s => s.id));
  if (!slotIds.every(id => existingIds.has(id))) {
    throw new Error('Invalid slot IDs');
  }

  // Update order in transaction
  await prisma.$transaction(
    slotIds.map((id, index) =>
      prisma.mapaSlot.update({
        where: { id },
        data: { order: index }
      })
    )
  );

  return prisma.mapaSlot.findMany({
    where: { mapaId },
    orderBy: { order: 'asc' }
  });
}
```

## Acceptance Criteria

- [x] MapaService class with all CRUD operations
- [x] Slot management (add, update, delete, reorder)
- [x] Document assignment/unassignment
- [x] Template instantiation
- [x] Completion status calculation
- [x] Proper authorization checks (firmId validation)
- [ ] Unit tests for core operations (deferred)

## Files to Create/Modify

- `services/gateway/src/services/mapa.service.ts` (new)
- `services/gateway/src/services/index.ts` (export)

## Parallel Work

- Can be developed in parallel with OPS-101 (GraphQL Schema) once OPS-099 is complete

## Session Log

- [2024-12-22] Session 1: Implemented MapaService
  - Created `services/gateway/src/services/mapa.service.ts`
  - Implemented all Mapa CRUD operations (create, get, update, delete)
  - Implemented slot management (add, update, delete, reorder)
  - Implemented document assignment/unassignment with bulk operations
  - Implemented template operations (create, get, update, soft delete)
  - Implemented completion status calculation
  - Proper authorization checks with validateCaseAccess helper
  - All methods follow existing service patterns (UserContext, section dividers, singleton export)

## Local Verification Status

| Step           | Status     | Date | Notes                      |
| -------------- | ---------- | ---- | -------------------------- |
| Prod data test | ⬜ Pending |      | Service layer only         |
| Preflight      | ⬜ Pending |      | Need to run pnpm preflight |
| Docker test    | ⬜ Pending |      | Service layer only         |

**Verified**: No (pending preflight check)
