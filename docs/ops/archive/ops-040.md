# OPS-040: Court Email Detection & INSTANȚE Routing

**Status:** Verifying | **Priority:** P1-High | **Type:** Feature | **Created:** 2025-12-18 | **Sessions:** 1 | **Last Active:** 2025-12-18

## Overview

Handle emails from courts and authorities separately. They match by case reference number (not contact) and have their own "folder" for unassigned items.

## Dependencies

- **Depends on:** OPS-035 (data model), OPS-038 (reference numbers on cases)
- **Blocks:** OPS-041
- **Parallel with:** OPS-038, OPS-039

## Context

Part of the Communications Architecture Rethink. Court emails are different:

- They come from institutional addresses (configured in GlobalEmailSource)
- They should NOT use contact matching
- They should match by case reference number in subject/body
- Unmatched court emails go to a special INSTANȚE folder (not NECLAR)

**Existing work:** GlobalEmailSource model exists with categories (Court, Notary, Bailiff, Authority, Other).

## Requirements

### 1. Court Email Detection

```typescript
async function isFromInstitution(email: Email): Promise<boolean> {
  const senderDomain = extractDomain(email.from);
  const senderEmail = extractEmail(email.from);

  const sources = await prisma.globalEmailSource.findMany({
    where: {
      firmId: email.firmId,
      OR: [{ domains: { has: senderDomain } }, { emails: { has: senderEmail } }],
    },
  });

  return sources.length > 0;
}
```

### 2. Court Email Classification Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                         COURT FLOW                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │ Extract case #  │
                    │ from subject    │
                    │ and body        │
                    └────────┬────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │ Match against   │
                    │ case reference  │
                    │ numbers         │
                    └────────┬────────┘
                              │
              ┌───────────────┴───────────────┐
              │                               │
         Found match                    No match
              │                               │
              ▼                               ▼
        Assign to case              Mark as COURT_UNASSIGNED
        (CLASSIFIED)                → INSTANȚE folder
```

### 3. Reference Number Matching

```typescript
async function classifyCourtEmail(email: Email): Promise<ClassificationResult> {
  // Extract all reference numbers from email
  const references = extractReferenceNumbers(`${email.subject} ${email.bodyContent}`);

  if (references.length === 0) {
    return {
      state: 'COURT_UNASSIGNED',
      reason: 'NO_REFERENCE_NUMBER',
    };
  }

  // Find cases with matching reference numbers
  const matchingCases = await prisma.case.findMany({
    where: {
      firmId: email.firmId,
      referenceNumbers: { hasSome: references },
    },
  });

  if (matchingCases.length === 0) {
    return {
      state: 'COURT_UNASSIGNED',
      reason: 'NO_MATCHING_CASE',
      extractedReferences: references,
    };
  }

  if (matchingCases.length === 1) {
    return {
      caseId: matchingCases[0].id,
      state: 'CLASSIFIED',
      confidence: 1.0,
      matchType: 'REFERENCE_NUMBER',
    };
  }

  // Multiple matches - should be rare, but handle it
  return {
    state: 'COURT_UNASSIGNED',
    reason: 'MULTIPLE_MATCHES',
    suggestedCases: matchingCases.map((c) => ({ id: c.id, reference: c.referenceNumbers })),
  };
}
```

### 4. INSTANȚE Folder Query

```graphql
# Get court emails not assigned to any case
query getUnassignedCourtEmails($userId: ID!) {
  unassignedCourtEmails(userId: $userId) {
    id
    subject
    from
    receivedDateTime
    extractedReferences # References found but no case match
    suggestedCases {
      # If multiple matches found
      id
      title
      referenceNumbers
    }
  }
}
```

### 5. Manual Assignment from INSTANȚE

When user assigns a court email to a case:

1. Set `caseId` on the email
2. Set `classificationState = CLASSIFIED`
3. Optionally: Offer to add the reference number to the case if it was extracted

```graphql
mutation assignCourtEmailToCase($emailId: ID!, $caseId: ID!, $addReference: Boolean) {
  assignCourtEmailToCase(emailId: $emailId, caseId: $caseId, addReference: $addReference) {
    email {
      id
      caseId
      classificationState
    }
    case {
      id
      referenceNumbers
    }
  }
}
```

## Acceptance Criteria

- [x] Court/authority emails detected via GlobalEmailSource
- [x] Reference numbers extracted from subject and body
- [x] Exact match on reference number assigns to case
- [x] No match → COURT_UNASSIGNED state
- [x] Multiple matches → COURT_UNASSIGNED with suggestions
- [x] Query for unassigned court emails (INSTANȚE folder)
- [x] Manual assignment mutation works
- [x] Option to add reference number to case during assignment
- [x] Classification logged for audit
- [x] No TypeScript errors

## Files Modified

- `services/gateway/src/services/classification-scoring.ts` - court email detection and classification flow
- `services/gateway/src/graphql/schema/email.graphql` - INSTANȚE types, queries, and mutations
- `services/gateway/src/graphql/resolvers/email.resolvers.ts` - INSTANȚE query and mutation resolvers
- `services/gateway/src/workers/email-categorization.worker.ts` - handle CourtUnassigned state

## Estimated Scope

Medium - Court-specific classification logic.

---

## Local Verification Status

| Step           | Status     | Date | Notes |
| -------------- | ---------- | ---- | ----- |
| Prod data test | ⬜ Pending |      |       |
| Preflight      | ⬜ Pending |      |       |
| Docker test    | ⬜ Pending |      |       |

**Verified**: No

## Session Log

### Session 1 - 2025-12-18

**Started**: Continuing from Open status. Dependencies (OPS-035, OPS-038) are implementation-complete.

**Plan:**

1. Add court email detection using GlobalEmailSource
2. Create court classification flow in ClassificationScoringService
3. Add GraphQL query for unassigned court emails (INSTANȚE)
4. Add mutation for manual court email assignment
5. Update email categorization worker to use court flow

**Work Completed:**

1. **Court Email Detection** (`classification-scoring.ts`):
   - Added `checkInstitutionSource()` method to detect court/institution emails
   - Checks both sender domain and email address against `GlobalEmailSource` table
   - Returns institution category (Court, Notary, Bailiff, Authority, Other)

2. **Court Classification Flow** (`classification-scoring.ts`):
   - Added `classifyCourtEmail()` method for court-specific classification
   - Extracts reference numbers from subject and body using Romanian patterns
   - Single match → assigns to case with `Classified` state
   - No match → `CourtUnassigned` state (INSTANȚE folder)
   - Multiple matches → `CourtUnassigned` with suggested cases
   - Extended `ClassificationResult` type with court-specific fields

3. **GraphQL Schema** (`email.graphql`):
   - Added `UnassignedCourtEmail` type for INSTANȚE folder items
   - Added `SuggestedCase` type for case suggestions
   - Added `AssignCourtEmailResult` type for assignment response
   - Added `unassignedCourtEmails` query with pagination
   - Added `unassignedCourtEmailsCount` query
   - Added `assignCourtEmailToCase` mutation with optional `addReference`

4. **Resolvers** (`email.resolvers.ts`):
   - Implemented `unassignedCourtEmails` query - fetches court emails, extracts references, finds suggested cases
   - Implemented `unassignedCourtEmailsCount` query
   - Implemented `assignCourtEmailToCase` mutation - assigns email to case, optionally adds extracted reference numbers to case

5. **Worker Update** (`email-categorization.worker.ts`):
   - Added handling for `CourtUnassigned` state in classification results
   - Court emails now routed to INSTANȚE folder correctly

**Tests:**

- ✅ TypeScript type check passed (gateway + web)
- ⬜ Local verification pending

**Status:** Implementation complete, ready for verification
