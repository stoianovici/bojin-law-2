# OPS-068: AI Assistant Resolvers

**Status:** Open | **Priority:** P1-High | **Type:** Feature
**Created:** 2025-12-20 | **Depends on:** OPS-064, OPS-066, OPS-067 | **Blocks:** OPS-069, OPS-070, OPS-071

## Summary

Create GraphQL resolvers that wire the AI assistant schema to the orchestrator and conversation services.

## Background

The resolvers connect the GraphQL API to the backend services:

- Query resolvers for conversation retrieval
- Mutation resolvers for sending messages and confirming actions
- Field resolvers for computed fields

## Requirements

### Resolver Implementation

```typescript
// services/gateway/src/graphql/resolvers/ai-assistant.resolvers.ts

import { GraphQLError } from 'graphql';
import { prisma } from '@legal-platform/database';
import { conversationService } from '../../services/conversation.service';
import { aiOrchestratorService } from '../../services/ai-orchestrator.service';
import { actionExecutorService } from '../../services/action-executor.service';
import type { AIConversation, AIMessage } from '@prisma/client';

// ============================================================================
// Types
// ============================================================================

interface SendMessageInput {
  conversationId?: string;
  content: string;
  caseId?: string;
  context?: {
    currentScreen?: string;
    currentCaseId?: string;
    currentDocumentId?: string;
    selectedEmailId?: string;
  };
}

interface ConfirmActionInput {
  messageId: string;
  confirmed: boolean;
  modifications?: Record<string, unknown>;
}

interface Context {
  user?: {
    id: string;
    firmId: string;
    role: string;
    email: string;
  };
}

// ============================================================================
// Resolvers
// ============================================================================

export const aiAssistantResolvers = {
  Query: {
    /**
     * Get active conversation for current context.
     */
    activeConversation: async (_: unknown, args: { caseId?: string }, context: Context) => {
      if (!context.user) {
        throw new GraphQLError('Authentication required', {
          extensions: { code: 'UNAUTHENTICATED' },
        });
      }

      return conversationService.getOrCreateConversation(
        { userId: context.user.id, firmId: context.user.firmId },
        args.caseId
      );
    },

    /**
     * Get conversation by ID.
     */
    conversation: async (_: unknown, args: { id: string }, context: Context) => {
      if (!context.user) {
        throw new GraphQLError('Authentication required', {
          extensions: { code: 'UNAUTHENTICATED' },
        });
      }

      return conversationService.getConversation(args.id, context.user.firmId);
    },

    /**
     * Get conversation history.
     */
    conversationHistory: async (
      _: unknown,
      args: { limit?: number; caseId?: string },
      context: Context
    ) => {
      if (!context.user) {
        throw new GraphQLError('Authentication required', {
          extensions: { code: 'UNAUTHENTICATED' },
        });
      }

      return conversationService.getHistory(
        { userId: context.user.id, firmId: context.user.firmId },
        args.limit ?? 10,
        args.caseId
      );
    },
  },

  Mutation: {
    /**
     * Send a message to the AI assistant.
     */
    sendAssistantMessage: async (
      _: unknown,
      args: { input: SendMessageInput },
      context: Context
    ) => {
      if (!context.user) {
        throw new GraphQLError('Authentication required', {
          extensions: { code: 'UNAUTHENTICATED' },
        });
      }

      const { input } = args;
      const userContext = {
        userId: context.user.id,
        firmId: context.user.firmId,
        role: context.user.role,
        email: context.user.email,
      };

      // Get or create conversation
      let conversation = input.conversationId
        ? await conversationService.getConversation(input.conversationId, context.user.firmId)
        : await conversationService.getOrCreateConversation(userContext, input.caseId);

      if (!conversation) {
        throw new GraphQLError('Conversation not found', {
          extensions: { code: 'NOT_FOUND' },
        });
      }

      // Save user message
      await conversationService.addMessage(
        conversation.id,
        {
          role: 'User',
          content: input.content,
        },
        context.user.firmId
      );

      // Process with orchestrator
      const result = await aiOrchestratorService.processMessage(
        input.content,
        input.context ?? {},
        conversation.messages,
        userContext
      );

      // Save assistant message
      const assistantMessage = await conversationService.addMessage(
        conversation.id,
        {
          role: 'Assistant',
          content: result.response,
          intent: result.intent,
          confidence: result.confidence,
          actionType: result.proposedAction?.type,
          actionPayload: result.proposedAction?.payload,
          actionStatus: result.proposedAction ? 'Proposed' : undefined,
        },
        context.user.firmId
      );

      // Update conversation status if action proposed
      if (result.proposedAction?.requiresConfirmation) {
        await conversationService.updateStatus(
          conversation.id,
          'AwaitingConfirmation',
          context.user.firmId
        );
      }

      // Refresh conversation
      conversation = await conversationService.getConversation(
        conversation.id,
        context.user.firmId
      );

      return {
        message: assistantMessage,
        conversation,
        suggestedFollowUps: result.suggestedFollowUps,
      };
    },

    /**
     * Confirm or reject a proposed action.
     */
    confirmAction: async (_: unknown, args: { input: ConfirmActionInput }, context: Context) => {
      if (!context.user) {
        throw new GraphQLError('Authentication required', {
          extensions: { code: 'UNAUTHENTICATED' },
        });
      }

      const { input } = args;
      const userContext = {
        userId: context.user.id,
        firmId: context.user.firmId,
        role: context.user.role,
      };

      // Get message with action
      const message = await prisma.aiMessage.findUnique({
        where: { id: input.messageId },
        include: { conversation: true },
      });

      if (!message || message.conversation.firmId !== context.user.firmId) {
        throw new GraphQLError('Message not found', {
          extensions: { code: 'NOT_FOUND' },
        });
      }

      if (!input.confirmed) {
        // User rejected action
        await conversationService.updateMessageActionStatus(
          input.messageId,
          'Rejected',
          context.user.firmId
        );
        await conversationService.updateStatus(
          message.conversationId,
          'Active',
          context.user.firmId
        );

        return {
          success: true,
          message: 'Acțiune anulată.',
        };
      }

      // Execute the action
      const action = {
        type: message.actionType!,
        data: {
          ...(message.actionPayload as Record<string, unknown>),
          ...input.modifications,
        },
      };

      const result = await actionExecutorService.executeAction(action, userContext);

      // Update message status
      await conversationService.updateMessageActionStatus(
        input.messageId,
        result.success ? 'Executed' : 'Failed',
        context.user.firmId
      );

      // Update conversation status
      await conversationService.updateStatus(message.conversationId, 'Active', context.user.firmId);

      return result;
    },

    /**
     * Close a conversation.
     */
    closeConversation: async (_: unknown, args: { id: string }, context: Context) => {
      if (!context.user) {
        throw new GraphQLError('Authentication required', {
          extensions: { code: 'UNAUTHENTICATED' },
        });
      }

      return conversationService.closeConversation(args.id, context.user.firmId);
    },
  },

  // Field resolvers
  AIConversation: {
    messageCount: async (conversation: AIConversation) => {
      // Note: Use count query instead of relation length for reliability
      return prisma.aiMessage.count({ where: { conversationId: conversation.id } });
    },
    case: async (conversation: AIConversation) => {
      if (!conversation.caseId) return null;
      return prisma.case.findUnique({ where: { id: conversation.caseId } });
    },
  },

  AIMessage: {
    proposedAction: (message: AIMessage) => {
      if (!message.actionType) return null;
      return {
        type: message.actionType,
        displayText: getActionDisplayText(message.actionType),
        payload: message.actionPayload,
        status: message.actionStatus,
        requiresConfirmation: true,
        confirmationPrompt: getConfirmationPrompt(message.actionType),
      };
    },
  },
};

// ============================================================================
// Helper Functions
// ============================================================================

function getActionDisplayText(actionType: string): string {
  const displayTexts: Record<string, string> = {
    CreateTask: 'Creează sarcină',
    UpdateTask: 'Actualizează sarcină',
    ScheduleEvent: 'Programează eveniment',
    DraftEmail: 'Redactează email',
    GenerateDocument: 'Generează document',
  };
  return displayTexts[actionType] || actionType;
}

function getConfirmationPrompt(actionType: string): string {
  const prompts: Record<string, string> = {
    CreateTask: 'Creez această sarcină?',
    UpdateTask: 'Actualizez această sarcină?',
    ScheduleEvent: 'Adaug în calendar?',
    DraftEmail: 'Folosiți acest răspuns?',
    GenerateDocument: 'Generez acest document?',
  };
  return prompts[actionType] || 'Confirmați această acțiune?';
}
```

## Acceptance Criteria

- [ ] All Query resolvers implemented
- [ ] All Mutation resolvers implemented
- [ ] Field resolvers for computed fields
- [ ] Authentication checks on all operations
- [ ] Firm isolation enforced
- [ ] Error handling with GraphQL errors
- [ ] Resolvers registered in server.ts
- [ ] Integration tests

## Files to Create

- `services/gateway/src/graphql/resolvers/ai-assistant.resolvers.ts`

## Files to Modify

- `services/gateway/src/graphql/server.ts` (import and register resolvers)

## Session Log

- [2025-12-20 Session 1] Implementation started
  - Created `ai-assistant.resolvers.ts` with full resolver implementation
  - Query resolvers: `activeConversation`, `conversation`, `conversationHistory`
  - Mutation resolvers: `sendAssistantMessage`, `confirmAction`, `closeConversation`
  - Field resolvers: `AIConversation.{messageCount, case, messages}`, `AIMessage.proposedAction`
  - Registered resolvers in `server.ts`
  - **NOTE:** OPS-066 (AI Orchestrator) and OPS-067 (Action Executor) were auto-implemented by linter
  - All services now use real implementations (no stubs)
  - TypeScript compilation verified ✓

#### Local Verification Status

| Step           | Status     | Notes                                 |
| -------------- | ---------- | ------------------------------------- |
| Prod data test | ⬜ Pending | Requires frontend integration to test |
| Preflight      | ⬜ Pending | Need to run full preflight            |
| Docker test    | ⬜ Pending |                                       |

**Verified**: No (awaiting integration with frontend)

## Acceptance Criteria Status

- [x] All Query resolvers implemented
- [x] All Mutation resolvers implemented
- [x] Field resolvers for computed fields
- [x] Authentication checks on all operations
- [x] Firm isolation enforced
- [x] Error handling with GraphQL errors
- [x] Resolvers registered in server.ts
- [ ] Integration tests (pending OPS-079)
