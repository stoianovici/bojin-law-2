# OPS-039: Enhanced Multi-Case Classification Algorithm

**Status:** Open | **Priority:** P1-High | **Type:** Feature | **Created:** 2025-12-18

## Overview

Build a bulletproof algorithm for classifying emails when a contact has multiple active cases.

## Dependencies

- **Depends on:** OPS-035 (data model), builds on OPS-027-029 (existing classification)
- **Blocks:** OPS-041, OPS-042
- **Parallel with:** OPS-038, OPS-040

## Context

Part of the Communications Architecture Rethink. When a client (e.g., Maria Popescu) has multiple active cases, incoming emails must be routed to the correct case with high confidence.

**Existing work:** OPS-027-029 implemented basic classification. This issue enhances the algorithm for the multi-case scenario.

## Requirements

### 1. Classification Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                    EMAIL CLASSIFICATION FLOW                     │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │ Email received  │
                    └────────┬────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │ Is from court/  │───Yes──▶ COURT FLOW (OPS-040)
                    │ authority?      │
                    └────────┬────────┘
                             No
                              │
                              ▼
                    ┌─────────────────┐
                    │ Thread exists?  │───Yes──▶ Same case as thread
                    │ (conversationId)│         (100% confidence)
                    └────────┬────────┘
                             No
                              │
                              ▼
                    ┌─────────────────┐
                    │ Match sender to │
                    │ case contacts   │
                    └────────┬────────┘
                              │
              ┌───────────────┼───────────────┐
              │               │               │
         0 matches      1 match         2+ matches
              │               │               │
              ▼               ▼               ▼
        → UNCERTAIN     Assign to      MULTI-CASE SCORING
        (unknown        that case      (see below)
         contact)       (high conf)
```

### 2. Multi-Case Scoring Algorithm

When a contact has multiple cases, score each case:

```typescript
interface ClassificationScore {
  caseId: string;
  score: number;
  signals: Signal[];
}

interface Signal {
  type:
    | 'THREAD_CONTINUITY'
    | 'REFERENCE_NUMBER'
    | 'KEYWORD_SUBJECT'
    | 'KEYWORD_BODY'
    | 'RECENT_ACTIVITY'
    | 'SEMANTIC';
  weight: number;
  matched: string; // what matched
}

// Scoring weights
const WEIGHTS = {
  THREAD_CONTINUITY: 100, // Same conversationId - deterministic
  REFERENCE_NUMBER: 50, // Case reference in subject/body
  KEYWORD_SUBJECT: 30, // Case keyword in subject
  KEYWORD_BODY: 20, // Case keyword in body (more noise)
  RECENT_ACTIVITY: 20, // Email within 7 days of last case activity
  SEMANTIC: 15, // AI semantic similarity (fallback)
};

// Decision thresholds
const THRESHOLDS = {
  MIN_SCORE: 70, // Minimum to auto-assign
  MIN_GAP: 20, // Minimum lead over second place
};
```

### 3. Classification Decision

```typescript
function classifyEmail(email: Email, candidateCases: Case[]): ClassificationResult {
  // 1. Check thread continuity first (deterministic)
  const existingThread = findExistingThread(email.conversationId);
  if (existingThread) {
    return {
      caseId: existingThread.caseId,
      state: 'CLASSIFIED',
      confidence: 1.0,
      matchType: 'THREAD_CONTINUITY',
    };
  }

  // 2. Score each candidate case
  const scores = candidateCases.map((c) => scoreCase(email, c));
  scores.sort((a, b) => b.score - a.score);

  const top = scores[0];
  const second = scores[1];
  const gap = second ? top.score - second.score : top.score;

  // 3. Decision
  if (top.score >= THRESHOLDS.MIN_SCORE && gap >= THRESHOLDS.MIN_GAP) {
    return {
      caseId: top.caseId,
      state: 'CLASSIFIED',
      confidence: top.score / 100,
      matchType: top.signals[0].type,
    };
  }

  // 4. Uncertain - needs user review
  return {
    caseId: null,
    state: 'UNCERTAIN',
    confidence: top.score / 100,
    suggestedCases: scores.slice(0, 3),
    reason: gap < THRESHOLDS.MIN_GAP ? 'AMBIGUOUS' : 'LOW_CONFIDENCE',
  };
}
```

### 4. Reference Number Extraction

```typescript
// Common Romanian court reference patterns
const REFERENCE_PATTERNS = [
  /(\d+)\/(\d+)\/(\d{4})/, // 123/45/2025
  /dosar(?:\s+nr\.?)?\s*(\d+\/\d+\/\d{4})/i,
  /nr\.\s*(\d+\/\d+\/\d{4})/i,
];

function extractReferenceNumbers(text: string): string[] {
  const matches: string[] = [];
  for (const pattern of REFERENCE_PATTERNS) {
    const match = text.match(pattern);
    if (match) matches.push(match[1] || match[0]);
  }
  return [...new Set(matches)];
}
```

### 5. Service Implementation

Enhance existing `email-classification.service.ts`:

```typescript
class EmailClassificationService {
  async classifyNewEmail(email: Email): Promise<ClassificationResult> {
    // 1. Check if from court/authority
    if (await this.isFromInstitution(email)) {
      return this.classifyCourtEmail(email); // Delegates to OPS-040
    }

    // 2. Find contact's cases
    const contactCases = await this.findCasesForContact(email.from);

    if (contactCases.length === 0) {
      return { state: 'UNCERTAIN', reason: 'UNKNOWN_CONTACT' };
    }

    if (contactCases.length === 1) {
      return {
        caseId: contactCases[0].id,
        state: 'CLASSIFIED',
        confidence: 0.9,
      };
    }

    // 3. Multi-case scoring
    return this.scoreAndClassify(email, contactCases);
  }
}
```

## Acceptance Criteria

- [ ] Thread continuity always wins (same conversation = same case)
- [ ] Single-case contacts auto-assign with high confidence
- [ ] Multi-case contacts scored with weighted signals
- [ ] Reference number extraction works for Romanian formats
- [ ] Keyword matching (subject weighted higher than body)
- [ ] Recent activity considered
- [ ] Uncertain emails marked with `UNCERTAIN` state
- [ ] Suggested cases provided for uncertain emails
- [ ] Classification logged for audit trail
- [ ] Unit tests for scoring algorithm
- [ ] No TypeScript errors

## Files to Modify

- `services/gateway/src/services/email-classification.service.ts` - enhance
- `services/gateway/src/workers/email-categorization.worker.ts` - use new algorithm
- New: `services/gateway/src/services/classification-scoring.ts`
- Tests: `services/gateway/src/services/classification-scoring.test.ts`

## Estimated Scope

Medium-Large - Algorithm implementation + testing.

---

## Session Log

_(Add session notes here as work progresses)_
