# OPS-240: Thread Summaries Processor

**Type**: Feature
**Priority**: P2-Medium
**Status**: Completed
**Epic**: AI Batch Processing & Ops Dashboard

## Problem

Email thread summaries generate on-demand. Opening a long thread shows a loading spinner while AI processes.

## Solution

Create `ThreadSummariesProcessor` that pre-generates summaries for threads with new messages.

### How It Works

1. Query threads (grouped by `conversationId`) where:
   - `lastAnalyzedAt` is older than latest email in thread
   - OR no `ThreadSummary` record exists
   - Thread has 2+ emails (worth summarizing)
2. Generate summary with Claude
3. Update existing `ThreadSummary` record or create new one

### Existing ThreadSummary Model

The `ThreadSummary` model already exists in the schema, keyed by `conversationId`:

```prisma
model ThreadSummary {
  id                      String   @id @default(uuid())
  conversationId          String   @unique @map("conversation_id") // Graph conversation ID
  caseId                  String?  @map("case_id")
  firmId                  String   @map("firm_id")
  opposingCounselPosition String?  @map("opposing_counsel_position") @db.Text
  keyArguments            Json?    @map("key_arguments")     // Array of argument summaries
  positionChanges         Json?    @map("position_changes")  // Array of position change events
  lastAnalyzedAt          DateTime @map("last_analyzed_at") @db.Timestamptz
  messageCount            Int      @map("message_count")
  createdAt               DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt               DateTime @updatedAt @map("updated_at") @db.Timestamptz

  @@index([caseId])
}
```

### Schema Update (extend existing model)

Add new fields to the existing `ThreadSummary` model:

```prisma
model ThreadSummary {
  // ... existing fields ...
  // Note: Existing fields serve legal analysis:
  //   - keyArguments: Legal arguments made by opposing counsel
  //   - positionChanges: How opposing counsel's position evolved
  //   - opposingCounselPosition: Current stance summary

  // New fields for general thread summary (batch processor)
  overview        String?   @db.Text           // 1-2 sentence overview of the thread
  keyPoints       Json?     @map("key_points") // General discussion bullet points (not legal-specific)
  actionItems     Json?     @map("action_items") // Extracted action items/to-dos
  sentiment       String?   @db.VarChar(20)    // 'positive' | 'neutral' | 'negative' | 'urgent'
  participants    Json?                         // Array of participant names/emails
}
```

### Summary Data Structures

```typescript
interface ThreadSummaryData {
  overview: string; // 1-2 sentence overview in Romanian
  keyPoints: string[]; // 3-5 bullet points
  participants: string[]; // List of participants
  actionItems: string[]; // Extracted action items
  sentiment: 'positive' | 'neutral' | 'negative' | 'urgent';
}
```

### Incremental Processing

```typescript
async process(firmId: string, batchJobId: string): Promise<BatchProcessorResult> {
  // Find conversations needing summary update using raw query
  // (comparing dates across tables requires raw SQL)
  const staleThreads = await prisma.$queryRaw<Array<{ conversationId: string }>>`
    SELECT DISTINCT e.conversation_id as "conversationId"
    FROM emails e
    LEFT JOIN thread_summaries ts ON ts.conversation_id = e.conversation_id
    WHERE e.firm_id = ${firmId}
    AND (
      ts.id IS NULL  -- Never summarized
      OR ts.last_analyzed_at < (
        SELECT MAX(received_date_time)
        FROM emails e2
        WHERE e2.conversation_id = e.conversation_id
      )
    )
    GROUP BY e.conversation_id
    HAVING COUNT(e.id) >= 2  -- At least 2 emails
    LIMIT 100
  `;

  for (const { conversationId } of staleThreads) {
    // Fetch all emails in thread
    const emails = await prisma.email.findMany({
      where: { conversationId, firmId },
      orderBy: { receivedDateTime: 'asc' },
    });

    const summaryData = await this.generateSummary(emails, batchJobId);

    // Upsert ThreadSummary
    await prisma.threadSummary.upsert({
      where: { conversationId },
      create: {
        conversationId,
        firmId,
        caseId: emails[0]?.caseId,
        messageCount: emails.length,
        lastAnalyzedAt: new Date(),
        ...summaryData,
      },
      update: {
        messageCount: emails.length,
        lastAnalyzedAt: new Date(),
        ...summaryData,
      },
    });
  }
}
```

## Acceptance Criteria

- [x] `ThreadSummariesProcessor` implements `BatchProcessor`
- [x] Incremental processing (only changed threads based on `lastAnalyzedAt`)
- [x] Summary includes overview, key points, action items, sentiment
- [x] Summary stored in existing `ThreadSummary` model (with new fields)
- [ ] Frontend uses pre-computed summary (no loading) - future work
- [x] Batch size limit (100 threads per run)
- [x] Summaries in Romanian

## Files to Modify

- `services/gateway/src/batch/processors/thread-summaries.processor.ts` (new)
- `packages/database/prisma/schema.prisma` (add new fields to ThreadSummary)
- `services/gateway/src/services/email-thread.service.ts` (update to use pre-computed)

## Dependencies

- OPS-236 (Batch Job Runner Framework)

## Parallel Work

Can be done in parallel with OPS-237, OPS-238, OPS-239.
