# OPS-241: AI Ops GraphQL Schema & Resolvers

**Type**: Feature
**Priority**: P1-High
**Status**: Completed
**Epic**: AI Batch Processing & Ops Dashboard

## Problem

No API for the admin dashboard to query usage data, toggle features, or view job history.

## Solution

Create GraphQL schema and resolvers for AI operations management.

### Schema

```graphql
# Types
type AIUsageOverview {
  totalCost: Float!
  totalTokens: Int!
  totalCalls: Int!
  successRate: Float!
  projectedMonthEnd: Float!
  budgetLimit: Float
  budgetUsedPercent: Float
}

type DailyCost {
  date: String!
  cost: Float!
  tokens: Int!
  calls: Int!
}

type FeatureCost {
  feature: String!
  featureName: String!
  cost: Float!
  tokens: Int!
  calls: Int!
  percentOfTotal: Float!
}

type UserCost {
  userId: ID!
  userName: String!
  cost: Float!
  tokens: Int!
  calls: Int!
}

type AIFeatureConfig {
  id: ID!
  feature: String!
  featureName: String!
  featureType: String! # 'request' or 'batch'
  enabled: Boolean!
  monthlyBudgetEur: Float
  dailyLimitEur: Float
  schedule: String
  lastRunAt: DateTime
  lastRunStatus: String
  dailyCostEstimate: Float # Computed from last 7 days average, not stored
}

type AIBatchJobRun {
  id: ID!
  feature: String!
  featureName: String!
  status: String!
  startedAt: DateTime!
  completedAt: DateTime
  itemsProcessed: Int!
  itemsFailed: Int!
  totalTokens: Int!
  totalCostEur: Float!
  errorMessage: String
}

# Queries
extend type Query {
  # Overview
  aiUsageOverview(dateRange: DateRangeInput): AIUsageOverview!

  # Cost breakdowns
  aiDailyCosts(dateRange: DateRangeInput!): [DailyCost!]!
  aiCostsByFeature(dateRange: DateRangeInput!): [FeatureCost!]!
  aiCostsByUser(dateRange: DateRangeInput!): [UserCost!]!

  # Feature management
  aiFeatures: [AIFeatureConfig!]!
  aiFeature(feature: String!): AIFeatureConfig

  # Job history
  aiBatchJobs(feature: String, status: String, limit: Int = 50, offset: Int = 0): [AIBatchJobRun!]!
}

# Mutations
extend type Mutation {
  # Feature toggles
  updateAIFeatureConfig(
    feature: String!
    enabled: Boolean
    monthlyBudgetEur: Float
    dailyLimitEur: Float
    schedule: String
  ): AIFeatureConfig!

  # Manual trigger
  triggerBatchJob(feature: String!): AIBatchJobRun!

  # Budget alerts
  updateAIBudgetSettings(
    monthlyBudget: Float
    alertAt75: Boolean
    alertAt90: Boolean
    autoPauseAt100: Boolean
  ): Boolean!
}

input DateRangeInput {
  start: DateTime!
  end: DateTime!
}
```

### Authorization

All queries and mutations require Partner role. Authorization is enforced at the resolver level using the `requireRole` middleware pattern:

```typescript
import { requireRole } from '../middleware/auth.middleware';

// Helper to wrap resolver with role check
function partnerOnly<T>(
  resolver: (parent: unknown, args: T, context: GraphQLContext) => Promise<unknown>
) {
  return async (parent: unknown, args: T, context: GraphQLContext) => {
    // Check role from context (set by authenticateJWT middleware)
    if (!context.user || context.user.role !== 'Partner') {
      throw new GraphQLError('Access denied. Partner role required.', {
        extensions: { code: 'FORBIDDEN' },
      });
    }
    return resolver(parent, args, context);
  };
}

const resolvers = {
  Query: {
    aiUsageOverview: partnerOnly(async (_, args, context) => {
      return aiUsageService.getUsageOverview(context.firmId, args.dateRange);
    }),
    aiDailyCosts: partnerOnly(async (_, args, context) => {
      return aiUsageService.getDailyCosts(context.firmId, args.dateRange);
    }),
    aiCostsByFeature: partnerOnly(async (_, args, context) => {
      return aiUsageService.getCostsByFeature(context.firmId, args.dateRange);
    }),
    aiCostsByUser: partnerOnly(async (_, args, context) => {
      return aiUsageService.getCostsByUser(context.firmId, args.dateRange);
    }),
    aiFeatures: partnerOnly(async (_, __, context) => {
      return aiFeatureConfigService.getAllFeatures(context.firmId);
    }),
    aiFeature: partnerOnly(async (_, args, context) => {
      return aiFeatureConfigService.getFeatureConfig(context.firmId, args.feature);
    }),
    aiBatchJobs: partnerOnly(async (_, args, context) => {
      return batchJobService.getJobHistory(context.firmId, args);
    }),
  },
  Mutation: {
    updateAIFeatureConfig: partnerOnly(async (_, args, context) => {
      return aiFeatureConfigService.updateFeatureConfig(context.firmId, args.feature, args);
    }),
    triggerBatchJob: partnerOnly(async (_, args, context) => {
      return batchRunner.runProcessor(context.firmId, args.feature);
    }),
    updateAIBudgetSettings: partnerOnly(async (_, args, context) => {
      return aiBudgetService.updateSettings(context.firmId, args);
    }),
  },
};
```

## Acceptance Criteria

- [x] GraphQL schema defined with all types
- [x] Resolvers call usage and config services
- [x] Partner-only authorization enforced on all operations
- [x] Manual job trigger works via mutation
- [x] Date range filtering works correctly
- [x] Pagination for job history

## Implementation Notes

Completed 2024-12-25.

**Files Created:**

- `services/gateway/src/graphql/schema/ai-ops.graphql` - Full GraphQL schema with all types and operations
- `services/gateway/src/graphql/resolvers/ai-ops.resolvers.ts` - Resolvers with Partner-only authorization

**Files Modified:**

- `services/gateway/src/graphql/server.ts` - Added resolver imports and registration

**Key Features:**

- All queries and mutations require Partner role (enforced via `requirePartner` helper)
- Integration with existing services: `aiUsageService`, `aiFeatureConfigService`, `batchRunner`
- Computes `dailyCostEstimate` from last 7 days average
- Computes `lastRunAt` and `lastRunStatus` from `AIBatchJobRun` table
- Romanian error messages for consistency with rest of app

## Files to Modify

- `services/gateway/src/graphql/schema/ai-ops.graphql` (new)
- `services/gateway/src/graphql/resolvers/ai-ops.resolvers.ts` (new)
- `services/gateway/src/graphql/resolvers/index.ts` (register resolvers)

## Dependencies

- OPS-235 (AI Usage Aggregation Service)
- OPS-236 (Batch Job Runner for triggerBatchJob)

## Parallel Work

This is sequential - blocked by OPS-235 (Usage Aggregation) and OPS-236 (Batch Runner).
