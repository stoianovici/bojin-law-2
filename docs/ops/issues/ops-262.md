# OPS-262: AI Assistant Pre-compiled Context Integration

**Type**: Feature | **Priority**: P2-Medium | **Complexity**: S
**Status**: Verifying
**Blocked by**: ~~OPS-261~~ (completed)

## Problem

AI assistant still calls `caseBriefingService.getBriefingText()` which may trigger on-demand generation on cache miss. Need to use the comprehensive pre-compiled rich context from the nightly batch processor.

## Solution

Modify `buildContextualSystemPrompt()` to load and inject pre-compiled rich context, falling back to on-demand generation only when pre-compiled context is stale or unavailable.

## Implementation

### Updated Context Building

```typescript
private async buildContextualSystemPrompt(context: AssistantContext): Promise<string> {
  const user = await prisma.user.findUnique({
    where: { id: context.userId },
    select: { firstName: true, lastName: true, role: true }
  });

  // Get user daily context (unchanged)
  const userDailyContext = await userContextService.getContextForPrompt(
    context.userId,
    context.firmId
  );

  let caseBriefing = '';
  let richContext: RichCaseContext | null = null;

  if (context.caseId) {
    // Try to get pre-compiled rich context first
    richContext = await caseBriefingService.getRichContext(context.caseId);

    if (richContext && this.isContextFresh(richContext)) {
      // Use pre-compiled comprehensive context
      caseBriefing = this.formatRichContext(richContext);
      console.log('[AIAssistant] Using pre-compiled context', {
        caseId: context.caseId,
        contextAge: this.getContextAge(richContext),
        version: richContext.contextVersion
      });
    } else {
      // Fall back to on-demand (legacy behavior)
      caseBriefing = await caseBriefingService.getBriefingText(context.caseId);
      console.log('[AIAssistant] Using on-demand context (pre-compiled stale)', {
        caseId: context.caseId
      });
    }
  }

  return buildSystemPrompt({
    currentDate: getCurrentDateISO(),
    userName: `${user?.firstName} ${user?.lastName}`,
    userRole: user?.role || 'Unknown',
    caseId: context.caseId,
    caseName: context.caseName,
    userDailyContext,
    caseBriefing,
  });
}
```

### Freshness Check

```typescript
private isContextFresh(ctx: RichCaseContext): boolean {
  if (!ctx.lastComputedAt) return false;

  const ageHours = hoursBetween(ctx.lastComputedAt, new Date());

  // Context is fresh if computed within last 24 hours
  // OR if validUntil hasn't passed
  return ageHours < 24 || (ctx.validUntil && ctx.validUntil > new Date());
}

private getContextAge(ctx: RichCaseContext): string {
  const hours = hoursBetween(ctx.lastComputedAt, new Date());
  if (hours < 1) return 'sub 1 oră';
  if (hours < 24) return `${Math.round(hours)} ore`;
  return `${Math.round(hours / 24)} zile`;
}
```

### Rich Context Formatting

```typescript
private formatRichContext(ctx: RichCaseContext): string {
  const sections: string[] = [];

  // Basic case info (existing briefingText format)
  sections.push(ctx.briefingText);

  // Client context
  if (ctx.clientContext) {
    sections.push(clientContextService.formatForPrompt(ctx.clientContext));
  }

  // Document summaries
  if (ctx.documentSummaries?.length > 0) {
    sections.push('\n## Documente cheie:');
    sections.push(...ctx.documentSummaries.slice(0, 5).map(d =>
      `- **${d.title}** (${d.type}): ${d.summary}`
    ));
  }

  // Email thread context
  if (ctx.emailThreadSummaries?.threads?.length > 0) {
    sections.push('\n## Comunicări recente:');
    sections.push(...ctx.emailThreadSummaries.threads.slice(0, 3).map(t =>
      `- ${t.subject}: ${t.summary}${t.isUrgent ? ' ⚠️' : ''}`
    ));

    if (ctx.emailThreadSummaries.pendingActionItems?.length > 0) {
      sections.push('\n**Acțiuni în așteptare:**');
      sections.push(...ctx.emailThreadSummaries.pendingActionItems.map(a => `- ${a}`));
    }
  }

  // Health indicators
  if (ctx.caseHealthIndicators?.length > 0) {
    const warnings = ctx.caseHealthIndicators
      .filter(h => h.severity === 'high')
      .map(h => h.message);
    if (warnings.length > 0) {
      sections.push(`\n⚠️ **Atenție:** ${warnings.join(', ')}`);
    }
  }

  return sections.join('\n');
}
```

### Update CaseBriefingService

Add new method to retrieve rich context:

```typescript
async getRichContext(caseId: string): Promise<RichCaseContext | null> {
  const briefing = await prisma.caseBriefing.findUnique({
    where: { caseId }
  });

  if (!briefing) return null;

  return {
    briefingText: briefing.briefingText,
    briefingData: briefing.briefingData as CaseBriefingData,
    documentSummaries: briefing.documentSummaries as DocumentSummary[],
    emailThreadSummaries: briefing.emailThreadSummaries as EmailThreadContext,
    upcomingDeadlines: briefing.upcomingDeadlines as UpcomingDeadline[],
    contactContext: briefing.contactContext as ContactContext,
    clientContext: briefing.clientContext as ClientContext,
    caseHealthIndicators: briefing.caseHealthIndicators as HealthIndicator[],
    contextVersion: briefing.contextVersion,
    lastComputedAt: briefing.lastComputedAt,
    validUntil: briefing.validUntil
  };
}
```

## Done When

- [x] `getRichContext()` method added to caseBriefingService
- [x] Assistant uses pre-compiled context when available and fresh
- [x] Falls back gracefully to on-demand when stale
- [x] Context includes all rich sections (docs, emails, client)
- [x] Logs context source and age for monitoring
- [ ] Latency measurably reduced (check logs in production)
- [x] No breaking changes to existing behavior

## Files

- `services/gateway/src/services/ai-assistant.service.ts` - Update context building
- `services/gateway/src/services/case-briefing.service.ts` - Add `getRichContext()`

## Monitoring

Add logs for context usage tracking:

```
[AIAssistant] Using pre-compiled context { caseId, contextAge, version }
[AIAssistant] Using on-demand context (pre-compiled stale) { caseId }
[AIAssistant] Using on-demand context (no pre-compiled) { caseId }
```

## Dependencies

- OPS-261: Case Context Batch Processor

## Blockers For

None - final issue in epic.
