# OPS-261: Case Context Batch Processor

**Type**: Feature | **Priority**: P2-Medium | **Complexity**: L
**Status**: Completed

## Problem

Case briefings are generated on-demand, causing 200-500ms latency on cache miss. The current briefing is also limited (~400-600 tokens) and doesn't include document summaries, email context, or client information.

## Solution

Create `case-context.processor.ts` batch processor that runs nightly to pre-compile comprehensive case context (~2000-4000 tokens) for all active cases.

## Implementation

### Processor Structure

Following the morning briefings pattern:

```typescript
export class CaseContextProcessor implements BatchProcessor {
  readonly name = 'Case Context Pre-compilation';
  readonly feature = 'case_context';

  async process(ctx: BatchProcessorContext): Promise<BatchProcessorResult> {
    const activeCases = await this.getActiveCases(ctx.firmId);

    let processed = 0,
      failed = 0,
      totalTokens = 0,
      totalCost = 0;
    const errors: string[] = [];

    // Process in batches of 10 with concurrency limit
    for (const batch of chunk(activeCases, 10)) {
      const results = await Promise.allSettled(
        batch.map((caseItem) => this.processCase(caseItem, ctx))
      );

      for (const result of results) {
        if (result.status === 'fulfilled') {
          processed++;
          totalTokens += result.value.tokens;
          totalCost += result.value.cost;
        } else {
          failed++;
          errors.push(result.reason.message);
        }
      }

      ctx.onProgress?.(processed + failed, activeCases.length);
    }

    return { itemsProcessed: processed, itemsFailed: failed, totalTokens, totalCost, errors };
  }
}
```

### Case Processing Logic

```typescript
private async processCase(
  caseItem: Case,
  ctx: BatchProcessorContext
): Promise<{ tokens: number; cost: number }> {
  // Gather all context in parallel
  const [metadata, documents, emails, client] = await Promise.all([
    caseBriefingService.generateBriefingData(caseItem.id, ctx.firmId),
    documentSummaryService.getForCase(caseItem.id, ctx.firmId),
    emailContextService.getForCase(caseItem.id, ctx.firmId),
    clientContextService.getForClient(caseItem.clientId, ctx.firmId),
  ]);

  // Compile deadlines from tasks
  const upcomingDeadlines = await this.getUpcomingDeadlines(caseItem.id);

  // Calculate health indicators
  const healthIndicators = this.calculateHealthIndicators(caseItem, metadata);

  // Generate formatted briefing text
  const briefingText = this.formatBriefingText({
    metadata,
    documents,
    emails,
    client,
    upcomingDeadlines,
    healthIndicators
  });

  // Upsert to CaseBriefing table
  await prisma.caseBriefing.upsert({
    where: { caseId: caseItem.id },
    create: {
      caseId: caseItem.id,
      firmId: ctx.firmId,
      briefingText,
      briefingData: metadata,
      documentSummaries: documents,
      emailThreadSummaries: emails,
      clientContext: client,
      upcomingDeadlines,
      caseHealthIndicators: healthIndicators,
      contextVersion: 1,
      lastComputedAt: new Date(),
      validUntil: addHours(new Date(), 24),
    },
    update: {
      briefingText,
      briefingData: metadata,
      documentSummaries: documents,
      emailThreadSummaries: emails,
      clientContext: client,
      upcomingDeadlines,
      caseHealthIndicators: healthIndicators,
      lastComputedAt: new Date(),
      validUntil: addHours(new Date(), 24),
    }
  });

  return { tokens: 0, cost: 0 }; // No AI calls in this processor
}
```

### Active Case Detection

```typescript
private async getActiveCases(firmId: string): Promise<Case[]> {
  return prisma.case.findMany({
    where: {
      firmId,
      status: { not: 'CLOSED' },
      // Has activity in last 60 days OR has pending tasks
      OR: [
        { updatedAt: { gte: subDays(new Date(), 60) } },
        { tasks: { some: { status: { not: 'COMPLETED' } } } }
      ]
    },
    include: { client: true }
  });
}
```

### Health Indicators

```typescript
private calculateHealthIndicators(
  caseItem: Case,
  metadata: CaseBriefingData
): HealthIndicator[] {
  const indicators: HealthIndicator[] = [];

  // Staleness warning
  const daysSinceActivity = daysBetween(caseItem.updatedAt, new Date());
  if (daysSinceActivity > 14) {
    indicators.push({
      type: 'STALE',
      severity: daysSinceActivity > 30 ? 'high' : 'medium',
      message: `Fără activitate de ${daysSinceActivity} zile`
    });
  }

  // Overdue tasks
  if (metadata.overdueTaskCount > 0) {
    indicators.push({
      type: 'OVERDUE_TASKS',
      severity: 'high',
      message: `${metadata.overdueTaskCount} sarcini restante`
    });
  }

  // Upcoming deadline
  if (metadata.nextDeadline && isWithinDays(metadata.nextDeadline, 3)) {
    indicators.push({
      type: 'APPROACHING_DEADLINE',
      severity: 'medium',
      message: `Termen în ${daysUntil(metadata.nextDeadline)} zile`
    });
  }

  return indicators;
}
```

### Scheduling

- **Time**: 4 AM daily (before morning briefings at 5 AM)
- **Feature flag**: `case_context`
- **Default schedule**: `0 4 * * *`

## Done When

- [x] Processor registered with batch runner
- [x] Processes all active cases per firm
- [x] Gathers context from all 4 aggregation services
- [x] Generates comprehensive briefing text (~2000-4000 tokens)
- [x] Upserts to CaseBriefing with new fields
- [x] Feature flag `case_context` controls execution
- [x] Progress logged and errors captured
- [x] Handles edge cases (no documents, no emails, etc.)

## Files

- `services/gateway/src/batch/processors/case-context.processor.ts` - New processor
- `services/gateway/src/batch/index.ts` - Register processor

## Dependencies

- OPS-257: Extend CaseBriefing Schema for Rich Context
- OPS-258: Document Summary Aggregation Service
- OPS-259: Email Thread Summary Aggregation Service
- OPS-260: Client Context Aggregation Service

## Blockers For

- OPS-262: AI Assistant Pre-compiled Context Integration
