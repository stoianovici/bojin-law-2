# OPS-259: Email Thread Summary Aggregation Service

**Type**: Feature | **Priority**: P2-Medium | **Complexity**: M
**Status**: Completed
**Parallel**: Yes (with OPS-257, OPS-258, OPS-260)

## Problem

Current case briefing only shows email counts. AI assistant can't reference email content or identify action items without loading threads at request time, adding latency.

## Solution

Create `email-context.service.ts` that aggregates email thread summaries for a case, leveraging existing `ThreadSummary` table (populated by OPS-240 nightly processor).

## Implementation

### Service Interface

```typescript
interface EmailContextService {
  /**
   * Get aggregated email context for a case
   * Returns recent threads with summaries and action items
   * Target: ~600 tokens total
   */
  getForCase(caseId: string, firmId: string): Promise<EmailThreadContext>;
}

interface EmailThreadContext {
  threads: EmailThreadSummary[];
  pendingActionItems: string[];
  unreadCount: number;
  urgentCount: number;
}

interface EmailThreadSummary {
  threadId: string;
  subject: string;
  participants: string[];
  summary: string;
  actionItems: string[];
  lastMessageAt: string;
  isUrgent: boolean;
  isUnread: boolean;
}
```

### Thread Selection Logic

```typescript
async getForCase(caseId: string, firmId: string): Promise<EmailThreadContext> {
  // Get threads from last 30 days with existing summaries
  const threads = await prisma.email.findMany({
    where: {
      caseEmails: { some: { caseId } },
      receivedDateTime: { gte: thirtyDaysAgo() }
    },
    distinct: ['conversationId'],
    orderBy: { receivedDateTime: 'desc' },
    take: 15,
    include: {
      threadSummary: true  // From OPS-240
    }
  });

  // Aggregate action items across threads
  const pendingActionItems = threads
    .flatMap(t => t.threadSummary?.actionItems || [])
    .filter(item => !item.completed)
    .slice(0, 5);

  // Format for context
  return {
    threads: threads.slice(0, 8).map(formatThread),
    pendingActionItems,
    unreadCount: threads.filter(t => !t.isRead).length,
    urgentCount: threads.filter(t => t.threadSummary?.sentiment === 'urgent').length
  };
}
```

### Urgency Detection

Leverage existing ThreadSummary sentiment field:

- `urgent` → Court deadlines, immediate action required
- `negative` → Complaints, disputes, issues
- `neutral` → Standard correspondence
- `positive` → Confirmations, approvals

## Done When

- [x] Service queries threads with existing ThreadSummary data
- [x] Aggregates action items across threads (top 5)
- [x] Identifies urgent/unread threads
- [x] Returns structured context (~600 tokens max)
- [x] Handles cases with no emails gracefully
- [x] Unit tests for aggregation logic (13 tests passing)

## Files

- `services/gateway/src/services/email-context.service.ts` - New service
- `services/gateway/src/services/email-context.service.test.ts` - Unit tests

## Token Budget

| Component                                     | Tokens   |
| --------------------------------------------- | -------- |
| Per thread (subject + participants + summary) | ~60      |
| 8 threads max                                 | ~480     |
| Action items (5 max)                          | ~50      |
| Counts and metadata                           | ~20      |
| **Total**                                     | **~550** |

## Dependencies

- Relies on `ThreadSummary` table (OPS-240) being populated nightly

## Blockers For

- OPS-261: Case Context Batch Processor
