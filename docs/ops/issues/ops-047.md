# OPS-047: Event-Driven Summary Invalidation

**Status:** Implementing | **Priority:** P1-High | **Type:** Feature
**Created:** 2025-12-19 | **Depends on:** OPS-046 | **Parallel with:** OPS-048, OPS-049
**Sessions:** 1 | **Last Active:** 2025-12-19

## Summary

Implement event hooks that mark case summaries as stale when relevant data changes, triggering background regeneration.

## Background

Summaries should auto-update when case data changes. Rather than polling, we detect specific events and mark the summary as needing regeneration.

## Requirements

### 1. Event Detection Points

| Event               | Trigger Location                    | Action                        |
| ------------------- | ----------------------------------- | ----------------------------- |
| Document uploaded   | `DocumentService.uploadDocument()`  | Mark stale + create CaseEvent |
| Document deleted    | `DocumentService.deleteDocument()`  | Mark stale + delete CaseEvent |
| Email synced        | `EmailSyncService.syncEmails()`     | Mark stale + create CaseEvent |
| Note created        | `InternalNotesService.createNote()` | Mark stale + create CaseEvent |
| Note updated        | `InternalNotesService.updateNote()` | Mark stale (no new event)     |
| Task created        | `TaskService.createTask()`          | Mark stale + create CaseEvent |
| Task completed      | `TaskService.completeTask()`        | Mark stale + create CaseEvent |
| Case status changed | `CaseService.updateCase()`          | Mark stale + create CaseEvent |

### 2. Mark Stale Function

```typescript
// services/gateway/src/services/case-summary.service.ts

async markSummaryStale(caseId: string): Promise<void> {
  await prisma.caseSummary.upsert({
    where: { caseId },
    update: { isStale: true },
    create: {
      caseId,
      isStale: true,
      executiveSummary: '',
      currentStatus: '',
      keyDevelopments: [],
      openIssues: [],
      generatedAt: new Date(0), // Epoch = never generated
    },
  });

  // Enqueue regeneration job
  await this.enqueueRegeneration(caseId);
}
```

### 3. Create CaseEvent Function

```typescript
async createCaseEvent(input: {
  caseId: string;
  eventType: CaseEventType;
  sourceId: string;
  title: string;
  description?: string;
  importance: EventImportance;
  occurredAt: Date;
  actorId?: string;
}): Promise<void> {
  await prisma.caseEvent.upsert({
    where: {
      eventType_sourceId: {
        eventType: input.eventType,
        sourceId: input.sourceId,
      },
    },
    update: {
      title: input.title,
      description: input.description,
      importance: input.importance,
      occurredAt: input.occurredAt,
    },
    create: input,
  });
}
```

### 4. Fallback: Hourly Stale Check

If event triggers fail or are missed:

```typescript
// Cron job: runs every hour
async checkForStaleSummaries(): Promise<void> {
  // Find cases with data newer than their summary
  const staleCases = await prisma.$queryRaw`
    SELECT c.id as "caseId"
    FROM "Case" c
    LEFT JOIN "CaseSummary" cs ON cs."caseId" = c.id
    WHERE cs.id IS NULL
       OR cs."generatedAt" < (
         SELECT MAX(latest) FROM (
           SELECT MAX("createdAt") as latest FROM "Document" WHERE "caseId" = c.id
           UNION ALL
           SELECT MAX("receivedAt") FROM "Email" WHERE "caseId" = c.id
           UNION ALL
           SELECT MAX("createdAt") FROM "InternalNote" WHERE "caseId" = c.id
           UNION ALL
           SELECT MAX("updatedAt") FROM "Task" WHERE "caseId" = c.id
         ) as dates
       )
  `;

  for (const { caseId } of staleCases) {
    await this.markSummaryStale(caseId);
  }
}
```

### 5. Job Queue Integration

Use existing job queue (BullMQ or similar) to enqueue regeneration:

```typescript
async enqueueRegeneration(caseId: string): Promise<void> {
  // Debounce: if job already queued for this case, skip
  const existingJob = await regenerationQueue.getJob(`regen-${caseId}`);
  if (existingJob && await existingJob.isWaiting()) {
    return; // Already queued
  }

  await regenerationQueue.add(
    'regenerate-summary',
    { caseId },
    {
      jobId: `regen-${caseId}`,
      delay: 5000, // Wait 5s for batch changes
      removeOnComplete: true,
    }
  );
}
```

## Acceptance Criteria

- [ ] `markSummaryStale()` function implemented
- [ ] `createCaseEvent()` function implemented
- [ ] Hooks added to Document, Email, Note, Task services
- [ ] Hourly cron job for fallback stale detection
- [ ] Job queue integration for regeneration
- [ ] Debouncing prevents duplicate regeneration jobs

## Files to Modify

- `services/gateway/src/services/case-summary.service.ts` (new)
- `services/gateway/src/services/document.service.ts`
- `services/gateway/src/services/email.service.ts`
- `services/gateway/src/services/internal-notes.service.ts`
- `services/gateway/src/services/task.service.ts`
- `services/gateway/src/services/case.service.ts`

## Testing

- Unit tests for markSummaryStale and createCaseEvent
- Integration test: upload document â†’ verify summary marked stale
- Integration test: verify debouncing works (multiple events = one job)

## Session Log

- [2025-12-19T12:00:00Z] Issue created. Depends on OPS-046 schema changes.
- [2025-12-19T12:45:00Z] Session 1 started. OPS-046 preflight passed.
- [2025-12-19T13:15:00Z] Implementation complete:
  - Enhanced `case-summary.service.ts` with `markSummaryStale()`, `createCaseEvent()`, `deleteCaseEvent()`, `enqueueRegeneration()`
  - Created `summary-regeneration.worker.ts` with BullMQ queue, debouncing, hourly stale check
  - Added hooks to: DocumentService (resolvers), InternalNotesService, TaskService, classification-review.resolvers, CaseService (resolvers)
  - Fixed TypeScript errors (CaseStatusChanged enum, Urgent priority)
  - TypeScript check passed
